// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/bddf.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/bddf.proto</summary>
  public static partial class BddfReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/bddf.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BddfReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChFQcm90b3MvYmRkZi5wcm90bxIKYm9zZHluLmFwaRofZ29vZ2xlL3Byb3Rv",
            "YnVmL3RpbWVzdGFtcC5wcm90byKEAgoPRGVzY3JpcHRvckJsb2NrEjsKD2Zp",
            "bGVfZGVzY3JpcHRvchgBIAEoCzIgLmJvc2R5bi5hcGkuRmlsZUZvcm1hdERl",
            "c2NyaXB0b3JIABI5ChFzZXJpZXNfZGVzY3JpcHRvchgCIAEoCzIcLmJvc2R5",
            "bi5hcGkuU2VyaWVzRGVzY3JpcHRvckgAEjoKEnNlcmllc19ibG9ja19pbmRl",
            "eBgDIAEoCzIcLmJvc2R5bi5hcGkuU2VyaWVzQmxvY2tJbmRleEgAEisKCmZp",
            "bGVfaW5kZXgYBCABKAsyFS5ib3NkeW4uYXBpLkZpbGVJbmRleEgAQhAKDkRl",
            "c2NyaXB0b3JUeXBlInEKDkRhdGFEZXNjcmlwdG9yEhQKDHNlcmllc19pbmRl",
            "eBgBIAEoDRItCgl0aW1lc3RhbXAYAiABKAsyGi5nb29nbGUucHJvdG9idWYu",
            "VGltZXN0YW1wEhoKEmFkZGl0aW9uYWxfaW5kZXhlcxgDIAMoAyL/AgoURmls",
            "ZUZvcm1hdERlc2NyaXB0b3ISLgoHdmVyc2lvbhgBIAEoCzIdLmJvc2R5bi5h",
            "cGkuRmlsZUZvcm1hdFZlcnNpb24SRgoLYW5ub3RhdGlvbnMYAiADKAsyMS5i",
            "b3NkeW4uYXBpLkZpbGVGb3JtYXREZXNjcmlwdG9yLkFubm90YXRpb25zRW50",
            "cnkSRAoNY2hlY2tzdW1fdHlwZRgDIAEoDjItLmJvc2R5bi5hcGkuRmlsZUZv",
            "cm1hdERlc2NyaXB0b3IuQ2hlY2tTdW1UeXBlEhoKEmNoZWNrc3VtX251bV9i",
            "eXRlcxgEIAEoDRoyChBBbm5vdGF0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRIN",
            "CgV2YWx1ZRgCIAEoCToCOAEiWQoMQ2hlY2tTdW1UeXBlEhkKFUNIRUNLU1VN",
            "X1RZUEVfVU5LTk9XThAAEhYKEkNIRUNLU1VNX1RZUEVfTk9ORRABEhYKEkNI",
            "RUNLU1VNX1RZUEVfU0hBMRACIlYKEUZpbGVGb3JtYXRWZXJzaW9uEhUKDW1h",
            "am9yX3ZlcnNpb24YASABKA0SFQoNbWlub3JfdmVyc2lvbhgCIAEoDRITCgtw",
            "YXRjaF9sZXZlbBgDIAEoDSLaAwoQU2VyaWVzRGVzY3JpcHRvchIUCgxzZXJp",
            "ZXNfaW5kZXgYASABKA0SNwoRc2VyaWVzX2lkZW50aWZpZXIYAiABKAsyHC5i",
            "b3NkeW4uYXBpLlNlcmllc0lkZW50aWZpZXISFwoPaWRlbnRpZmllcl9oYXNo",
            "GAMgASgEEjkKDG1lc3NhZ2VfdHlwZRgEIAEoCzIhLmJvc2R5bi5hcGkuTWVz",
            "c2FnZVR5cGVEZXNjcmlwdG9ySAASMQoIcG9kX3R5cGUYBSABKAsyHS5ib3Nk",
            "eW4uYXBpLlBvZFR5cGVEZXNjcmlwdG9ySAASNwoLc3RydWN0X3R5cGUYBiAB",
            "KAsyIC5ib3NkeW4uYXBpLlN0cnVjdFR5cGVEZXNjcmlwdG9ySAASQgoLYW5u",
            "b3RhdGlvbnMYByADKAsyLS5ib3NkeW4uYXBpLlNlcmllc0Rlc2NyaXB0b3Iu",
            "QW5ub3RhdGlvbnNFbnRyeRIeChZhZGRpdGlvbmFsX2luZGV4X25hbWVzGAgg",
            "AygJEhMKC2Rlc2NyaXB0aW9uGAkgASgJGjIKEEFubm90YXRpb25zRW50cnkS",
            "CwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIKCghEYXRhVHlwZSJV",
            "ChVNZXNzYWdlVHlwZURlc2NyaXB0b3ISFAoMY29udGVudF90eXBlGAEgASgJ",
            "EhEKCXR5cGVfbmFtZRgCIAEoCRITCgtpc19tZXRhZGF0YRgDIAEoCCJRChFQ",
            "b2RUeXBlRGVzY3JpcHRvchIpCghwb2RfdHlwZRgBIAEoDjIXLmJvc2R5bi5h",
            "cGkuUG9kVHlwZUVudW0SEQoJZGltZW5zaW9uGAIgAygNIsABChRTdHJ1Y3RU",
            "eXBlRGVzY3JpcHRvchJmCh1rZXlfdG9fc2VyaWVzX2lkZW50aWZpZXJfaGFz",
            "aBgBIAMoCzI/LmJvc2R5bi5hcGkuU3RydWN0VHlwZURlc2NyaXB0b3IuS2V5",
            "VG9TZXJpZXNJZGVudGlmaWVySGFzaEVudHJ5GkAKHktleVRvU2VyaWVzSWRl",
            "bnRpZmllckhhc2hFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAQ6",
            "AjgBIosBCglGaWxlSW5kZXgSOAoSc2VyaWVzX2lkZW50aWZpZXJzGAEgAygL",
            "MhwuYm9zZHluLmFwaS5TZXJpZXNJZGVudGlmaWVyEiIKGnNlcmllc19ibG9j",
            "a19pbmRleF9vZmZzZXRzGAIgAygEEiAKGHNlcmllc19pZGVudGlmaWVyX2hh",
            "c2hlcxgDIAMoBCKLAgoQU2VyaWVzQmxvY2tJbmRleBIUCgxzZXJpZXNfaW5k",
            "ZXgYASABKA0SHgoWZGVzY3JpcHRvcl9maWxlX29mZnNldBgCIAEoBBI+Cg1i",
            "bG9ja19lbnRyaWVzGAMgAygLMicuYm9zZHluLmFwaS5TZXJpZXNCbG9ja0lu",
            "ZGV4LkJsb2NrRW50cnkSEwoLdG90YWxfYnl0ZXMYBCABKAQabAoKQmxvY2tF",
            "bnRyeRItCgl0aW1lc3RhbXAYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGlt",
            "ZXN0YW1wEhMKC2ZpbGVfb2Zmc2V0GAIgASgEEhoKEmFkZGl0aW9uYWxfaW5k",
            "ZXhlcxgDIAMoAyKKAQoQU2VyaWVzSWRlbnRpZmllchITCgtzZXJpZXNfdHlw",
            "ZRgBIAEoCRI0CgRzcGVjGAIgAygLMiYuYm9zZHluLmFwaS5TZXJpZXNJZGVu",
            "dGlmaWVyLlNwZWNFbnRyeRorCglTcGVjRW50cnkSCwoDa2V5GAEgASgJEg0K",
            "BXZhbHVlGAIgASgJOgI4ASrJAQoLUG9kVHlwZUVudW0SFAoQVFlQRV9VTlNQ",
            "RUNJRklFRBAAEg0KCVRZUEVfSU5UOBABEg4KClRZUEVfSU5UMTYQAhIOCgpU",
            "WVBFX0lOVDMyEAMSDgoKVFlQRV9JTlQ2NBAEEg4KClRZUEVfVUlOVDgQBRIP",
            "CgtUWVBFX1VJTlQxNhAGEg8KC1RZUEVfVUlOVDMyEAcSDwoLVFlQRV9VSU5U",
            "NjQQCBIQCgxUWVBFX0ZMT0FUMzIQCRIQCgxUWVBFX0ZMT0FUNjQQCmIGcHJv",
            "dG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Bosdyn.Api.PodTypeEnum), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.DescriptorBlock), global::Bosdyn.Api.DescriptorBlock.Parser, new[]{ "FileDescriptor", "SeriesDescriptor", "SeriesBlockIndex", "FileIndex" }, new[]{ "DescriptorType" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.DataDescriptor), global::Bosdyn.Api.DataDescriptor.Parser, new[]{ "SeriesIndex", "Timestamp", "AdditionalIndexes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FileFormatDescriptor), global::Bosdyn.Api.FileFormatDescriptor.Parser, new[]{ "Version", "Annotations", "ChecksumType", "ChecksumNumBytes" }, null, new[]{ typeof(global::Bosdyn.Api.FileFormatDescriptor.Types.CheckSumType) }, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FileFormatVersion), global::Bosdyn.Api.FileFormatVersion.Parser, new[]{ "MajorVersion", "MinorVersion", "PatchLevel" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SeriesDescriptor), global::Bosdyn.Api.SeriesDescriptor.Parser, new[]{ "SeriesIndex", "SeriesIdentifier", "IdentifierHash", "MessageType", "PodType", "StructType", "Annotations", "AdditionalIndexNames", "Description" }, new[]{ "DataType" }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.MessageTypeDescriptor), global::Bosdyn.Api.MessageTypeDescriptor.Parser, new[]{ "ContentType", "TypeName", "IsMetadata" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.PodTypeDescriptor), global::Bosdyn.Api.PodTypeDescriptor.Parser, new[]{ "PodType", "Dimension" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StructTypeDescriptor), global::Bosdyn.Api.StructTypeDescriptor.Parser, new[]{ "KeyToSeriesIdentifierHash" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FileIndex), global::Bosdyn.Api.FileIndex.Parser, new[]{ "SeriesIdentifiers", "SeriesBlockIndexOffsets", "SeriesIdentifierHashes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SeriesBlockIndex), global::Bosdyn.Api.SeriesBlockIndex.Parser, new[]{ "SeriesIndex", "DescriptorFileOffset", "BlockEntries", "TotalBytes" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry), global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry.Parser, new[]{ "Timestamp", "FileOffset", "AdditionalIndexes" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SeriesIdentifier), global::Bosdyn.Api.SeriesIdentifier.Parser, new[]{ "SeriesType", "Spec" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// "Plain old data" types which may be stored within POD data blocks.
  /// </summary>
  public enum PodTypeEnum {
    [pbr::OriginalName("TYPE_UNSPECIFIED")] TypeUnspecified = 0,
    [pbr::OriginalName("TYPE_INT8")] TypeInt8 = 1,
    [pbr::OriginalName("TYPE_INT16")] TypeInt16 = 2,
    [pbr::OriginalName("TYPE_INT32")] TypeInt32 = 3,
    [pbr::OriginalName("TYPE_INT64")] TypeInt64 = 4,
    [pbr::OriginalName("TYPE_UINT8")] TypeUint8 = 5,
    [pbr::OriginalName("TYPE_UINT16")] TypeUint16 = 6,
    [pbr::OriginalName("TYPE_UINT32")] TypeUint32 = 7,
    [pbr::OriginalName("TYPE_UINT64")] TypeUint64 = 8,
    [pbr::OriginalName("TYPE_FLOAT32")] TypeFloat32 = 9,
    [pbr::OriginalName("TYPE_FLOAT64")] TypeFloat64 = 10,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A Descriptor block typically describes a series of messages, but the descriptor at the
  ///  start of the file describes the contents of the file as a whole, and the descriptor
  ///  at the end of the file is an index structure to allow efficient access to the contents
  ///  of the file.
  /// </summary>
  public sealed partial class DescriptorBlock : pb::IMessage<DescriptorBlock> {
    private static readonly pb::MessageParser<DescriptorBlock> _parser = new pb::MessageParser<DescriptorBlock>(() => new DescriptorBlock());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DescriptorBlock> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DescriptorBlock() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DescriptorBlock(DescriptorBlock other) : this() {
      switch (other.DescriptorTypeCase) {
        case DescriptorTypeOneofCase.FileDescriptor:
          FileDescriptor = other.FileDescriptor.Clone();
          break;
        case DescriptorTypeOneofCase.SeriesDescriptor:
          SeriesDescriptor = other.SeriesDescriptor.Clone();
          break;
        case DescriptorTypeOneofCase.SeriesBlockIndex:
          SeriesBlockIndex = other.SeriesBlockIndex.Clone();
          break;
        case DescriptorTypeOneofCase.FileIndex:
          FileIndex = other.FileIndex.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DescriptorBlock Clone() {
      return new DescriptorBlock(this);
    }

    /// <summary>Field number for the "file_descriptor" field.</summary>
    public const int FileDescriptorFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FileFormatDescriptor FileDescriptor {
      get { return descriptorTypeCase_ == DescriptorTypeOneofCase.FileDescriptor ? (global::Bosdyn.Api.FileFormatDescriptor) descriptorType_ : null; }
      set {
        descriptorType_ = value;
        descriptorTypeCase_ = value == null ? DescriptorTypeOneofCase.None : DescriptorTypeOneofCase.FileDescriptor;
      }
    }

    /// <summary>Field number for the "series_descriptor" field.</summary>
    public const int SeriesDescriptorFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SeriesDescriptor SeriesDescriptor {
      get { return descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesDescriptor ? (global::Bosdyn.Api.SeriesDescriptor) descriptorType_ : null; }
      set {
        descriptorType_ = value;
        descriptorTypeCase_ = value == null ? DescriptorTypeOneofCase.None : DescriptorTypeOneofCase.SeriesDescriptor;
      }
    }

    /// <summary>Field number for the "series_block_index" field.</summary>
    public const int SeriesBlockIndexFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SeriesBlockIndex SeriesBlockIndex {
      get { return descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesBlockIndex ? (global::Bosdyn.Api.SeriesBlockIndex) descriptorType_ : null; }
      set {
        descriptorType_ = value;
        descriptorTypeCase_ = value == null ? DescriptorTypeOneofCase.None : DescriptorTypeOneofCase.SeriesBlockIndex;
      }
    }

    /// <summary>Field number for the "file_index" field.</summary>
    public const int FileIndexFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FileIndex FileIndex {
      get { return descriptorTypeCase_ == DescriptorTypeOneofCase.FileIndex ? (global::Bosdyn.Api.FileIndex) descriptorType_ : null; }
      set {
        descriptorType_ = value;
        descriptorTypeCase_ = value == null ? DescriptorTypeOneofCase.None : DescriptorTypeOneofCase.FileIndex;
      }
    }

    private object descriptorType_;
    /// <summary>Enum of possible cases for the "DescriptorType" oneof.</summary>
    public enum DescriptorTypeOneofCase {
      None = 0,
      FileDescriptor = 1,
      SeriesDescriptor = 2,
      SeriesBlockIndex = 3,
      FileIndex = 4,
    }
    private DescriptorTypeOneofCase descriptorTypeCase_ = DescriptorTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DescriptorTypeOneofCase DescriptorTypeCase {
      get { return descriptorTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDescriptorType() {
      descriptorTypeCase_ = DescriptorTypeOneofCase.None;
      descriptorType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DescriptorBlock);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DescriptorBlock other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FileDescriptor, other.FileDescriptor)) return false;
      if (!object.Equals(SeriesDescriptor, other.SeriesDescriptor)) return false;
      if (!object.Equals(SeriesBlockIndex, other.SeriesBlockIndex)) return false;
      if (!object.Equals(FileIndex, other.FileIndex)) return false;
      if (DescriptorTypeCase != other.DescriptorTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileDescriptor) hash ^= FileDescriptor.GetHashCode();
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesDescriptor) hash ^= SeriesDescriptor.GetHashCode();
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesBlockIndex) hash ^= SeriesBlockIndex.GetHashCode();
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileIndex) hash ^= FileIndex.GetHashCode();
      hash ^= (int) descriptorTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileDescriptor) {
        output.WriteRawTag(10);
        output.WriteMessage(FileDescriptor);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesDescriptor) {
        output.WriteRawTag(18);
        output.WriteMessage(SeriesDescriptor);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesBlockIndex) {
        output.WriteRawTag(26);
        output.WriteMessage(SeriesBlockIndex);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileIndex) {
        output.WriteRawTag(34);
        output.WriteMessage(FileIndex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileDescriptor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FileDescriptor);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesDescriptor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeriesDescriptor);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesBlockIndex) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeriesBlockIndex);
      }
      if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileIndex) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FileIndex);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DescriptorBlock other) {
      if (other == null) {
        return;
      }
      switch (other.DescriptorTypeCase) {
        case DescriptorTypeOneofCase.FileDescriptor:
          if (FileDescriptor == null) {
            FileDescriptor = new global::Bosdyn.Api.FileFormatDescriptor();
          }
          FileDescriptor.MergeFrom(other.FileDescriptor);
          break;
        case DescriptorTypeOneofCase.SeriesDescriptor:
          if (SeriesDescriptor == null) {
            SeriesDescriptor = new global::Bosdyn.Api.SeriesDescriptor();
          }
          SeriesDescriptor.MergeFrom(other.SeriesDescriptor);
          break;
        case DescriptorTypeOneofCase.SeriesBlockIndex:
          if (SeriesBlockIndex == null) {
            SeriesBlockIndex = new global::Bosdyn.Api.SeriesBlockIndex();
          }
          SeriesBlockIndex.MergeFrom(other.SeriesBlockIndex);
          break;
        case DescriptorTypeOneofCase.FileIndex:
          if (FileIndex == null) {
            FileIndex = new global::Bosdyn.Api.FileIndex();
          }
          FileIndex.MergeFrom(other.FileIndex);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Bosdyn.Api.FileFormatDescriptor subBuilder = new global::Bosdyn.Api.FileFormatDescriptor();
            if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileDescriptor) {
              subBuilder.MergeFrom(FileDescriptor);
            }
            input.ReadMessage(subBuilder);
            FileDescriptor = subBuilder;
            break;
          }
          case 18: {
            global::Bosdyn.Api.SeriesDescriptor subBuilder = new global::Bosdyn.Api.SeriesDescriptor();
            if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesDescriptor) {
              subBuilder.MergeFrom(SeriesDescriptor);
            }
            input.ReadMessage(subBuilder);
            SeriesDescriptor = subBuilder;
            break;
          }
          case 26: {
            global::Bosdyn.Api.SeriesBlockIndex subBuilder = new global::Bosdyn.Api.SeriesBlockIndex();
            if (descriptorTypeCase_ == DescriptorTypeOneofCase.SeriesBlockIndex) {
              subBuilder.MergeFrom(SeriesBlockIndex);
            }
            input.ReadMessage(subBuilder);
            SeriesBlockIndex = subBuilder;
            break;
          }
          case 34: {
            global::Bosdyn.Api.FileIndex subBuilder = new global::Bosdyn.Api.FileIndex();
            if (descriptorTypeCase_ == DescriptorTypeOneofCase.FileIndex) {
              subBuilder.MergeFrom(FileIndex);
            }
            input.ReadMessage(subBuilder);
            FileIndex = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A DataDescriptor describes a data block which immediately follows it in the file.
  /// A corresponding SeriesDescriptor with a matching series_index must precede this in the file.
  /// </summary>
  public sealed partial class DataDescriptor : pb::IMessage<DataDescriptor> {
    private static readonly pb::MessageParser<DataDescriptor> _parser = new pb::MessageParser<DataDescriptor>(() => new DataDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DataDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataDescriptor(DataDescriptor other) : this() {
      seriesIndex_ = other.seriesIndex_;
      timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
      additionalIndexes_ = other.additionalIndexes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataDescriptor Clone() {
      return new DataDescriptor(this);
    }

    /// <summary>Field number for the "series_index" field.</summary>
    public const int SeriesIndexFieldNumber = 1;
    private uint seriesIndex_;
    /// <summary>
    /// The series_index references the SeriesDescriptor to which the data following is associated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SeriesIndex {
      get { return seriesIndex_; }
      set {
        seriesIndex_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
    /// <summary>
    /// The time at which the data is considered to be captured/sampled.
    /// E.g., the shutter-close time of a captured image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "additional_indexes" field.</summary>
    public const int AdditionalIndexesFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_additionalIndexes_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> additionalIndexes_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Sometimes a visualizer will want to organize message by data timestamp, sometimes by
    ///  the time messages were published or logged.
    /// The additional_indexes field allows extra indexes or timestamps to be associated with
    ///  each data block for this purpose.
    /// Other identifying information may also be used here, such as the PID of the process which
    ///  originated the data (e.g., for detecting if and when that process restarted).
    /// The values in this field should correspond to the labels defined in "additional_index_names"
    ///  in the corresponding SeriesDescriptor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> AdditionalIndexes {
      get { return additionalIndexes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DataDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DataDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SeriesIndex != other.SeriesIndex) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if(!additionalIndexes_.Equals(other.additionalIndexes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SeriesIndex != 0) hash ^= SeriesIndex.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      hash ^= additionalIndexes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SeriesIndex != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SeriesIndex);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      additionalIndexes_.WriteTo(output, _repeated_additionalIndexes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SeriesIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SeriesIndex);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      size += additionalIndexes_.CalculateSize(_repeated_additionalIndexes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DataDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.SeriesIndex != 0) {
        SeriesIndex = other.SeriesIndex;
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
      additionalIndexes_.Add(other.additionalIndexes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SeriesIndex = input.ReadUInt32();
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 26:
          case 24: {
            additionalIndexes_.AddEntriesFrom(input, _repeated_additionalIndexes_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The first block in the file should be a DescriptorBlock containing a FileFormatDescriptor.
  /// FileFormatDescriptor indicates the file format version and annotations.
  /// Annotations describe things like the robot from which the log was taken and the release id.
  /// The format of annotation keys should be
  ///   {project-or-organization}/{annotation-name}
  /// For example, 'bosdyn/robot-serial-number'.
  /// </summary>
  public sealed partial class FileFormatDescriptor : pb::IMessage<FileFormatDescriptor> {
    private static readonly pb::MessageParser<FileFormatDescriptor> _parser = new pb::MessageParser<FileFormatDescriptor>(() => new FileFormatDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FileFormatDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatDescriptor(FileFormatDescriptor other) : this() {
      version_ = other.version_ != null ? other.version_.Clone() : null;
      annotations_ = other.annotations_.Clone();
      checksumType_ = other.checksumType_;
      checksumNumBytes_ = other.checksumNumBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatDescriptor Clone() {
      return new FileFormatDescriptor(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private global::Bosdyn.Api.FileFormatVersion version_;
    /// <summary>
    /// The version number of the BDDF file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FileFormatVersion Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "annotations" field.</summary>
    public const int AnnotationsFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_annotations_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> annotations_ = new pbc::MapField<string, string>();
    /// <summary>
    /// File/stream-wide annotations to describe the content of the file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Annotations {
      get { return annotations_; }
    }

    /// <summary>Field number for the "checksum_type" field.</summary>
    public const int ChecksumTypeFieldNumber = 3;
    private global::Bosdyn.Api.FileFormatDescriptor.Types.CheckSumType checksumType_ = 0;
    /// <summary>
    /// The type of checksum supported by this stream.
    /// For BDDF version 1.0.0 this should be SHA1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FileFormatDescriptor.Types.CheckSumType ChecksumType {
      get { return checksumType_; }
      set {
        checksumType_ = value;
      }
    }

    /// <summary>Field number for the "checksum_num_bytes" field.</summary>
    public const int ChecksumNumBytesFieldNumber = 4;
    private uint checksumNumBytes_;
    /// <summary>
    /// The number of bytes used for the BDDF checksum.
    /// For BDDF version 1.0.0 this should always be 20, even if CHECKSUM_NONE is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ChecksumNumBytes {
      get { return checksumNumBytes_; }
      set {
        checksumNumBytes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FileFormatDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FileFormatDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Version, other.Version)) return false;
      if (!Annotations.Equals(other.Annotations)) return false;
      if (ChecksumType != other.ChecksumType) return false;
      if (ChecksumNumBytes != other.ChecksumNumBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (version_ != null) hash ^= Version.GetHashCode();
      hash ^= Annotations.GetHashCode();
      if (ChecksumType != 0) hash ^= ChecksumType.GetHashCode();
      if (ChecksumNumBytes != 0) hash ^= ChecksumNumBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (version_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Version);
      }
      annotations_.WriteTo(output, _map_annotations_codec);
      if (ChecksumType != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ChecksumType);
      }
      if (ChecksumNumBytes != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(ChecksumNumBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (version_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Version);
      }
      size += annotations_.CalculateSize(_map_annotations_codec);
      if (ChecksumType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ChecksumType);
      }
      if (ChecksumNumBytes != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ChecksumNumBytes);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FileFormatDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.version_ != null) {
        if (version_ == null) {
          Version = new global::Bosdyn.Api.FileFormatVersion();
        }
        Version.MergeFrom(other.Version);
      }
      annotations_.Add(other.annotations_);
      if (other.ChecksumType != 0) {
        ChecksumType = other.ChecksumType;
      }
      if (other.ChecksumNumBytes != 0) {
        ChecksumNumBytes = other.ChecksumNumBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (version_ == null) {
              Version = new global::Bosdyn.Api.FileFormatVersion();
            }
            input.ReadMessage(Version);
            break;
          }
          case 18: {
            annotations_.AddEntriesFrom(input, _map_annotations_codec);
            break;
          }
          case 24: {
            ChecksumType = (global::Bosdyn.Api.FileFormatDescriptor.Types.CheckSumType) input.ReadEnum();
            break;
          }
          case 32: {
            ChecksumNumBytes = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FileFormatDescriptor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum CheckSumType {
        /// <summary>
        /// Checksum type is unspecified.  Should not be used.
        /// </summary>
        [pbr::OriginalName("CHECKSUM_TYPE_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// The writer of this stream is not computing a checksum.
        /// The stream checksum at the end of the file will be 160 bits all set to 0.
        /// </summary>
        [pbr::OriginalName("CHECKSUM_TYPE_NONE")] None = 1,
        /// <summary>
        /// A 160 bit SHA1 checksum will be included at the end of the stream.
        /// This checksum will be computed over all data before digest itself at the
        ///  end of the stream, and can be used to verify the stream was received uncorrupted.
        /// </summary>
        [pbr::OriginalName("CHECKSUM_TYPE_SHA1")] Sha1 = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// The current data file format is 1.0.0.
  /// </summary>
  public sealed partial class FileFormatVersion : pb::IMessage<FileFormatVersion> {
    private static readonly pb::MessageParser<FileFormatVersion> _parser = new pb::MessageParser<FileFormatVersion>(() => new FileFormatVersion());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FileFormatVersion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatVersion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatVersion(FileFormatVersion other) : this() {
      majorVersion_ = other.majorVersion_;
      minorVersion_ = other.minorVersion_;
      patchLevel_ = other.patchLevel_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileFormatVersion Clone() {
      return new FileFormatVersion(this);
    }

    /// <summary>Field number for the "major_version" field.</summary>
    public const int MajorVersionFieldNumber = 1;
    private uint majorVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MajorVersion {
      get { return majorVersion_; }
      set {
        majorVersion_ = value;
      }
    }

    /// <summary>Field number for the "minor_version" field.</summary>
    public const int MinorVersionFieldNumber = 2;
    private uint minorVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MinorVersion {
      get { return minorVersion_; }
      set {
        minorVersion_ = value;
      }
    }

    /// <summary>Field number for the "patch_level" field.</summary>
    public const int PatchLevelFieldNumber = 3;
    private uint patchLevel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PatchLevel {
      get { return patchLevel_; }
      set {
        patchLevel_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FileFormatVersion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FileFormatVersion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MajorVersion != other.MajorVersion) return false;
      if (MinorVersion != other.MinorVersion) return false;
      if (PatchLevel != other.PatchLevel) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MajorVersion != 0) hash ^= MajorVersion.GetHashCode();
      if (MinorVersion != 0) hash ^= MinorVersion.GetHashCode();
      if (PatchLevel != 0) hash ^= PatchLevel.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MajorVersion != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(MajorVersion);
      }
      if (MinorVersion != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(MinorVersion);
      }
      if (PatchLevel != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(PatchLevel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MajorVersion != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MajorVersion);
      }
      if (MinorVersion != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinorVersion);
      }
      if (PatchLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PatchLevel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FileFormatVersion other) {
      if (other == null) {
        return;
      }
      if (other.MajorVersion != 0) {
        MajorVersion = other.MajorVersion;
      }
      if (other.MinorVersion != 0) {
        MinorVersion = other.MinorVersion;
      }
      if (other.PatchLevel != 0) {
        PatchLevel = other.PatchLevel;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MajorVersion = input.ReadUInt32();
            break;
          }
          case 16: {
            MinorVersion = input.ReadUInt32();
            break;
          }
          case 24: {
            PatchLevel = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A description of a series of data blocks.
  /// These data blocks may either represent binary messages of a variable size, or they may
  ///  represent a sequence of samples of POD data samples: single/vector/matrix/... of integer
  ///  or floating-point values.
  /// </summary>
  public sealed partial class SeriesDescriptor : pb::IMessage<SeriesDescriptor> {
    private static readonly pb::MessageParser<SeriesDescriptor> _parser = new pb::MessageParser<SeriesDescriptor>(() => new SeriesDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SeriesDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesDescriptor(SeriesDescriptor other) : this() {
      seriesIndex_ = other.seriesIndex_;
      seriesIdentifier_ = other.seriesIdentifier_ != null ? other.seriesIdentifier_.Clone() : null;
      identifierHash_ = other.identifierHash_;
      annotations_ = other.annotations_.Clone();
      additionalIndexNames_ = other.additionalIndexNames_.Clone();
      description_ = other.description_;
      switch (other.DataTypeCase) {
        case DataTypeOneofCase.MessageType:
          MessageType = other.MessageType.Clone();
          break;
        case DataTypeOneofCase.PodType:
          PodType = other.PodType.Clone();
          break;
        case DataTypeOneofCase.StructType:
          StructType = other.StructType.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesDescriptor Clone() {
      return new SeriesDescriptor(this);
    }

    /// <summary>Field number for the "series_index" field.</summary>
    public const int SeriesIndexFieldNumber = 1;
    private uint seriesIndex_;
    /// <summary>
    /// This index for the series is unique within the data file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SeriesIndex {
      get { return seriesIndex_; }
      set {
        seriesIndex_ = value;
      }
    }

    /// <summary>Field number for the "series_identifier" field.</summary>
    public const int SeriesIdentifierFieldNumber = 2;
    private global::Bosdyn.Api.SeriesIdentifier seriesIdentifier_;
    /// <summary>
    /// This is the globally unique {key -> value} mapping to identify the series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SeriesIdentifier SeriesIdentifier {
      get { return seriesIdentifier_; }
      set {
        seriesIdentifier_ = value;
      }
    }

    /// <summary>Field number for the "identifier_hash" field.</summary>
    public const int IdentifierHashFieldNumber = 3;
    private ulong identifierHash_;
    /// <summary>
    /// This is a hash of the series_identifier.
    /// The hash is the first 64 bits (read as a big-endian encoded uint64_t) of
    ///  SHA1(S K1 V1 K2 V2 ...) where,
    ///   - S is series identifier text,
    ///   - K1 and V1 are the key and value of the first key and value of the `spec`,
    ///   - K2 and V2 are the second key and value of the spec, etc...
    /// Here, all strings are encoded as utf-8, and keys are sorted lexicographically using this
    ///  encoding (K1 &lt; K2 &lt; ...).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong IdentifierHash {
      get { return identifierHash_; }
      set {
        identifierHash_ = value;
      }
    }

    /// <summary>Field number for the "message_type" field.</summary>
    public const int MessageTypeFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.MessageTypeDescriptor MessageType {
      get { return dataTypeCase_ == DataTypeOneofCase.MessageType ? (global::Bosdyn.Api.MessageTypeDescriptor) dataType_ : null; }
      set {
        dataType_ = value;
        dataTypeCase_ = value == null ? DataTypeOneofCase.None : DataTypeOneofCase.MessageType;
      }
    }

    /// <summary>Field number for the "pod_type" field.</summary>
    public const int PodTypeFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PodTypeDescriptor PodType {
      get { return dataTypeCase_ == DataTypeOneofCase.PodType ? (global::Bosdyn.Api.PodTypeDescriptor) dataType_ : null; }
      set {
        dataType_ = value;
        dataTypeCase_ = value == null ? DataTypeOneofCase.None : DataTypeOneofCase.PodType;
      }
    }

    /// <summary>Field number for the "struct_type" field.</summary>
    public const int StructTypeFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.StructTypeDescriptor StructType {
      get { return dataTypeCase_ == DataTypeOneofCase.StructType ? (global::Bosdyn.Api.StructTypeDescriptor) dataType_ : null; }
      set {
        dataType_ = value;
        dataTypeCase_ = value == null ? DataTypeOneofCase.None : DataTypeOneofCase.StructType;
      }
    }

    /// <summary>Field number for the "annotations" field.</summary>
    public const int AnnotationsFieldNumber = 7;
    private static readonly pbc::MapField<string, string>.Codec _map_annotations_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 58);
    private readonly pbc::MapField<string, string> annotations_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Annotations are a {key -> value} mapping for associating additional information with
    ///  the series.
    /// The format of annotation keys should be
    ///   {project-or-organization}/{annotation-name}
    /// For example, 'bosdyn/channel-name', 'bosdyn/protobuf-type'.
    /// Annotation keys without a '/' are reserved.
    /// The only current key in the reserved namespace is 'units': e.g., {'units': 'm/s2'}.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Annotations {
      get { return annotations_; }
    }

    /// <summary>Field number for the "additional_index_names" field.</summary>
    public const int AdditionalIndexNamesFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_additionalIndexNames_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> additionalIndexNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Labels for additional index values which should be attached to each DataDescriptor
    ///  in the series.
    /// See the description of "additional_indexes" in DataDescriptor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AdditionalIndexNames {
      get { return additionalIndexNames_; }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 9;
    private string description_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object dataType_;
    /// <summary>Enum of possible cases for the "DataType" oneof.</summary>
    public enum DataTypeOneofCase {
      None = 0,
      MessageType = 4,
      PodType = 5,
      StructType = 6,
    }
    private DataTypeOneofCase dataTypeCase_ = DataTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataTypeOneofCase DataTypeCase {
      get { return dataTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataType() {
      dataTypeCase_ = DataTypeOneofCase.None;
      dataType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SeriesDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SeriesDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SeriesIndex != other.SeriesIndex) return false;
      if (!object.Equals(SeriesIdentifier, other.SeriesIdentifier)) return false;
      if (IdentifierHash != other.IdentifierHash) return false;
      if (!object.Equals(MessageType, other.MessageType)) return false;
      if (!object.Equals(PodType, other.PodType)) return false;
      if (!object.Equals(StructType, other.StructType)) return false;
      if (!Annotations.Equals(other.Annotations)) return false;
      if(!additionalIndexNames_.Equals(other.additionalIndexNames_)) return false;
      if (Description != other.Description) return false;
      if (DataTypeCase != other.DataTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SeriesIndex != 0) hash ^= SeriesIndex.GetHashCode();
      if (seriesIdentifier_ != null) hash ^= SeriesIdentifier.GetHashCode();
      if (IdentifierHash != 0UL) hash ^= IdentifierHash.GetHashCode();
      if (dataTypeCase_ == DataTypeOneofCase.MessageType) hash ^= MessageType.GetHashCode();
      if (dataTypeCase_ == DataTypeOneofCase.PodType) hash ^= PodType.GetHashCode();
      if (dataTypeCase_ == DataTypeOneofCase.StructType) hash ^= StructType.GetHashCode();
      hash ^= Annotations.GetHashCode();
      hash ^= additionalIndexNames_.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      hash ^= (int) dataTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SeriesIndex != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SeriesIndex);
      }
      if (seriesIdentifier_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SeriesIdentifier);
      }
      if (IdentifierHash != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(IdentifierHash);
      }
      if (dataTypeCase_ == DataTypeOneofCase.MessageType) {
        output.WriteRawTag(34);
        output.WriteMessage(MessageType);
      }
      if (dataTypeCase_ == DataTypeOneofCase.PodType) {
        output.WriteRawTag(42);
        output.WriteMessage(PodType);
      }
      if (dataTypeCase_ == DataTypeOneofCase.StructType) {
        output.WriteRawTag(50);
        output.WriteMessage(StructType);
      }
      annotations_.WriteTo(output, _map_annotations_codec);
      additionalIndexNames_.WriteTo(output, _repeated_additionalIndexNames_codec);
      if (Description.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(Description);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SeriesIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SeriesIndex);
      }
      if (seriesIdentifier_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeriesIdentifier);
      }
      if (IdentifierHash != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(IdentifierHash);
      }
      if (dataTypeCase_ == DataTypeOneofCase.MessageType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MessageType);
      }
      if (dataTypeCase_ == DataTypeOneofCase.PodType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodType);
      }
      if (dataTypeCase_ == DataTypeOneofCase.StructType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StructType);
      }
      size += annotations_.CalculateSize(_map_annotations_codec);
      size += additionalIndexNames_.CalculateSize(_repeated_additionalIndexNames_codec);
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SeriesDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.SeriesIndex != 0) {
        SeriesIndex = other.SeriesIndex;
      }
      if (other.seriesIdentifier_ != null) {
        if (seriesIdentifier_ == null) {
          SeriesIdentifier = new global::Bosdyn.Api.SeriesIdentifier();
        }
        SeriesIdentifier.MergeFrom(other.SeriesIdentifier);
      }
      if (other.IdentifierHash != 0UL) {
        IdentifierHash = other.IdentifierHash;
      }
      annotations_.Add(other.annotations_);
      additionalIndexNames_.Add(other.additionalIndexNames_);
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      switch (other.DataTypeCase) {
        case DataTypeOneofCase.MessageType:
          if (MessageType == null) {
            MessageType = new global::Bosdyn.Api.MessageTypeDescriptor();
          }
          MessageType.MergeFrom(other.MessageType);
          break;
        case DataTypeOneofCase.PodType:
          if (PodType == null) {
            PodType = new global::Bosdyn.Api.PodTypeDescriptor();
          }
          PodType.MergeFrom(other.PodType);
          break;
        case DataTypeOneofCase.StructType:
          if (StructType == null) {
            StructType = new global::Bosdyn.Api.StructTypeDescriptor();
          }
          StructType.MergeFrom(other.StructType);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SeriesIndex = input.ReadUInt32();
            break;
          }
          case 18: {
            if (seriesIdentifier_ == null) {
              SeriesIdentifier = new global::Bosdyn.Api.SeriesIdentifier();
            }
            input.ReadMessage(SeriesIdentifier);
            break;
          }
          case 24: {
            IdentifierHash = input.ReadUInt64();
            break;
          }
          case 34: {
            global::Bosdyn.Api.MessageTypeDescriptor subBuilder = new global::Bosdyn.Api.MessageTypeDescriptor();
            if (dataTypeCase_ == DataTypeOneofCase.MessageType) {
              subBuilder.MergeFrom(MessageType);
            }
            input.ReadMessage(subBuilder);
            MessageType = subBuilder;
            break;
          }
          case 42: {
            global::Bosdyn.Api.PodTypeDescriptor subBuilder = new global::Bosdyn.Api.PodTypeDescriptor();
            if (dataTypeCase_ == DataTypeOneofCase.PodType) {
              subBuilder.MergeFrom(PodType);
            }
            input.ReadMessage(subBuilder);
            PodType = subBuilder;
            break;
          }
          case 50: {
            global::Bosdyn.Api.StructTypeDescriptor subBuilder = new global::Bosdyn.Api.StructTypeDescriptor();
            if (dataTypeCase_ == DataTypeOneofCase.StructType) {
              subBuilder.MergeFrom(StructType);
            }
            input.ReadMessage(subBuilder);
            StructType = subBuilder;
            break;
          }
          case 58: {
            annotations_.AddEntriesFrom(input, _map_annotations_codec);
            break;
          }
          case 66: {
            additionalIndexNames_.AddEntriesFrom(input, _repeated_additionalIndexNames_codec);
            break;
          }
          case 74: {
            Description = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// If a data series contains a sequence of binary messages, the encoding and format of these
  ///  messages is described by a MesssageTypeDescriptor.
  /// </summary>
  public sealed partial class MessageTypeDescriptor : pb::IMessage<MessageTypeDescriptor> {
    private static readonly pb::MessageParser<MessageTypeDescriptor> _parser = new pb::MessageParser<MessageTypeDescriptor>(() => new MessageTypeDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MessageTypeDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageTypeDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageTypeDescriptor(MessageTypeDescriptor other) : this() {
      contentType_ = other.contentType_;
      typeName_ = other.typeName_;
      isMetadata_ = other.isMetadata_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageTypeDescriptor Clone() {
      return new MessageTypeDescriptor(this);
    }

    /// <summary>Field number for the "content_type" field.</summary>
    public const int ContentTypeFieldNumber = 1;
    private string contentType_ = "";
    /// <summary>
    /// Description of the content type.
    /// E.g., "application/protobuf", "image/jpeg", "text/csv", ...
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ContentType {
      get { return contentType_; }
      set {
        contentType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type_name" field.</summary>
    public const int TypeNameFieldNumber = 2;
    private string typeName_ = "";
    /// <summary>
    /// If content_type is "application/protobuf", this is the full-name of the protobuf type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TypeName {
      get { return typeName_; }
      set {
        typeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_metadata" field.</summary>
    public const int IsMetadataFieldNumber = 3;
    private bool isMetadata_;
    /// <summary>
    /// If true, message contents are necessary for interpreting other messages.
    /// If the content of this file is split into multiple output files, these messages should be
    ///  copied into each.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMetadata {
      get { return isMetadata_; }
      set {
        isMetadata_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MessageTypeDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MessageTypeDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContentType != other.ContentType) return false;
      if (TypeName != other.TypeName) return false;
      if (IsMetadata != other.IsMetadata) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ContentType.Length != 0) hash ^= ContentType.GetHashCode();
      if (TypeName.Length != 0) hash ^= TypeName.GetHashCode();
      if (IsMetadata != false) hash ^= IsMetadata.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ContentType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ContentType);
      }
      if (TypeName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(TypeName);
      }
      if (IsMetadata != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ContentType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContentType);
      }
      if (TypeName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TypeName);
      }
      if (IsMetadata != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MessageTypeDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.ContentType.Length != 0) {
        ContentType = other.ContentType;
      }
      if (other.TypeName.Length != 0) {
        TypeName = other.TypeName;
      }
      if (other.IsMetadata != false) {
        IsMetadata = other.IsMetadata;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ContentType = input.ReadString();
            break;
          }
          case 18: {
            TypeName = input.ReadString();
            break;
          }
          case 24: {
            IsMetadata = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// If a data series contains signals-style data of time-sampled "plain old datatypes", this
  ///  describes the content of the series.
  /// All POD data stored in data blocks is stored in little-endian byte order.
  /// Any number of samples may be stored within a given data block.
  /// </summary>
  public sealed partial class PodTypeDescriptor : pb::IMessage<PodTypeDescriptor> {
    private static readonly pb::MessageParser<PodTypeDescriptor> _parser = new pb::MessageParser<PodTypeDescriptor>(() => new PodTypeDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PodTypeDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PodTypeDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PodTypeDescriptor(PodTypeDescriptor other) : this() {
      podType_ = other.podType_;
      dimension_ = other.dimension_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PodTypeDescriptor Clone() {
      return new PodTypeDescriptor(this);
    }

    /// <summary>Field number for the "pod_type" field.</summary>
    public const int PodTypeFieldNumber = 1;
    private global::Bosdyn.Api.PodTypeEnum podType_ = 0;
    /// <summary>
    /// The type of machine-readable values stored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PodTypeEnum PodType {
      get { return podType_; }
      set {
        podType_ = value;
      }
    }

    /// <summary>Field number for the "dimension" field.</summary>
    public const int DimensionFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_dimension_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> dimension_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// If empty, indicates a single POD per sample.
    /// If one-element, indicates a vector of the given size per sample.
    /// If two-elements, indicates a matrix of the given size, and so on.
    /// An M x N x .. x P array of data is traversed from innermost (P) to outermost (M) dimension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> Dimension {
      get { return dimension_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PodTypeDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PodTypeDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PodType != other.PodType) return false;
      if(!dimension_.Equals(other.dimension_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PodType != 0) hash ^= PodType.GetHashCode();
      hash ^= dimension_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PodType != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) PodType);
      }
      dimension_.WriteTo(output, _repeated_dimension_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PodType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PodType);
      }
      size += dimension_.CalculateSize(_repeated_dimension_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PodTypeDescriptor other) {
      if (other == null) {
        return;
      }
      if (other.PodType != 0) {
        PodType = other.PodType;
      }
      dimension_.Add(other.dimension_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            PodType = (global::Bosdyn.Api.PodTypeEnum) input.ReadEnum();
            break;
          }
          case 18:
          case 16: {
            dimension_.AddEntriesFrom(input, _repeated_dimension_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A struct series is a composite formed by a set of other series whose messages or signals-ticks
  ///  are sampled at the same time.
  /// For example, all there may be a struct series for a set of signals variables, all from a
  ///  process with an 'update()' function within which all all variables are sampled with the
  ///  same timestamp.
  /// DataBlocks will not directly reference this series, but only child series of this series.
  /// Struct series may reference other struct series, but the series structure must be a directed
  ///  acyclic graph (DAG): no circular reference structures.
  /// </summary>
  public sealed partial class StructTypeDescriptor : pb::IMessage<StructTypeDescriptor> {
    private static readonly pb::MessageParser<StructTypeDescriptor> _parser = new pb::MessageParser<StructTypeDescriptor>(() => new StructTypeDescriptor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StructTypeDescriptor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StructTypeDescriptor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StructTypeDescriptor(StructTypeDescriptor other) : this() {
      keyToSeriesIdentifierHash_ = other.keyToSeriesIdentifierHash_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StructTypeDescriptor Clone() {
      return new StructTypeDescriptor(this);
    }

    /// <summary>Field number for the "key_to_series_identifier_hash" field.</summary>
    public const int KeyToSeriesIdentifierHashFieldNumber = 1;
    private static readonly pbc::MapField<string, ulong>.Codec _map_keyToSeriesIdentifierHash_codec
        = new pbc::MapField<string, ulong>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForUInt64(16), 10);
    private readonly pbc::MapField<string, ulong> keyToSeriesIdentifierHash_ = new pbc::MapField<string, ulong>();
    /// <summary>
    /// A map of a name-reference to a series, identified by its series_identifer_hash.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, ulong> KeyToSeriesIdentifierHash {
      get { return keyToSeriesIdentifierHash_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StructTypeDescriptor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StructTypeDescriptor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!KeyToSeriesIdentifierHash.Equals(other.KeyToSeriesIdentifierHash)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= KeyToSeriesIdentifierHash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keyToSeriesIdentifierHash_.WriteTo(output, _map_keyToSeriesIdentifierHash_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keyToSeriesIdentifierHash_.CalculateSize(_map_keyToSeriesIdentifierHash_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StructTypeDescriptor other) {
      if (other == null) {
        return;
      }
      keyToSeriesIdentifierHash_.Add(other.keyToSeriesIdentifierHash_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            keyToSeriesIdentifierHash_.AddEntriesFrom(input, _map_keyToSeriesIdentifierHash_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// As a file is closed, a DescriptorBlock containing a FileIndex should be written.
  /// The FileIndex summarizes the data series stored in the file and the location of the
  ///  block-indexes for each type in the file.
  /// Each series is assigned a "series_index" within the file, and this index may be used to
  ///  index into the repeated fields in this message.
  /// E.g., for the series with series_index N, you can access its SeriesIdentifier by accessing
  ///  element N the of the series_identifiers repeated field.
  /// </summary>
  public sealed partial class FileIndex : pb::IMessage<FileIndex> {
    private static readonly pb::MessageParser<FileIndex> _parser = new pb::MessageParser<FileIndex>(() => new FileIndex());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FileIndex> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileIndex() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileIndex(FileIndex other) : this() {
      seriesIdentifiers_ = other.seriesIdentifiers_.Clone();
      seriesBlockIndexOffsets_ = other.seriesBlockIndexOffsets_.Clone();
      seriesIdentifierHashes_ = other.seriesIdentifierHashes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FileIndex Clone() {
      return new FileIndex(this);
    }

    /// <summary>Field number for the "series_identifiers" field.</summary>
    public const int SeriesIdentifiersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.SeriesIdentifier> _repeated_seriesIdentifiers_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.SeriesIdentifier.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.SeriesIdentifier> seriesIdentifiers_ = new pbc::RepeatedField<global::Bosdyn.Api.SeriesIdentifier>();
    /// <summary>
    /// SeriesIdentifer for each series in this file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.SeriesIdentifier> SeriesIdentifiers {
      get { return seriesIdentifiers_; }
    }

    /// <summary>Field number for the "series_block_index_offsets" field.</summary>
    public const int SeriesBlockIndexOffsetsFieldNumber = 2;
    private static readonly pb::FieldCodec<ulong> _repeated_seriesBlockIndexOffsets_codec
        = pb::FieldCodec.ForUInt64(18);
    private readonly pbc::RepeatedField<ulong> seriesBlockIndexOffsets_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// The offset from the start of the file of the SeriesBlockIndex block for each series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> SeriesBlockIndexOffsets {
      get { return seriesBlockIndexOffsets_; }
    }

    /// <summary>Field number for the "series_identifier_hashes" field.</summary>
    public const int SeriesIdentifierHashesFieldNumber = 3;
    private static readonly pb::FieldCodec<ulong> _repeated_seriesIdentifierHashes_codec
        = pb::FieldCodec.ForUInt64(26);
    private readonly pbc::RepeatedField<ulong> seriesIdentifierHashes_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// The hash of the series_identifier for each series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> SeriesIdentifierHashes {
      get { return seriesIdentifierHashes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FileIndex);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FileIndex other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!seriesIdentifiers_.Equals(other.seriesIdentifiers_)) return false;
      if(!seriesBlockIndexOffsets_.Equals(other.seriesBlockIndexOffsets_)) return false;
      if(!seriesIdentifierHashes_.Equals(other.seriesIdentifierHashes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= seriesIdentifiers_.GetHashCode();
      hash ^= seriesBlockIndexOffsets_.GetHashCode();
      hash ^= seriesIdentifierHashes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      seriesIdentifiers_.WriteTo(output, _repeated_seriesIdentifiers_codec);
      seriesBlockIndexOffsets_.WriteTo(output, _repeated_seriesBlockIndexOffsets_codec);
      seriesIdentifierHashes_.WriteTo(output, _repeated_seriesIdentifierHashes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += seriesIdentifiers_.CalculateSize(_repeated_seriesIdentifiers_codec);
      size += seriesBlockIndexOffsets_.CalculateSize(_repeated_seriesBlockIndexOffsets_codec);
      size += seriesIdentifierHashes_.CalculateSize(_repeated_seriesIdentifierHashes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FileIndex other) {
      if (other == null) {
        return;
      }
      seriesIdentifiers_.Add(other.seriesIdentifiers_);
      seriesBlockIndexOffsets_.Add(other.seriesBlockIndexOffsets_);
      seriesIdentifierHashes_.Add(other.seriesIdentifierHashes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            seriesIdentifiers_.AddEntriesFrom(input, _repeated_seriesIdentifiers_codec);
            break;
          }
          case 18:
          case 16: {
            seriesBlockIndexOffsets_.AddEntriesFrom(input, _repeated_seriesBlockIndexOffsets_codec);
            break;
          }
          case 26:
          case 24: {
            seriesIdentifierHashes_.AddEntriesFrom(input, _repeated_seriesIdentifierHashes_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// This describes the location of the SeriesDescriptor DescriptorBlock for the series, and
  ///  the timestamp and location in the file of every data block in the series.
  /// </summary>
  public sealed partial class SeriesBlockIndex : pb::IMessage<SeriesBlockIndex> {
    private static readonly pb::MessageParser<SeriesBlockIndex> _parser = new pb::MessageParser<SeriesBlockIndex>(() => new SeriesBlockIndex());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SeriesBlockIndex> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesBlockIndex() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesBlockIndex(SeriesBlockIndex other) : this() {
      seriesIndex_ = other.seriesIndex_;
      descriptorFileOffset_ = other.descriptorFileOffset_;
      blockEntries_ = other.blockEntries_.Clone();
      totalBytes_ = other.totalBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesBlockIndex Clone() {
      return new SeriesBlockIndex(this);
    }

    /// <summary>Field number for the "series_index" field.</summary>
    public const int SeriesIndexFieldNumber = 1;
    private uint seriesIndex_;
    /// <summary>
    /// The series_index for the series described by this index block.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SeriesIndex {
      get { return seriesIndex_; }
      set {
        seriesIndex_ = value;
      }
    }

    /// <summary>Field number for the "descriptor_file_offset" field.</summary>
    public const int DescriptorFileOffsetFieldNumber = 2;
    private ulong descriptorFileOffset_;
    /// <summary>
    /// Offset of type descriptor block from start of file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong DescriptorFileOffset {
      get { return descriptorFileOffset_; }
      set {
        descriptorFileOffset_ = value;
      }
    }

    /// <summary>Field number for the "block_entries" field.</summary>
    public const int BlockEntriesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry> _repeated_blockEntries_codec
        = pb::FieldCodec.ForMessage(26, global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry> blockEntries_ = new pbc::RepeatedField<global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry>();
    /// <summary>
    /// The timestamp and location of each data block for this series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.SeriesBlockIndex.Types.BlockEntry> BlockEntries {
      get { return blockEntries_; }
    }

    /// <summary>Field number for the "total_bytes" field.</summary>
    public const int TotalBytesFieldNumber = 4;
    private ulong totalBytes_;
    /// <summary>
    /// The total size of the data stored in the data blocks of this series.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong TotalBytes {
      get { return totalBytes_; }
      set {
        totalBytes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SeriesBlockIndex);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SeriesBlockIndex other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SeriesIndex != other.SeriesIndex) return false;
      if (DescriptorFileOffset != other.DescriptorFileOffset) return false;
      if(!blockEntries_.Equals(other.blockEntries_)) return false;
      if (TotalBytes != other.TotalBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SeriesIndex != 0) hash ^= SeriesIndex.GetHashCode();
      if (DescriptorFileOffset != 0UL) hash ^= DescriptorFileOffset.GetHashCode();
      hash ^= blockEntries_.GetHashCode();
      if (TotalBytes != 0UL) hash ^= TotalBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SeriesIndex != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(SeriesIndex);
      }
      if (DescriptorFileOffset != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(DescriptorFileOffset);
      }
      blockEntries_.WriteTo(output, _repeated_blockEntries_codec);
      if (TotalBytes != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(TotalBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SeriesIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SeriesIndex);
      }
      if (DescriptorFileOffset != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DescriptorFileOffset);
      }
      size += blockEntries_.CalculateSize(_repeated_blockEntries_codec);
      if (TotalBytes != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(TotalBytes);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SeriesBlockIndex other) {
      if (other == null) {
        return;
      }
      if (other.SeriesIndex != 0) {
        SeriesIndex = other.SeriesIndex;
      }
      if (other.DescriptorFileOffset != 0UL) {
        DescriptorFileOffset = other.DescriptorFileOffset;
      }
      blockEntries_.Add(other.blockEntries_);
      if (other.TotalBytes != 0UL) {
        TotalBytes = other.TotalBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SeriesIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            DescriptorFileOffset = input.ReadUInt64();
            break;
          }
          case 26: {
            blockEntries_.AddEntriesFrom(input, _repeated_blockEntries_codec);
            break;
          }
          case 32: {
            TotalBytes = input.ReadUInt64();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SeriesBlockIndex message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class BlockEntry : pb::IMessage<BlockEntry> {
        private static readonly pb::MessageParser<BlockEntry> _parser = new pb::MessageParser<BlockEntry>(() => new BlockEntry());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BlockEntry> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SeriesBlockIndex.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockEntry() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockEntry(BlockEntry other) : this() {
          timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
          fileOffset_ = other.fileOffset_;
          additionalIndexes_ = other.additionalIndexes_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockEntry Clone() {
          return new BlockEntry(this);
        }

        /// <summary>Field number for the "timestamp" field.</summary>
        public const int TimestampFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp timestamp_;
        /// <summary>
        /// The timestamp of data in this block.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp Timestamp {
          get { return timestamp_; }
          set {
            timestamp_ = value;
          }
        }

        /// <summary>Field number for the "file_offset" field.</summary>
        public const int FileOffsetFieldNumber = 2;
        private ulong fileOffset_;
        /// <summary>
        /// The offset of the data block from the start of the file.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong FileOffset {
          get { return fileOffset_; }
          set {
            fileOffset_ = value;
          }
        }

        /// <summary>Field number for the "additional_indexes" field.</summary>
        public const int AdditionalIndexesFieldNumber = 3;
        private static readonly pb::FieldCodec<long> _repeated_additionalIndexes_codec
            = pb::FieldCodec.ForInt64(26);
        private readonly pbc::RepeatedField<long> additionalIndexes_ = new pbc::RepeatedField<long>();
        /// <summary>
        /// Values of the additional indexes for describing this block.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<long> AdditionalIndexes {
          get { return additionalIndexes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BlockEntry);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BlockEntry other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Timestamp, other.Timestamp)) return false;
          if (FileOffset != other.FileOffset) return false;
          if(!additionalIndexes_.Equals(other.additionalIndexes_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
          if (FileOffset != 0UL) hash ^= FileOffset.GetHashCode();
          hash ^= additionalIndexes_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (timestamp_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Timestamp);
          }
          if (FileOffset != 0UL) {
            output.WriteRawTag(16);
            output.WriteUInt64(FileOffset);
          }
          additionalIndexes_.WriteTo(output, _repeated_additionalIndexes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (timestamp_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
          }
          if (FileOffset != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FileOffset);
          }
          size += additionalIndexes_.CalculateSize(_repeated_additionalIndexes_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BlockEntry other) {
          if (other == null) {
            return;
          }
          if (other.timestamp_ != null) {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            Timestamp.MergeFrom(other.Timestamp);
          }
          if (other.FileOffset != 0UL) {
            FileOffset = other.FileOffset;
          }
          additionalIndexes_.Add(other.additionalIndexes_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (timestamp_ == null) {
                  Timestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(Timestamp);
                break;
              }
              case 16: {
                FileOffset = input.ReadUInt64();
                break;
              }
              case 26:
              case 24: {
                additionalIndexes_.AddEntriesFrom(input, _repeated_additionalIndexes_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// A key or description for selecting a message series.
  /// Because there may be multiple ways of describing a message series, we identify
  ///  them by a unique mapping of {key -> value}.
  /// A series_type corresponds to a set of keys which are expected in the mapping.
  /// A 'bosdyn:grpc:requests' series_type, containing GRPC robot-id request messages, might
  ///  thus be specified as:
  ///   {'service': 'robot_id', 'message': 'bosdyn.api.RobotIdRequest'}
  /// A 'bosdyn:logtick' series_type, containing a signals data variable from LogTick
  ///   annotations might be specified as:
  ///   {'varname': 'tablet.wifi.rssi', 'schema': 'tablet-comms', 'client': 'bd-tablet'}
  /// </summary>
  public sealed partial class SeriesIdentifier : pb::IMessage<SeriesIdentifier> {
    private static readonly pb::MessageParser<SeriesIdentifier> _parser = new pb::MessageParser<SeriesIdentifier>(() => new SeriesIdentifier());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SeriesIdentifier> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BddfReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesIdentifier() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesIdentifier(SeriesIdentifier other) : this() {
      seriesType_ = other.seriesType_;
      spec_ = other.spec_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SeriesIdentifier Clone() {
      return new SeriesIdentifier(this);
    }

    /// <summary>Field number for the "series_type" field.</summary>
    public const int SeriesTypeFieldNumber = 1;
    private string seriesType_ = "";
    /// <summary>
    /// This is the kind of spec, which should correspond to a set of keys which are expected
    ///  in the spec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SeriesType {
      get { return seriesType_; }
      set {
        seriesType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_spec_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> spec_ = new pbc::MapField<string, string>();
    /// <summary>
    /// This is the "key" for naming the series within the file.
    /// A key->value description which should be unique for this series within the file
    ///  with this series_type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Spec {
      get { return spec_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SeriesIdentifier);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SeriesIdentifier other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SeriesType != other.SeriesType) return false;
      if (!Spec.Equals(other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SeriesType.Length != 0) hash ^= SeriesType.GetHashCode();
      hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SeriesType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SeriesType);
      }
      spec_.WriteTo(output, _map_spec_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SeriesType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SeriesType);
      }
      size += spec_.CalculateSize(_map_spec_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SeriesIdentifier other) {
      if (other == null) {
        return;
      }
      if (other.SeriesType.Length != 0) {
        SeriesType = other.SeriesType;
      }
      spec_.Add(other.spec_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SeriesType = input.ReadString();
            break;
          }
          case 18: {
            spec_.AddEntriesFrom(input, _map_spec_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
