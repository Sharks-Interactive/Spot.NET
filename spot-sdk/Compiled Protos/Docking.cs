// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/docking.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api.Docking {

  /// <summary>Holder for reflection information generated from Protos/docking.proto</summary>
  public static partial class DockingReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/docking.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DockingReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChRQcm90b3MvZG9ja2luZy5wcm90bxISYm9zZHluLmFwaS5kb2NraW5nGhNQ",
            "cm90b3MvaGVhZGVyLnByb3RvGhJQcm90b3MvbGVhc2UucHJvdG8aH2dvb2ds",
            "ZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8iigIKFURvY2tpbmdDb21tYW5k",
            "UmVxdWVzdBIpCgZoZWFkZXIYASABKAsyGS5ib3NkeW4uYXBpLlJlcXVlc3RI",
            "ZWFkZXISIAoFbGVhc2UYAiABKAsyES5ib3NkeW4uYXBpLkxlYXNlEhoKEmRv",
            "Y2tpbmdfc3RhdGlvbl9pZBgDIAEoDRIYChBjbG9ja19pZGVudGlmaWVyGAQg",
            "ASgJEiwKCGVuZF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVz",
            "dGFtcBJAChJwcmVwX3Bvc2VfYmVoYXZpb3IYCSABKA4yJC5ib3NkeW4uYXBp",
            "LmRvY2tpbmcuUHJlcFBvc2VCZWhhdmlvciK9AwoWRG9ja2luZ0NvbW1hbmRS",
            "ZXNwb25zZRIqCgZoZWFkZXIYASABKAsyGi5ib3NkeW4uYXBpLlJlc3BvbnNl",
            "SGVhZGVyEjQKEGxlYXNlX3VzZV9yZXN1bHQYAiABKAsyGi5ib3NkeW4uYXBp",
            "LkxlYXNlVXNlUmVzdWx0EkEKBnN0YXR1cxgDIAEoDjIxLmJvc2R5bi5hcGku",
            "ZG9ja2luZy5Eb2NraW5nQ29tbWFuZFJlc3BvbnNlLlN0YXR1cxIaChJkb2Nr",
            "aW5nX2NvbW1hbmRfaWQYBSABKA0i4QEKBlN0YXR1cxISCg5TVEFUVVNfVU5L",
            "Tk9XThAAEg0KCVNUQVRVU19PSxABEhYKElNUQVRVU19FUlJPUl9MRUFTRRAE",
            "Eh8KG1NUQVRVU19FUlJPUl9ET0NLX05PVF9GT1VORBAFEhsKF1NUQVRVU19F",
            "UlJPUl9OT1RfRE9DS0VEEAYSJQohU1RBVFVTX0VSUk9SX0dSSVBQRVJfSE9M",
            "RElOR19JVEVNEAgSHgoaU1RBVFVTX0VSUk9SX05PVF9BVkFJTEFCTEUQCRIX",
            "ChNTVEFUVVNfRVJST1JfU1lTVEVNEAciZgodRG9ja2luZ0NvbW1hbmRGZWVk",
            "YmFja1JlcXVlc3QSKQoGaGVhZGVyGAEgASgLMhkuYm9zZHluLmFwaS5SZXF1",
            "ZXN0SGVhZGVyEhoKEmRvY2tpbmdfY29tbWFuZF9pZBgCIAEoDSK0BAoeRG9j",
            "a2luZ0NvbW1hbmRGZWVkYmFja1Jlc3BvbnNlEioKBmhlYWRlchgBIAEoCzIa",
            "LmJvc2R5bi5hcGkuUmVzcG9uc2VIZWFkZXISNAoQbGVhc2VfdXNlX3Jlc3Vs",
            "dBgCIAEoCzIaLmJvc2R5bi5hcGkuTGVhc2VVc2VSZXN1bHQSSQoGc3RhdHVz",
            "GAMgASgOMjkuYm9zZHluLmFwaS5kb2NraW5nLkRvY2tpbmdDb21tYW5kRmVl",
            "ZGJhY2tSZXNwb25zZS5TdGF0dXMi5AIKBlN0YXR1cxISCg5TVEFUVVNfVU5L",
            "Tk9XThAAEhYKElNUQVRVU19JTl9QUk9HUkVTUxABEhEKDVNUQVRVU19ET0NL",
            "RUQQAhIXChNTVEFUVVNfQVRfUFJFUF9QT1NFEAsSFQoRU1RBVFVTX01JU0FM",
            "SUdORUQQChIeChpTVEFUVVNfT0xEX0RPQ0tJTkdfQ09NTUFORBADEhoKFlNU",
            "QVRVU19FUlJPUl9ET0NLX0xPU1QQBBIWChJTVEFUVVNfRVJST1JfTEVBU0UQ",
            "BRIiCh5TVEFUVVNfRVJST1JfQ09NTUFORF9USU1FRF9PVVQQBhIcChhTVEFU",
            "VVNfRVJST1JfTk9fVElNRVNZTkMQBxIcChhTVEFUVVNfRVJST1JfVE9PX0RJ",
            "U1RBTlQQCBIeChpTVEFUVVNfRVJST1JfTk9UX0FWQUlMQUJMRRAMEhcKE1NU",
            "QVRVU19FUlJPUl9TWVNURU0QCSJbCgtDb25maWdSYW5nZRIQCghpZF9zdGFy",
            "dBgBIAEoDRIOCgZpZF9lbmQYAiABKA0SKgoEdHlwZRgDIAEoDjIcLmJvc2R5",
            "bi5hcGkuZG9ja2luZy5Eb2NrVHlwZSJEChdHZXREb2NraW5nQ29uZmlnUmVx",
            "dWVzdBIpCgZoZWFkZXIYASABKAsyGS5ib3NkeW4uYXBpLlJlcXVlc3RIZWFk",
            "ZXIifQoYR2V0RG9ja2luZ0NvbmZpZ1Jlc3BvbnNlEioKBmhlYWRlchgBIAEo",
            "CzIaLmJvc2R5bi5hcGkuUmVzcG9uc2VIZWFkZXISNQoMZG9ja19jb25maWdz",
            "GAIgAygLMh8uYm9zZHluLmFwaS5kb2NraW5nLkNvbmZpZ1JhbmdlIs0DCglE",
            "b2NrU3RhdGUSOgoGc3RhdHVzGAEgASgOMiouYm9zZHluLmFwaS5kb2NraW5n",
            "LkRvY2tTdGF0ZS5Eb2NrZWRTdGF0dXMSLwoJZG9ja190eXBlGAIgASgOMhwu",
            "Ym9zZHluLmFwaS5kb2NraW5nLkRvY2tUeXBlEg8KB2RvY2tfaWQYAyABKA0S",
            "PgoMcG93ZXJfc3RhdHVzGAQgASgOMiguYm9zZHluLmFwaS5kb2NraW5nLkRv",
            "Y2tTdGF0ZS5MaW5rU3RhdHVzIo0BCgxEb2NrZWRTdGF0dXMSFwoTRE9DS19T",
            "VEFUVVNfVU5LTk9XThAAEhYKEkRPQ0tfU1RBVFVTX0RPQ0tFRBABEhcKE0RP",
            "Q0tfU1RBVFVTX0RPQ0tJTkcQAhIYChRET0NLX1NUQVRVU19VTkRPQ0tFRBAD",
            "EhkKFURPQ0tfU1RBVFVTX1VORE9DS0lORxAEInIKCkxpbmtTdGF0dXMSFwoT",
            "TElOS19TVEFUVVNfVU5LTk9XThAAEhkKFUxJTktfU1RBVFVTX0RFVEVDVElO",
            "RxADEhkKFUxJTktfU1RBVFVTX0NPTk5FQ1RFRBABEhUKEUxJTktfU1RBVFVT",
            "X0VSUk9SEAIiQwoWR2V0RG9ja2luZ1N0YXRlUmVxdWVzdBIpCgZoZWFkZXIY",
            "ASABKAsyGS5ib3NkeW4uYXBpLlJlcXVlc3RIZWFkZXIieAoXR2V0RG9ja2lu",
            "Z1N0YXRlUmVzcG9uc2USKgoGaGVhZGVyGAEgASgLMhouYm9zZHluLmFwaS5S",
            "ZXNwb25zZUhlYWRlchIxCgpkb2NrX3N0YXRlGAIgASgLMh0uYm9zZHluLmFw",
            "aS5kb2NraW5nLkRvY2tTdGF0ZSpbCghEb2NrVHlwZRIVChFET0NLX1RZUEVf",
            "VU5LTk9XThAAEh8KG0RPQ0tfVFlQRV9DT05UQUNUX1BST1RPVFlQRRACEhcK",
            "E0RPQ0tfVFlQRV9TUE9UX0RPQ0sQAyqJAQoQUHJlcFBvc2VCZWhhdmlvchIV",
            "ChFQUkVQX1BPU0VfVU5LTk9XThAAEhYKElBSRVBfUE9TRV9VU0VfUE9TRRAB",
            "EhcKE1BSRVBfUE9TRV9TS0lQX1BPU0UQAhIXChNQUkVQX1BPU0VfT05MWV9Q",
            "T1NFEAMSFAoQUFJFUF9QT1NFX1VORE9DSxAEQg5CDERvY2tpbmdQcm90b2IG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.HeaderReflection.Descriptor, global::Bosdyn.Api.LeaseReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Bosdyn.Api.Docking.DockType), typeof(global::Bosdyn.Api.Docking.PrepPoseBehavior), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.DockingCommandRequest), global::Bosdyn.Api.Docking.DockingCommandRequest.Parser, new[]{ "Header", "Lease", "DockingStationId", "ClockIdentifier", "EndTime", "PrepPoseBehavior" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.DockingCommandResponse), global::Bosdyn.Api.Docking.DockingCommandResponse.Parser, new[]{ "Header", "LeaseUseResult", "Status", "DockingCommandId" }, null, new[]{ typeof(global::Bosdyn.Api.Docking.DockingCommandResponse.Types.Status) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.DockingCommandFeedbackRequest), global::Bosdyn.Api.Docking.DockingCommandFeedbackRequest.Parser, new[]{ "Header", "DockingCommandId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse), global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse.Parser, new[]{ "Header", "LeaseUseResult", "Status" }, null, new[]{ typeof(global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse.Types.Status) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.ConfigRange), global::Bosdyn.Api.Docking.ConfigRange.Parser, new[]{ "IdStart", "IdEnd", "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.GetDockingConfigRequest), global::Bosdyn.Api.Docking.GetDockingConfigRequest.Parser, new[]{ "Header" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.GetDockingConfigResponse), global::Bosdyn.Api.Docking.GetDockingConfigResponse.Parser, new[]{ "Header", "DockConfigs" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.DockState), global::Bosdyn.Api.Docking.DockState.Parser, new[]{ "Status", "DockType", "DockId", "PowerStatus" }, null, new[]{ typeof(global::Bosdyn.Api.Docking.DockState.Types.DockedStatus), typeof(global::Bosdyn.Api.Docking.DockState.Types.LinkStatus) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.GetDockingStateRequest), global::Bosdyn.Api.Docking.GetDockingStateRequest.Parser, new[]{ "Header" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Docking.GetDockingStateResponse), global::Bosdyn.Api.Docking.GetDockingStateResponse.Parser, new[]{ "Header", "DockState" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Type of dock
  /// </summary>
  public enum DockType {
    /// <summary>
    /// Unknown type of dock
    /// </summary>
    [pbr::OriginalName("DOCK_TYPE_UNKNOWN")] Unknown = 0,
    /// <summary>
    /// Prototype version SpotDock
    /// </summary>
    [pbr::OriginalName("DOCK_TYPE_CONTACT_PROTOTYPE")] ContactPrototype = 2,
    /// <summary>
    /// Production version SpotDock
    /// </summary>
    [pbr::OriginalName("DOCK_TYPE_SPOT_DOCK")] SpotDock = 3,
  }

  /// <summary>
  /// Defines how and whether we use the "pre-docking" pose.
  /// </summary>
  public enum PrepPoseBehavior {
    /// <summary>
    /// Default behavior, equivalent to PREP_POSE_USE_POSE.
    /// </summary>
    [pbr::OriginalName("PREP_POSE_UNKNOWN")] PrepPoseUnknown = 0,
    /// <summary>
    /// Goes to the pre-docking pose before docking.
    /// </summary>
    [pbr::OriginalName("PREP_POSE_USE_POSE")] PrepPoseUsePose = 1,
    /// <summary>
    /// Docks before going to the pre-docking pose.
    /// </summary>
    [pbr::OriginalName("PREP_POSE_SKIP_POSE")] PrepPoseSkipPose = 2,
    /// <summary>
    /// Goes to the pre-docking pose, and then returns SUCCESS without docking.
    /// </summary>
    [pbr::OriginalName("PREP_POSE_ONLY_POSE")] PrepPoseOnlyPose = 3,
    /// <summary>
    /// Use this enum to undock a currently docked robot.
    /// </summary>
    [pbr::OriginalName("PREP_POSE_UNDOCK")] PrepPoseUndock = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Message to command the robot to dock. \
  /// Note: If the robot is docked, you can undock the robot by issuing a command with
  /// `prep_pose_behavior=PREP_POSE_UNDOCK`. If undocking, `docking_station_id` is not required.
  /// </summary>
  public sealed partial class DockingCommandRequest : pb::IMessage<DockingCommandRequest> {
    private static readonly pb::MessageParser<DockingCommandRequest> _parser = new pb::MessageParser<DockingCommandRequest>(() => new DockingCommandRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockingCommandRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandRequest(DockingCommandRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      lease_ = other.lease_ != null ? other.lease_.Clone() : null;
      dockingStationId_ = other.dockingStationId_;
      clockIdentifier_ = other.clockIdentifier_;
      endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
      prepPoseBehavior_ = other.prepPoseBehavior_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandRequest Clone() {
      return new DockingCommandRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "lease" field.</summary>
    public const int LeaseFieldNumber = 2;
    private global::Bosdyn.Api.Lease lease_;
    /// <summary>
    /// The Lease to show ownership of the robot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Lease Lease {
      get { return lease_; }
      set {
        lease_ = value;
      }
    }

    /// <summary>Field number for the "docking_station_id" field.</summary>
    public const int DockingStationIdFieldNumber = 3;
    private uint dockingStationId_;
    /// <summary>
    /// ID of docking station to dock at.
    /// This is ignored if undocking the robot, the current dock is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DockingStationId {
      get { return dockingStationId_; }
      set {
        dockingStationId_ = value;
      }
    }

    /// <summary>Field number for the "clock_identifier" field.</summary>
    public const int ClockIdentifierFieldNumber = 4;
    private string clockIdentifier_ = "";
    /// <summary>
    /// Identifier provided by the time sync service to verify time sync between robot and client.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClockIdentifier {
      get { return clockIdentifier_; }
      set {
        clockIdentifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    /// The timestamp (in robot time) by which a command must finish executing.
    /// This is a required field and used to prevent runaway commands.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    /// <summary>Field number for the "prep_pose_behavior" field.</summary>
    public const int PrepPoseBehaviorFieldNumber = 9;
    private global::Bosdyn.Api.Docking.PrepPoseBehavior prepPoseBehavior_ = 0;
    /// <summary>
    /// [Optional] Specify the prep pose behavior
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.PrepPoseBehavior PrepPoseBehavior {
      get { return prepPoseBehavior_; }
      set {
        prepPoseBehavior_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockingCommandRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockingCommandRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(Lease, other.Lease)) return false;
      if (DockingStationId != other.DockingStationId) return false;
      if (ClockIdentifier != other.ClockIdentifier) return false;
      if (!object.Equals(EndTime, other.EndTime)) return false;
      if (PrepPoseBehavior != other.PrepPoseBehavior) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (lease_ != null) hash ^= Lease.GetHashCode();
      if (DockingStationId != 0) hash ^= DockingStationId.GetHashCode();
      if (ClockIdentifier.Length != 0) hash ^= ClockIdentifier.GetHashCode();
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      if (PrepPoseBehavior != 0) hash ^= PrepPoseBehavior.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (lease_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Lease);
      }
      if (DockingStationId != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(DockingStationId);
      }
      if (ClockIdentifier.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ClockIdentifier);
      }
      if (endTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(EndTime);
      }
      if (PrepPoseBehavior != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) PrepPoseBehavior);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (lease_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lease);
      }
      if (DockingStationId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DockingStationId);
      }
      if (ClockIdentifier.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClockIdentifier);
      }
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      if (PrepPoseBehavior != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PrepPoseBehavior);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockingCommandRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.lease_ != null) {
        if (lease_ == null) {
          Lease = new global::Bosdyn.Api.Lease();
        }
        Lease.MergeFrom(other.Lease);
      }
      if (other.DockingStationId != 0) {
        DockingStationId = other.DockingStationId;
      }
      if (other.ClockIdentifier.Length != 0) {
        ClockIdentifier = other.ClockIdentifier;
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
      if (other.PrepPoseBehavior != 0) {
        PrepPoseBehavior = other.PrepPoseBehavior;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (lease_ == null) {
              Lease = new global::Bosdyn.Api.Lease();
            }
            input.ReadMessage(Lease);
            break;
          }
          case 24: {
            DockingStationId = input.ReadUInt32();
            break;
          }
          case 34: {
            ClockIdentifier = input.ReadString();
            break;
          }
          case 42: {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EndTime);
            break;
          }
          case 72: {
            PrepPoseBehavior = (global::Bosdyn.Api.Docking.PrepPoseBehavior) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Response to a DockingCommandRequest
  /// </summary>
  public sealed partial class DockingCommandResponse : pb::IMessage<DockingCommandResponse> {
    private static readonly pb::MessageParser<DockingCommandResponse> _parser = new pb::MessageParser<DockingCommandResponse>(() => new DockingCommandResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockingCommandResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandResponse(DockingCommandResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      leaseUseResult_ = other.leaseUseResult_ != null ? other.leaseUseResult_.Clone() : null;
      status_ = other.status_;
      dockingCommandId_ = other.dockingCommandId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandResponse Clone() {
      return new DockingCommandResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    /// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "lease_use_result" field.</summary>
    public const int LeaseUseResultFieldNumber = 2;
    private global::Bosdyn.Api.LeaseUseResult leaseUseResult_;
    /// <summary>
    /// Details about how the lease was used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.LeaseUseResult LeaseUseResult {
      get { return leaseUseResult_; }
      set {
        leaseUseResult_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::Bosdyn.Api.Docking.DockingCommandResponse.Types.Status status_ = 0;
    /// <summary>
    /// Result of issued command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockingCommandResponse.Types.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "docking_command_id" field.</summary>
    public const int DockingCommandIdFieldNumber = 5;
    private uint dockingCommandId_;
    /// <summary>
    /// Unique identifier for the command (if accepted, `status=STATUS_OK`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DockingCommandId {
      get { return dockingCommandId_; }
      set {
        dockingCommandId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockingCommandResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockingCommandResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(LeaseUseResult, other.LeaseUseResult)) return false;
      if (Status != other.Status) return false;
      if (DockingCommandId != other.DockingCommandId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (leaseUseResult_ != null) hash ^= LeaseUseResult.GetHashCode();
      if (Status != 0) hash ^= Status.GetHashCode();
      if (DockingCommandId != 0) hash ^= DockingCommandId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (leaseUseResult_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LeaseUseResult);
      }
      if (Status != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Status);
      }
      if (DockingCommandId != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(DockingCommandId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (leaseUseResult_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LeaseUseResult);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (DockingCommandId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DockingCommandId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockingCommandResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.leaseUseResult_ != null) {
        if (leaseUseResult_ == null) {
          LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
        }
        LeaseUseResult.MergeFrom(other.LeaseUseResult);
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.DockingCommandId != 0) {
        DockingCommandId = other.DockingCommandId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (leaseUseResult_ == null) {
              LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
            }
            input.ReadMessage(LeaseUseResult);
            break;
          }
          case 24: {
            Status = (global::Bosdyn.Api.Docking.DockingCommandResponse.Types.Status) input.ReadEnum();
            break;
          }
          case 40: {
            DockingCommandId = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DockingCommandResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Status {
        /// <summary>
        /// Status is not specified.
        /// </summary>
        [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Docking command accepted
        /// </summary>
        [pbr::OriginalName("STATUS_OK")] Ok = 1,
        /// <summary>
        /// ERROR: Lease rejected
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_LEASE")] ErrorLease = 4,
        /// <summary>
        /// ERROR: Dock fiducial not found.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_DOCK_NOT_FOUND")] ErrorDockNotFound = 5,
        /// <summary>
        /// ERROR: Trying to undock while not docked
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_NOT_DOCKED")] ErrorNotDocked = 6,
        /// <summary>
        /// ERROR: Trying to dock when the arm is holding an object.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_GRIPPER_HOLDING_ITEM")] ErrorGripperHoldingItem = 8,
        /// <summary>
        /// ERROR: The dock is not available for docking.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_NOT_AVAILABLE")] ErrorNotAvailable = 9,
        /// <summary>
        /// ERROR: Internal system error during execution
        /// This error cannot be resolved by issuing a new DockingCommand
        /// Check the returned message for details
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_SYSTEM")] ErrorSystem = 7,
      }

    }
    #endregion

  }

  /// <summary>
  /// Message to get the status of a previously issued DockingCommand
  /// </summary>
  public sealed partial class DockingCommandFeedbackRequest : pb::IMessage<DockingCommandFeedbackRequest> {
    private static readonly pb::MessageParser<DockingCommandFeedbackRequest> _parser = new pb::MessageParser<DockingCommandFeedbackRequest>(() => new DockingCommandFeedbackRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockingCommandFeedbackRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackRequest(DockingCommandFeedbackRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      dockingCommandId_ = other.dockingCommandId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackRequest Clone() {
      return new DockingCommandFeedbackRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "docking_command_id" field.</summary>
    public const int DockingCommandIdFieldNumber = 2;
    private uint dockingCommandId_;
    /// <summary>
    /// Unique identifier of the command to get feedback for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DockingCommandId {
      get { return dockingCommandId_; }
      set {
        dockingCommandId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockingCommandFeedbackRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockingCommandFeedbackRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (DockingCommandId != other.DockingCommandId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (DockingCommandId != 0) hash ^= DockingCommandId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (DockingCommandId != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(DockingCommandId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (DockingCommandId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DockingCommandId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockingCommandFeedbackRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.DockingCommandId != 0) {
        DockingCommandId = other.DockingCommandId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 16: {
            DockingCommandId = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Response to a DockingCommandFeedbackRequest for a particualar docking command ID
  /// </summary>
  public sealed partial class DockingCommandFeedbackResponse : pb::IMessage<DockingCommandFeedbackResponse> {
    private static readonly pb::MessageParser<DockingCommandFeedbackResponse> _parser = new pb::MessageParser<DockingCommandFeedbackResponse>(() => new DockingCommandFeedbackResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockingCommandFeedbackResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackResponse(DockingCommandFeedbackResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      leaseUseResult_ = other.leaseUseResult_ != null ? other.leaseUseResult_.Clone() : null;
      status_ = other.status_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockingCommandFeedbackResponse Clone() {
      return new DockingCommandFeedbackResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    /// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "lease_use_result" field.</summary>
    public const int LeaseUseResultFieldNumber = 2;
    private global::Bosdyn.Api.LeaseUseResult leaseUseResult_;
    /// <summary>
    /// Details about how the lease was used (unset if unknown).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.LeaseUseResult LeaseUseResult {
      get { return leaseUseResult_; }
      set {
        leaseUseResult_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse.Types.Status status_ = 0;
    /// <summary>
    /// Current feedback of specified command ID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse.Types.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockingCommandFeedbackResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockingCommandFeedbackResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(LeaseUseResult, other.LeaseUseResult)) return false;
      if (Status != other.Status) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (leaseUseResult_ != null) hash ^= LeaseUseResult.GetHashCode();
      if (Status != 0) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (leaseUseResult_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LeaseUseResult);
      }
      if (Status != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (leaseUseResult_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LeaseUseResult);
      }
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockingCommandFeedbackResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.leaseUseResult_ != null) {
        if (leaseUseResult_ == null) {
          LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
        }
        LeaseUseResult.MergeFrom(other.LeaseUseResult);
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (leaseUseResult_ == null) {
              LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
            }
            input.ReadMessage(LeaseUseResult);
            break;
          }
          case 24: {
            Status = (global::Bosdyn.Api.Docking.DockingCommandFeedbackResponse.Types.Status) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DockingCommandFeedbackResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Status {
        /// <summary>
        /// Status is not specified.
        /// </summary>
        [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Docking command is executing.
        /// </summary>
        [pbr::OriginalName("STATUS_IN_PROGRESS")] InProgress = 1,
        /// <summary>
        /// Docking command succeeded, the robot is docked.
        /// </summary>
        [pbr::OriginalName("STATUS_DOCKED")] Docked = 2,
        /// <summary>
        /// Final success state for `PREP_POSE_ONLY_POSE` or `PREP_POSE_UNDOCK`.
        /// </summary>
        [pbr::OriginalName("STATUS_AT_PREP_POSE")] AtPrepPose = 11,
        /// <summary>
        /// Misaligned was detected between the robot and the dock.
        /// The docking command was aborted to save an ending up in an unrecoverable state, please try again.
        /// </summary>
        [pbr::OriginalName("STATUS_MISALIGNED")] Misaligned = 10,
        /// <summary>
        /// This DockingCommand overridden by new docking command.
        /// </summary>
        [pbr::OriginalName("STATUS_OLD_DOCKING_COMMAND")] OldDockingCommand = 3,
        /// <summary>
        /// ERROR: The sensed dock has been lost and is no longer found.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_DOCK_LOST")] ErrorDockLost = 4,
        /// <summary>
        /// ERROR: Lease rejected.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_LEASE")] ErrorLease = 5,
        /// <summary>
        /// ERROR: End time has been reached.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_COMMAND_TIMED_OUT")] ErrorCommandTimedOut = 6,
        /// <summary>
        /// ERROR: No Timesync with system.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_NO_TIMESYNC")] ErrorNoTimesync = 7,
        /// <summary>
        /// ERROR: Provided end time too far in the future.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_TOO_DISTANT")] ErrorTooDistant = 8,
        /// <summary>
        /// ERROR: The dock is not available for docking.
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_NOT_AVAILABLE")] ErrorNotAvailable = 12,
        /// <summary>
        /// ERROR: Internal system error during execution
        /// This error cannot be resolved by issuing a new DockingCommand
        /// Check the returned message for details
        /// </summary>
        [pbr::OriginalName("STATUS_ERROR_SYSTEM")] ErrorSystem = 9,
      }

    }
    #endregion

  }

  /// <summary>
  /// The configuration of a range of dock ID's
  /// </summary>
  public sealed partial class ConfigRange : pb::IMessage<ConfigRange> {
    private static readonly pb::MessageParser<ConfigRange> _parser = new pb::MessageParser<ConfigRange>(() => new ConfigRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConfigRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigRange(ConfigRange other) : this() {
      idStart_ = other.idStart_;
      idEnd_ = other.idEnd_;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigRange Clone() {
      return new ConfigRange(this);
    }

    /// <summary>Field number for the "id_start" field.</summary>
    public const int IdStartFieldNumber = 1;
    private uint idStart_;
    /// <summary>
    /// Starting ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint IdStart {
      get { return idStart_; }
      set {
        idStart_ = value;
      }
    }

    /// <summary>Field number for the "id_end" field.</summary>
    public const int IdEndFieldNumber = 2;
    private uint idEnd_;
    /// <summary>
    /// Ending ID
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint IdEnd {
      get { return idEnd_; }
      set {
        idEnd_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private global::Bosdyn.Api.Docking.DockType type_ = 0;
    /// <summary>
    /// Type of dock for this range
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConfigRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConfigRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IdStart != other.IdStart) return false;
      if (IdEnd != other.IdEnd) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IdStart != 0) hash ^= IdStart.GetHashCode();
      if (IdEnd != 0) hash ^= IdEnd.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IdStart != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(IdStart);
      }
      if (IdEnd != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(IdEnd);
      }
      if (Type != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IdStart != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(IdStart);
      }
      if (IdEnd != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(IdEnd);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConfigRange other) {
      if (other == null) {
        return;
      }
      if (other.IdStart != 0) {
        IdStart = other.IdStart;
      }
      if (other.IdEnd != 0) {
        IdEnd = other.IdEnd;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            IdStart = input.ReadUInt32();
            break;
          }
          case 16: {
            IdEnd = input.ReadUInt32();
            break;
          }
          case 24: {
            Type = (global::Bosdyn.Api.Docking.DockType) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class GetDockingConfigRequest : pb::IMessage<GetDockingConfigRequest> {
    private static readonly pb::MessageParser<GetDockingConfigRequest> _parser = new pb::MessageParser<GetDockingConfigRequest>(() => new GetDockingConfigRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetDockingConfigRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigRequest(GetDockingConfigRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigRequest Clone() {
      return new GetDockingConfigRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetDockingConfigRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetDockingConfigRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetDockingConfigRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
        }
      }
    }

  }

  public sealed partial class GetDockingConfigResponse : pb::IMessage<GetDockingConfigResponse> {
    private static readonly pb::MessageParser<GetDockingConfigResponse> _parser = new pb::MessageParser<GetDockingConfigResponse>(() => new GetDockingConfigResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetDockingConfigResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigResponse(GetDockingConfigResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      dockConfigs_ = other.dockConfigs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingConfigResponse Clone() {
      return new GetDockingConfigResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    /// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "dock_configs" field.</summary>
    public const int DockConfigsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.Docking.ConfigRange> _repeated_dockConfigs_codec
        = pb::FieldCodec.ForMessage(18, global::Bosdyn.Api.Docking.ConfigRange.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.Docking.ConfigRange> dockConfigs_ = new pbc::RepeatedField<global::Bosdyn.Api.Docking.ConfigRange>();
    /// <summary>
    /// A series of `ConfigRange` specifying details for dock ID numbers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.Docking.ConfigRange> DockConfigs {
      get { return dockConfigs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetDockingConfigResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetDockingConfigResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if(!dockConfigs_.Equals(other.dockConfigs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      hash ^= dockConfigs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      dockConfigs_.WriteTo(output, _repeated_dockConfigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      size += dockConfigs_.CalculateSize(_repeated_dockConfigs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetDockingConfigResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      dockConfigs_.Add(other.dockConfigs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            dockConfigs_.AddEntriesFrom(input, _repeated_dockConfigs_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Message describing the overall dock state of the robot, including power &amp; comms connections.  \
  /// Not tied to any particular DockingCommand ID.  \
  /// Note: [*] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED or DOCK_STATUS_DOCKING  \
  /// or DOCK_STATUS_UNDOCKING. \
  /// Note: [^] indicates fields which are only valid if the status is DOCK_STATUS_DOCKED.  \
  /// </summary>
  public sealed partial class DockState : pb::IMessage<DockState> {
    private static readonly pb::MessageParser<DockState> _parser = new pb::MessageParser<DockState>(() => new DockState());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DockState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockState(DockState other) : this() {
      status_ = other.status_;
      dockType_ = other.dockType_;
      dockId_ = other.dockId_;
      powerStatus_ = other.powerStatus_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DockState Clone() {
      return new DockState(this);
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 1;
    private global::Bosdyn.Api.Docking.DockState.Types.DockedStatus status_ = 0;
    /// <summary>
    /// Status of if the robot is on dock
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockState.Types.DockedStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "dock_type" field.</summary>
    public const int DockTypeFieldNumber = 2;
    private global::Bosdyn.Api.Docking.DockType dockType_ = 0;
    /// <summary>
    /// [*] Type of the dock
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockType DockType {
      get { return dockType_; }
      set {
        dockType_ = value;
      }
    }

    /// <summary>Field number for the "dock_id" field.</summary>
    public const int DockIdFieldNumber = 3;
    private uint dockId_;
    /// <summary>
    /// [*] ID of the dock
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DockId {
      get { return dockId_; }
      set {
        dockId_ = value;
      }
    }

    /// <summary>Field number for the "power_status" field.</summary>
    public const int PowerStatusFieldNumber = 4;
    private global::Bosdyn.Api.Docking.DockState.Types.LinkStatus powerStatus_ = 0;
    /// <summary>
    /// [^] Status of power detection from the dock
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockState.Types.LinkStatus PowerStatus {
      get { return powerStatus_; }
      set {
        powerStatus_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DockState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DockState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      if (DockType != other.DockType) return false;
      if (DockId != other.DockId) return false;
      if (PowerStatus != other.PowerStatus) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != 0) hash ^= Status.GetHashCode();
      if (DockType != 0) hash ^= DockType.GetHashCode();
      if (DockId != 0) hash ^= DockId.GetHashCode();
      if (PowerStatus != 0) hash ^= PowerStatus.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Status);
      }
      if (DockType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DockType);
      }
      if (DockId != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(DockId);
      }
      if (PowerStatus != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) PowerStatus);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (DockType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DockType);
      }
      if (DockId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DockId);
      }
      if (PowerStatus != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PowerStatus);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DockState other) {
      if (other == null) {
        return;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.DockType != 0) {
        DockType = other.DockType;
      }
      if (other.DockId != 0) {
        DockId = other.DockId;
      }
      if (other.PowerStatus != 0) {
        PowerStatus = other.PowerStatus;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = (global::Bosdyn.Api.Docking.DockState.Types.DockedStatus) input.ReadEnum();
            break;
          }
          case 16: {
            DockType = (global::Bosdyn.Api.Docking.DockType) input.ReadEnum();
            break;
          }
          case 24: {
            DockId = input.ReadUInt32();
            break;
          }
          case 32: {
            PowerStatus = (global::Bosdyn.Api.Docking.DockState.Types.LinkStatus) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DockState message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DockedStatus {
        /// <summary>
        /// Unknown
        /// </summary>
        [pbr::OriginalName("DOCK_STATUS_UNKNOWN")] DockStatusUnknown = 0,
        /// <summary>
        /// Robot is detected as on a dock
        /// </summary>
        [pbr::OriginalName("DOCK_STATUS_DOCKED")] DockStatusDocked = 1,
        /// <summary>
        /// Robot is currently running a docking command
        /// </summary>
        [pbr::OriginalName("DOCK_STATUS_DOCKING")] DockStatusDocking = 2,
        /// <summary>
        /// Robot is not detected as on dock
        /// </summary>
        [pbr::OriginalName("DOCK_STATUS_UNDOCKED")] DockStatusUndocked = 3,
        /// <summary>
        /// Robot is currently running an undocking command
        /// </summary>
        [pbr::OriginalName("DOCK_STATUS_UNDOCKING")] DockStatusUndocking = 4,
      }

      public enum LinkStatus {
        /// <summary>
        /// Unknown or Not applicable
        /// </summary>
        [pbr::OriginalName("LINK_STATUS_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// The link status is being detected
        /// </summary>
        [pbr::OriginalName("LINK_STATUS_DETECTING")] Detecting = 3,
        /// <summary>
        /// The link is detected as connected
        /// </summary>
        [pbr::OriginalName("LINK_STATUS_CONNECTED")] Connected = 1,
        /// <summary>
        /// The link could not be detected
        /// </summary>
        [pbr::OriginalName("LINK_STATUS_ERROR")] Error = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Message to get the overall docking state
  /// </summary>
  public sealed partial class GetDockingStateRequest : pb::IMessage<GetDockingStateRequest> {
    private static readonly pb::MessageParser<GetDockingStateRequest> _parser = new pb::MessageParser<GetDockingStateRequest>(() => new GetDockingStateRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetDockingStateRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateRequest(GetDockingStateRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateRequest Clone() {
      return new GetDockingStateRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetDockingStateRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetDockingStateRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetDockingStateRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Response of a GetDockingStateRequest
  /// </summary>
  public sealed partial class GetDockingStateResponse : pb::IMessage<GetDockingStateResponse> {
    private static readonly pb::MessageParser<GetDockingStateResponse> _parser = new pb::MessageParser<GetDockingStateResponse>(() => new GetDockingStateResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetDockingStateResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.Docking.DockingReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateResponse(GetDockingStateResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      dockState_ = other.dockState_ != null ? other.dockState_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetDockingStateResponse Clone() {
      return new GetDockingStateResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    /// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "dock_state" field.</summary>
    public const int DockStateFieldNumber = 2;
    private global::Bosdyn.Api.Docking.DockState dockState_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Docking.DockState DockState {
      get { return dockState_; }
      set {
        dockState_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetDockingStateResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetDockingStateResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(DockState, other.DockState)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (dockState_ != null) hash ^= DockState.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (dockState_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DockState);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (dockState_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DockState);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetDockingStateResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.dockState_ != null) {
        if (dockState_ == null) {
          DockState = new global::Bosdyn.Api.Docking.DockState();
        }
        DockState.MergeFrom(other.DockState);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (dockState_ == null) {
              DockState = new global::Bosdyn.Api.Docking.DockState();
            }
            input.ReadMessage(DockState);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
