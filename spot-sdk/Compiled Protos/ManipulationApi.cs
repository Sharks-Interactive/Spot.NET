// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/manipulation_api.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/manipulation_api.proto</summary>
  public static partial class ManipulationApiReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/manipulation_api.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ManipulationApiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch1Qcm90b3MvbWFuaXB1bGF0aW9uX2FwaS5wcm90bxIKYm9zZHluLmFwaRoV",
            "UHJvdG9zL2dlb21ldHJ5LnByb3RvGhNQcm90b3MvaGVhZGVyLnByb3RvGhJQ",
            "cm90b3MvaW1hZ2UucHJvdG8aElByb3Rvcy9sZWFzZS5wcm90bxoYUHJvdG9z",
            "L3JvYm90X3N0YXRlLnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMu",
            "cHJvdG8ivAEKFldhbGtUb09iamVjdFJheUluV29ybGQSLAoScmF5X3N0YXJ0",
            "X3J0X2ZyYW1lGAEgASgLMhAuYm9zZHluLmFwaS5WZWMzEioKEHJheV9lbmRf",
            "cnRfZnJhbWUYAiABKAsyEC5ib3NkeW4uYXBpLlZlYzMSEgoKZnJhbWVfbmFt",
            "ZRgDIAEoCRI0Cg9vZmZzZXRfZGlzdGFuY2UYBCABKAsyGy5nb29nbGUucHJv",
            "dG9idWYuRmxvYXRWYWx1ZSKTAgoTV2Fsa1RvT2JqZWN0SW5JbWFnZRIiCghw",
            "aXhlbF94eRgBIAEoCzIQLmJvc2R5bi5hcGkuVmVjMhJFCh50cmFuc2Zvcm1z",
            "X3NuYXBzaG90X2Zvcl9jYW1lcmEYAiABKAsyHS5ib3NkeW4uYXBpLkZyYW1l",
            "VHJlZVNuYXBzaG90Eh8KF2ZyYW1lX25hbWVfaW1hZ2Vfc2Vuc29yGAMgASgJ",
            "EjoKDGNhbWVyYV9tb2RlbBgEIAEoCzIkLmJvc2R5bi5hcGkuSW1hZ2VTb3Vy",
            "Y2UuUGluaG9sZU1vZGVsEjQKD29mZnNldF9kaXN0YW5jZRgFIAEoCzIbLmdv",
            "b2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlIoMCChRQaWNrT2JqZWN0UmF5SW5X",
            "b3JsZBIsChJyYXlfc3RhcnRfcnRfZnJhbWUYASABKAsyEC5ib3NkeW4uYXBp",
            "LlZlYzMSKgoQcmF5X2VuZF9ydF9mcmFtZRgCIAEoCzIQLmJvc2R5bi5hcGku",
            "VmVjMxISCgpmcmFtZV9uYW1lGAYgASgJEi0KDGdyYXNwX3BhcmFtcxgKIAEo",
            "CzIXLmJvc2R5bi5hcGkuR3Jhc3BQYXJhbXMSMAoOd2Fsa19nYXplX21vZGUY",
            "BCABKA4yGC5ib3NkeW4uYXBpLldhbGtHYXplTW9kZUoECAMQBEoECAUQBkoE",
            "CAcQCEoECAgQCUoECAkQCiIXChVQaWNrT2JqZWN0RXhlY3V0ZVBsYW4ikgEK",
            "ClBpY2tPYmplY3QSEgoKZnJhbWVfbmFtZRgBIAEoCRIpCg9vYmplY3RfcnRf",
            "ZnJhbWUYAiABKAsyEC5ib3NkeW4uYXBpLlZlYzMSLQoMZ3Jhc3BfcGFyYW1z",
            "GAMgASgLMhcuYm9zZHluLmFwaS5HcmFzcFBhcmFtc0oECAQQBUoECAUQBkoE",
            "CAYQB0oECAcQCCLUAgoRUGlja09iamVjdEluSW1hZ2USIgoIcGl4ZWxfeHkY",
            "ASABKAsyEC5ib3NkeW4uYXBpLlZlYzISRQoedHJhbnNmb3Jtc19zbmFwc2hv",
            "dF9mb3JfY2FtZXJhGAIgASgLMh0uYm9zZHluLmFwaS5GcmFtZVRyZWVTbmFw",
            "c2hvdBIfChdmcmFtZV9uYW1lX2ltYWdlX3NlbnNvchgDIAEoCRI6CgxjYW1l",
            "cmFfbW9kZWwYBCABKAsyJC5ib3NkeW4uYXBpLkltYWdlU291cmNlLlBpbmhv",
            "bGVNb2RlbBItCgxncmFzcF9wYXJhbXMYCiABKAsyFy5ib3NkeW4uYXBpLkdy",
            "YXNwUGFyYW1zEjAKDndhbGtfZ2F6ZV9tb2RlGAkgASgOMhguYm9zZHluLmFw",
            "aS5XYWxrR2F6ZU1vZGVKBAgFEAZKBAgGEAdKBAgHEAhKBAgIEAkinAIKC0dy",
            "YXNwUGFyYW1zEh8KF2dyYXNwX3BhbG1fdG9fZmluZ2VydGlwGAEgASgCEh8K",
            "F2dyYXNwX3BhcmFtc19mcmFtZV9uYW1lGAIgASgJEj8KFWFsbG93YWJsZV9v",
            "cmllbnRhdGlvbhgDIAMoCzIgLmJvc2R5bi5hcGkuQWxsb3dhYmxlT3JpZW50",
            "YXRpb24SQAoTcG9zaXRpb25fY29uc3RyYWludBgEIAEoDjIjLmJvc2R5bi5h",
            "cGkuR3Jhc3BQb3NpdGlvbkNvbnN0cmFpbnQSSAoabWFuaXB1bGF0aW9uX2Nh",
            "bWVyYV9zb3VyY2UYBSABKA4yJC5ib3NkeW4uYXBpLk1hbmlwdWxhdGlvbkNh",
            "bWVyYVNvdXJjZSLyAQoUQWxsb3dhYmxlT3JpZW50YXRpb24SRAoXcm90YXRp",
            "b25fd2l0aF90b2xlcmFuY2UYASABKAsyIS5ib3NkeW4uYXBpLlJvdGF0aW9u",
            "V2l0aFRvbGVyYW5jZUgAElMKH3ZlY3Rvcl9hbGlnbm1lbnRfd2l0aF90b2xl",
            "cmFuY2UYAiABKAsyKC5ib3NkeW4uYXBpLlZlY3RvckFsaWdubWVudFdpdGhU",
            "b2xlcmFuY2VIABIxCg1zcXVlZXplX2dyYXNwGAMgASgLMhguYm9zZHluLmFw",
            "aS5TcXVlZXplR3Jhc3BIAEIMCgpjb25zdHJhaW50ImcKFVJvdGF0aW9uV2l0",
            "aFRvbGVyYW5jZRIzChNyb3RhdGlvbl9ld3J0X2ZyYW1lGAEgASgLMhYuYm9z",
            "ZHluLmFwaS5RdWF0ZXJuaW9uEhkKEXRocmVzaG9sZF9yYWRpYW5zGAIgASgC",
            "IqoBChxWZWN0b3JBbGlnbm1lbnRXaXRoVG9sZXJhbmNlEjYKHGF4aXNfb25f",
            "Z3JpcHBlcl9ld3J0X2dyaXBwZXIYASABKAsyEC5ib3NkeW4uYXBpLlZlYzMS",
            "NwodYXhpc190b19hbGlnbl93aXRoX2V3cnRfZnJhbWUYAiABKAsyEC5ib3Nk",
            "eW4uYXBpLlZlYzMSGQoRdGhyZXNob2xkX3JhZGlhbnMYAyABKAIiMAoMU3F1",
            "ZWV6ZUdyYXNwEiAKGHNxdWVlemVfZ3Jhc3BfZGlzYWxsb3dlZBgBIAEoCCJo",
            "Ch5NYW5pcHVsYXRpb25BcGlGZWVkYmFja1JlcXVlc3QSKQoGaGVhZGVyGAEg",
            "ASgLMhkuYm9zZHluLmFwaS5SZXF1ZXN0SGVhZGVyEhsKE21hbmlwdWxhdGlv",
            "bl9jbWRfaWQYAiABKAUi9gEKH01hbmlwdWxhdGlvbkFwaUZlZWRiYWNrUmVz",
            "cG9uc2USKgoGaGVhZGVyGAEgASgLMhouYm9zZHluLmFwaS5SZXNwb25zZUhl",
            "YWRlchIbChNtYW5pcHVsYXRpb25fY21kX2lkGAQgASgFEjwKDWN1cnJlbnRf",
            "c3RhdGUYAiABKA4yJS5ib3NkeW4uYXBpLk1hbmlwdWxhdGlvbkZlZWRiYWNr",
            "U3RhdGUSTAoldHJhbnNmb3Jtc19zbmFwc2hvdF9tYW5pcHVsYXRpb25fZGF0",
            "YRgDIAEoCzIdLmJvc2R5bi5hcGkuRnJhbWVUcmVlU25hcHNob3QiqgEKF01h",
            "bmlwdWxhdGlvbkFwaVJlc3BvbnNlEioKBmhlYWRlchgBIAEoCzIaLmJvc2R5",
            "bi5hcGkuUmVzcG9uc2VIZWFkZXISGwoTbWFuaXB1bGF0aW9uX2NtZF9pZBgF",
            "IAEoBRI0ChBsZWFzZV91c2VfcmVzdWx0GAYgASgLMhouYm9zZHluLmFwaS5M",
            "ZWFzZVVzZVJlc3VsdEoECAIQA0oECAMQBEoECAQQBSKVBAoWTWFuaXB1bGF0",
            "aW9uQXBpUmVxdWVzdBIpCgZoZWFkZXIYASABKAsyGS5ib3NkeW4uYXBpLlJl",
            "cXVlc3RIZWFkZXISIAoFbGVhc2UYAiABKAsyES5ib3NkeW4uYXBpLkxlYXNl",
            "EkkKG3dhbGtfdG9fb2JqZWN0X3JheV9pbl93b3JsZBgMIAEoCzIiLmJvc2R5",
            "bi5hcGkuV2Fsa1RvT2JqZWN0UmF5SW5Xb3JsZEgAEkIKF3dhbGtfdG9fb2Jq",
            "ZWN0X2luX2ltYWdlGA0gASgLMh8uYm9zZHluLmFwaS5XYWxrVG9PYmplY3RJ",
            "bkltYWdlSAASLQoLcGlja19vYmplY3QYCiABKAsyFi5ib3NkeW4uYXBpLlBp",
            "Y2tPYmplY3RIABI9ChRwaWNrX29iamVjdF9pbl9pbWFnZRgLIAEoCzIdLmJv",
            "c2R5bi5hcGkuUGlja09iamVjdEluSW1hZ2VIABJEChhwaWNrX29iamVjdF9y",
            "YXlfaW5fd29ybGQYBCABKAsyIC5ib3NkeW4uYXBpLlBpY2tPYmplY3RSYXlJ",
            "bldvcmxkSAASRQoYcGlja19vYmplY3RfZXhlY3V0ZV9wbGFuGA4gASgLMiEu",
            "Ym9zZHluLmFwaS5QaWNrT2JqZWN0RXhlY3V0ZVBsYW5IAEISChBtYW5pcHVs",
            "YXRpb25fY21kSgQIAxAESgQIBhAHSgQICRAKIqUBChBBcGlHcmFzcE92ZXJy",
            "aWRlEj8KEG92ZXJyaWRlX3JlcXVlc3QYASABKA4yJS5ib3NkeW4uYXBpLkFw",
            "aUdyYXNwT3ZlcnJpZGUuT3ZlcnJpZGUiUAoIT3ZlcnJpZGUSFAoQT1ZFUlJJ",
            "REVfVU5LTk9XThAAEhQKEE9WRVJSSURFX0hPTERJTkcQARIYChRPVkVSUklE",
            "RV9OT1RfSE9MRElORxACImEKHEFwaUdyYXNwZWRDYXJyeVN0YXRlT3ZlcnJp",
            "ZGUSQQoQb3ZlcnJpZGVfcmVxdWVzdBgBIAEoDjInLmJvc2R5bi5hcGkuTWFu",
            "aXB1bGF0b3JTdGF0ZS5DYXJyeVN0YXRlIsYBChdBcGlHcmFzcE92ZXJyaWRl",
            "UmVxdWVzdBIpCgZoZWFkZXIYASABKAsyGS5ib3NkeW4uYXBpLlJlcXVlc3RI",
            "ZWFkZXISOAoSYXBpX2dyYXNwX292ZXJyaWRlGAQgASgLMhwuYm9zZHluLmFw",
            "aS5BcGlHcmFzcE92ZXJyaWRlEkYKFGNhcnJ5X3N0YXRlX292ZXJyaWRlGAIg",
            "ASgLMiguYm9zZHluLmFwaS5BcGlHcmFzcGVkQ2FycnlTdGF0ZU92ZXJyaWRl",
            "IkYKGEFwaUdyYXNwT3ZlcnJpZGVSZXNwb25zZRIqCgZoZWFkZXIYASABKAsy",
            "Gi5ib3NkeW4uYXBpLlJlc3BvbnNlSGVhZGVyKpwBChdHcmFzcFBvc2l0aW9u",
            "Q29uc3RyYWludBIlCiFHUkFTUF9QT1NJVElPTl9DT05TVFJBSU5UX1VOS05P",
            "V04QABIkCiBHUkFTUF9QT1NJVElPTl9DT05TVFJBSU5UX05PUk1BTBABEjQK",
            "MEdSQVNQX1BPU0lUSU9OX0NPTlNUUkFJTlRfRklYRURfQVRfVVNFUl9QT1NJ",
            "VElPThACKqkFChlNYW5pcHVsYXRpb25GZWVkYmFja1N0YXRlEhcKE01BTklQ",
            "X1NUQVRFX1VOS05PV04QABIUChBNQU5JUF9TVEFURV9ET05FEAESIwofTUFO",
            "SVBfU1RBVEVfU0VBUkNISU5HX0ZPUl9HUkFTUBACEh8KG01BTklQX1NUQVRF",
            "X01PVklOR19UT19HUkFTUBADEh8KG01BTklQX1NUQVRFX0dSQVNQSU5HX09C",
            "SkVDVBAEEh4KGk1BTklQX1NUQVRFX1BMQUNJTkdfT0JKRUNUEAUSHwobTUFO",
            "SVBfU1RBVEVfR1JBU1BfU1VDQ0VFREVEEAYSHAoYTUFOSVBfU1RBVEVfR1JB",
            "U1BfRkFJTEVEEAcSKAokTUFOSVBfU1RBVEVfR1JBU1BfUExBTk5JTkdfU1VD",
            "Q0VFREVEEAsSKgomTUFOSVBfU1RBVEVfR1JBU1BfUExBTk5JTkdfTk9fU09M",
            "VVRJT04QCBIwCixNQU5JUF9TVEFURV9HUkFTUF9GQUlMRURfVE9fUkFZQ0FT",
            "VF9JTlRPX01BUBAJEjMKL01BTklQX1NUQVRFX0dSQVNQX1BMQU5OSU5HX1dB",
            "SVRJTkdfREFUQV9BVF9FREdFEA0SIQodTUFOSVBfU1RBVEVfV0FMS0lOR19U",
            "T19PQkpFQ1QQChIlCiFNQU5JUF9TVEFURV9BVFRFTVBUSU5HX1JBWUNBU1RJ",
            "TkcQDBIfChtNQU5JUF9TVEFURV9NT1ZJTkdfVE9fUExBQ0UQDhIwCixNQU5J",
            "UF9TVEFURV9QTEFDRV9GQUlMRURfVE9fUkFZQ0FTVF9JTlRPX01BUBAPEh8K",
            "G01BTklQX1NUQVRFX1BMQUNFX1NVQ0NFRURFRBAQEhwKGE1BTklQX1NUQVRF",
            "X1BMQUNFX0ZBSUxFRBARKo4BChhNYW5pcHVsYXRpb25DYW1lcmFTb3VyY2US",
            "JgoiTUFOSVBVTEFUSU9OX0NBTUVSQV9TT1VSQ0VfVU5LTk9XThAAEiUKIU1B",
            "TklQVUxBVElPTl9DQU1FUkFfU09VUkNFX1NURVJFTxABEiMKH01BTklQVUxB",
            "VElPTl9DQU1FUkFfU09VUkNFX0hBTkQQAiqOAQoMV2Fsa0dhemVNb2RlEhoK",
            "FlBJQ0tfV0FMS19HQVpFX1VOS05PV04QABIbChdQSUNLX0FVVE9fV0FMS19B",
            "TkRfR0FaRRABEhIKDlBJQ0tfQVVUT19HQVpFEAISHQoZUElDS19OT19BVVRP",
            "X1dBTEtfT1JfR0FaRRADEhIKDlBJQ0tfUExBTl9PTkxZEARCFkIUTWFuaXB1",
            "bGF0aW9uQXBpUHJvdG9iBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.GeometryReflection.Descriptor, global::Bosdyn.Api.HeaderReflection.Descriptor, global::Bosdyn.Api.ImageReflection.Descriptor, global::Bosdyn.Api.LeaseReflection.Descriptor, global::Bosdyn.Api.RobotStateReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Bosdyn.Api.GraspPositionConstraint), typeof(global::Bosdyn.Api.ManipulationFeedbackState), typeof(global::Bosdyn.Api.ManipulationCameraSource), typeof(global::Bosdyn.Api.WalkGazeMode), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.WalkToObjectRayInWorld), global::Bosdyn.Api.WalkToObjectRayInWorld.Parser, new[]{ "RayStartRtFrame", "RayEndRtFrame", "FrameName", "OffsetDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.WalkToObjectInImage), global::Bosdyn.Api.WalkToObjectInImage.Parser, new[]{ "PixelXy", "TransformsSnapshotForCamera", "FrameNameImageSensor", "CameraModel", "OffsetDistance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.PickObjectRayInWorld), global::Bosdyn.Api.PickObjectRayInWorld.Parser, new[]{ "RayStartRtFrame", "RayEndRtFrame", "FrameName", "GraspParams", "WalkGazeMode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.PickObjectExecutePlan), global::Bosdyn.Api.PickObjectExecutePlan.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.PickObject), global::Bosdyn.Api.PickObject.Parser, new[]{ "FrameName", "ObjectRtFrame", "GraspParams" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.PickObjectInImage), global::Bosdyn.Api.PickObjectInImage.Parser, new[]{ "PixelXy", "TransformsSnapshotForCamera", "FrameNameImageSensor", "CameraModel", "GraspParams", "WalkGazeMode" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.GraspParams), global::Bosdyn.Api.GraspParams.Parser, new[]{ "GraspPalmToFingertip", "GraspParamsFrameName", "AllowableOrientation", "PositionConstraint", "ManipulationCameraSource" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.AllowableOrientation), global::Bosdyn.Api.AllowableOrientation.Parser, new[]{ "RotationWithTolerance", "VectorAlignmentWithTolerance", "SqueezeGrasp" }, new[]{ "Constraint" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.RotationWithTolerance), global::Bosdyn.Api.RotationWithTolerance.Parser, new[]{ "RotationEwrtFrame", "ThresholdRadians" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.VectorAlignmentWithTolerance), global::Bosdyn.Api.VectorAlignmentWithTolerance.Parser, new[]{ "AxisOnGripperEwrtGripper", "AxisToAlignWithEwrtFrame", "ThresholdRadians" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SqueezeGrasp), global::Bosdyn.Api.SqueezeGrasp.Parser, new[]{ "SqueezeGraspDisallowed" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ManipulationApiFeedbackRequest), global::Bosdyn.Api.ManipulationApiFeedbackRequest.Parser, new[]{ "Header", "ManipulationCmdId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ManipulationApiFeedbackResponse), global::Bosdyn.Api.ManipulationApiFeedbackResponse.Parser, new[]{ "Header", "ManipulationCmdId", "CurrentState", "TransformsSnapshotManipulationData" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ManipulationApiResponse), global::Bosdyn.Api.ManipulationApiResponse.Parser, new[]{ "Header", "ManipulationCmdId", "LeaseUseResult" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ManipulationApiRequest), global::Bosdyn.Api.ManipulationApiRequest.Parser, new[]{ "Header", "Lease", "WalkToObjectRayInWorld", "WalkToObjectInImage", "PickObject", "PickObjectInImage", "PickObjectRayInWorld", "PickObjectExecutePlan" }, new[]{ "ManipulationCmd" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ApiGraspOverride), global::Bosdyn.Api.ApiGraspOverride.Parser, new[]{ "OverrideRequest" }, null, new[]{ typeof(global::Bosdyn.Api.ApiGraspOverride.Types.Override) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ApiGraspedCarryStateOverride), global::Bosdyn.Api.ApiGraspedCarryStateOverride.Parser, new[]{ "OverrideRequest" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ApiGraspOverrideRequest), global::Bosdyn.Api.ApiGraspOverrideRequest.Parser, new[]{ "Header", "ApiGraspOverride", "CarryStateOverride" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ApiGraspOverrideResponse), global::Bosdyn.Api.ApiGraspOverrideResponse.Parser, new[]{ "Header" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum GraspPositionConstraint {
    [pbr::OriginalName("GRASP_POSITION_CONSTRAINT_UNKNOWN")] Unknown = 0,
    [pbr::OriginalName("GRASP_POSITION_CONSTRAINT_NORMAL")] Normal = 1,
    [pbr::OriginalName("GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION")] FixedAtUserPosition = 2,
  }

  public enum ManipulationFeedbackState {
    [pbr::OriginalName("MANIP_STATE_UNKNOWN")] ManipStateUnknown = 0,
    [pbr::OriginalName("MANIP_STATE_DONE")] ManipStateDone = 1,
    [pbr::OriginalName("MANIP_STATE_SEARCHING_FOR_GRASP")] ManipStateSearchingForGrasp = 2,
    [pbr::OriginalName("MANIP_STATE_MOVING_TO_GRASP")] ManipStateMovingToGrasp = 3,
    [pbr::OriginalName("MANIP_STATE_GRASPING_OBJECT")] ManipStateGraspingObject = 4,
    [pbr::OriginalName("MANIP_STATE_PLACING_OBJECT")] ManipStatePlacingObject = 5,
    [pbr::OriginalName("MANIP_STATE_GRASP_SUCCEEDED")] ManipStateGraspSucceeded = 6,
    [pbr::OriginalName("MANIP_STATE_GRASP_FAILED")] ManipStateGraspFailed = 7,
    [pbr::OriginalName("MANIP_STATE_GRASP_PLANNING_SUCCEEDED")] ManipStateGraspPlanningSucceeded = 11,
    [pbr::OriginalName("MANIP_STATE_GRASP_PLANNING_NO_SOLUTION")] ManipStateGraspPlanningNoSolution = 8,
    /// <summary>
    /// Note: if you are experiencing raycast failures during grasping, consider using a different
    /// grasping call that does not require the robot to automatically walk up to the grasp.
    /// </summary>
    [pbr::OriginalName("MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP")] ManipStateGraspFailedToRaycastIntoMap = 9,
    /// <summary>
    /// The grasp planner is waiting for the gaze to have the target object not on the edge of the
    /// camera view.  If you are seeing this in an automatic mode, the robot will soon retarget the
    /// grasp for you.  If you are seeing this in a non-auto mode, you'll need to change your gaze
    /// to have the target object more in the center of the hand-camera's view.
    /// </summary>
    [pbr::OriginalName("MANIP_STATE_GRASP_PLANNING_WAITING_DATA_AT_EDGE")] ManipStateGraspPlanningWaitingDataAtEdge = 13,
    [pbr::OriginalName("MANIP_STATE_WALKING_TO_OBJECT")] ManipStateWalkingToObject = 10,
    [pbr::OriginalName("MANIP_STATE_ATTEMPTING_RAYCASTING")] ManipStateAttemptingRaycasting = 12,
    [pbr::OriginalName("MANIP_STATE_MOVING_TO_PLACE")] ManipStateMovingToPlace = 14,
    [pbr::OriginalName("MANIP_STATE_PLACE_FAILED_TO_RAYCAST_INTO_MAP")] ManipStatePlaceFailedToRaycastIntoMap = 15,
    [pbr::OriginalName("MANIP_STATE_PLACE_SUCCEEDED")] ManipStatePlaceSucceeded = 16,
    [pbr::OriginalName("MANIP_STATE_PLACE_FAILED")] ManipStatePlaceFailed = 17,
  }

  public enum ManipulationCameraSource {
    [pbr::OriginalName("MANIPULATION_CAMERA_SOURCE_UNKNOWN")] Unknown = 0,
    [pbr::OriginalName("MANIPULATION_CAMERA_SOURCE_STEREO")] Stereo = 1,
    [pbr::OriginalName("MANIPULATION_CAMERA_SOURCE_HAND")] Hand = 2,
  }

  /// <summary>
  /// Configure automatic walking and gazing at the target.
  /// </summary>
  public enum WalkGazeMode {
    [pbr::OriginalName("PICK_WALK_GAZE_UNKNOWN")] PickWalkGazeUnknown = 0,
    /// <summary>
    /// Default, walk to the target and gaze at it automatically
    /// </summary>
    [pbr::OriginalName("PICK_AUTO_WALK_AND_GAZE")] PickAutoWalkAndGaze = 1,
    /// <summary>
    /// Don't move the robot base, but automatically look at the grasp target.
    /// </summary>
    [pbr::OriginalName("PICK_AUTO_GAZE")] PickAutoGaze = 2,
    /// <summary>
    /// No automatic gazing or walking. Note: if you choose this option, the target location
    /// must not be near the edges or off the screen on the hand camera's view.
    /// </summary>
    [pbr::OriginalName("PICK_NO_AUTO_WALK_OR_GAZE")] PickNoAutoWalkOrGaze = 3,
    /// <summary>
    /// Only plan for the grasp, don't move the robot.  Since we won't move
    /// the robot, the target location must not be near the edges or out of
    /// the hand camera's view.  The robot must be located near the object.
    /// (Equivalent conditions as for success with PICK_NO_AUTO_WALK_OR_GAZE)
    /// </summary>
    [pbr::OriginalName("PICK_PLAN_ONLY")] PickPlanOnly = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Walks the robot up to an object.  Useful to prepare to grasp or manipulate something.
  /// </summary>
  public sealed partial class WalkToObjectRayInWorld : pb::IMessage<WalkToObjectRayInWorld> {
    private static readonly pb::MessageParser<WalkToObjectRayInWorld> _parser = new pb::MessageParser<WalkToObjectRayInWorld>(() => new WalkToObjectRayInWorld());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WalkToObjectRayInWorld> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectRayInWorld() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectRayInWorld(WalkToObjectRayInWorld other) : this() {
      rayStartRtFrame_ = other.rayStartRtFrame_ != null ? other.rayStartRtFrame_.Clone() : null;
      rayEndRtFrame_ = other.rayEndRtFrame_ != null ? other.rayEndRtFrame_.Clone() : null;
      frameName_ = other.frameName_;
      OffsetDistance = other.OffsetDistance;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectRayInWorld Clone() {
      return new WalkToObjectRayInWorld(this);
    }

    /// <summary>Field number for the "ray_start_rt_frame" field.</summary>
    public const int RayStartRtFrameFieldNumber = 1;
    private global::Bosdyn.Api.Vec3 rayStartRtFrame_;
    /// <summary>
    /// Position of the start of the ray (see PickObjectRayInWorld for detailed comments.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 RayStartRtFrame {
      get { return rayStartRtFrame_; }
      set {
        rayStartRtFrame_ = value;
      }
    }

    /// <summary>Field number for the "ray_end_rt_frame" field.</summary>
    public const int RayEndRtFrameFieldNumber = 2;
    private global::Bosdyn.Api.Vec3 rayEndRtFrame_;
    /// <summary>
    /// Position of the end of the ray.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 RayEndRtFrame {
      get { return rayEndRtFrame_; }
      set {
        rayEndRtFrame_ = value;
      }
    }

    /// <summary>Field number for the "frame_name" field.</summary>
    public const int FrameNameFieldNumber = 3;
    private string frameName_ = "";
    /// <summary>
    /// Name of the frame that the above parameters are expressed in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FrameName {
      get { return frameName_; }
      set {
        frameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "offset_distance" field.</summary>
    public const int OffsetDistanceFieldNumber = 4;
    private static readonly pb::FieldCodec<float?> _single_offsetDistance_codec = pb::FieldCodec.ForStructWrapper<float>(34);
    private float? offsetDistance_;
    /// <summary>
    /// Optional offset distance for the robot to stand from the object's location.  The robot will
    /// walk forwards or backwards from where it is so that its center of mass is this distance from
    /// the object. \
    /// If unset, we use a reasonable default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float? OffsetDistance {
      get { return offsetDistance_; }
      set {
        offsetDistance_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WalkToObjectRayInWorld);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WalkToObjectRayInWorld other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(RayStartRtFrame, other.RayStartRtFrame)) return false;
      if (!object.Equals(RayEndRtFrame, other.RayEndRtFrame)) return false;
      if (FrameName != other.FrameName) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableSingleEqualityComparer.Equals(OffsetDistance, other.OffsetDistance)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (rayStartRtFrame_ != null) hash ^= RayStartRtFrame.GetHashCode();
      if (rayEndRtFrame_ != null) hash ^= RayEndRtFrame.GetHashCode();
      if (FrameName.Length != 0) hash ^= FrameName.GetHashCode();
      if (offsetDistance_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableSingleEqualityComparer.GetHashCode(OffsetDistance);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (rayStartRtFrame_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(RayStartRtFrame);
      }
      if (rayEndRtFrame_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RayEndRtFrame);
      }
      if (FrameName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(FrameName);
      }
      if (offsetDistance_ != null) {
        _single_offsetDistance_codec.WriteTagAndValue(output, OffsetDistance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (rayStartRtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RayStartRtFrame);
      }
      if (rayEndRtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RayEndRtFrame);
      }
      if (FrameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameName);
      }
      if (offsetDistance_ != null) {
        size += _single_offsetDistance_codec.CalculateSizeWithTag(OffsetDistance);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WalkToObjectRayInWorld other) {
      if (other == null) {
        return;
      }
      if (other.rayStartRtFrame_ != null) {
        if (rayStartRtFrame_ == null) {
          RayStartRtFrame = new global::Bosdyn.Api.Vec3();
        }
        RayStartRtFrame.MergeFrom(other.RayStartRtFrame);
      }
      if (other.rayEndRtFrame_ != null) {
        if (rayEndRtFrame_ == null) {
          RayEndRtFrame = new global::Bosdyn.Api.Vec3();
        }
        RayEndRtFrame.MergeFrom(other.RayEndRtFrame);
      }
      if (other.FrameName.Length != 0) {
        FrameName = other.FrameName;
      }
      if (other.offsetDistance_ != null) {
        if (offsetDistance_ == null || other.OffsetDistance != 0F) {
          OffsetDistance = other.OffsetDistance;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (rayStartRtFrame_ == null) {
              RayStartRtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(RayStartRtFrame);
            break;
          }
          case 18: {
            if (rayEndRtFrame_ == null) {
              RayEndRtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(RayEndRtFrame);
            break;
          }
          case 26: {
            FrameName = input.ReadString();
            break;
          }
          case 34: {
            float? value = _single_offsetDistance_codec.Read(input);
            if (offsetDistance_ == null || value != 0F) {
              OffsetDistance = value;
            }
            break;
          }
        }
      }
    }

  }

  public sealed partial class WalkToObjectInImage : pb::IMessage<WalkToObjectInImage> {
    private static readonly pb::MessageParser<WalkToObjectInImage> _parser = new pb::MessageParser<WalkToObjectInImage>(() => new WalkToObjectInImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WalkToObjectInImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectInImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectInImage(WalkToObjectInImage other) : this() {
      pixelXy_ = other.pixelXy_ != null ? other.pixelXy_.Clone() : null;
      transformsSnapshotForCamera_ = other.transformsSnapshotForCamera_ != null ? other.transformsSnapshotForCamera_.Clone() : null;
      frameNameImageSensor_ = other.frameNameImageSensor_;
      cameraModel_ = other.cameraModel_ != null ? other.cameraModel_.Clone() : null;
      OffsetDistance = other.OffsetDistance;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WalkToObjectInImage Clone() {
      return new WalkToObjectInImage(this);
    }

    /// <summary>Field number for the "pixel_xy" field.</summary>
    public const int PixelXyFieldNumber = 1;
    private global::Bosdyn.Api.Vec2 pixelXy_;
    /// <summary>
    /// Walk to an object that is at a pixel location in an image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec2 PixelXy {
      get { return pixelXy_; }
      set {
        pixelXy_ = value;
      }
    }

    /// <summary>Field number for the "transforms_snapshot_for_camera" field.</summary>
    public const int TransformsSnapshotForCameraFieldNumber = 2;
    private global::Bosdyn.Api.FrameTreeSnapshot transformsSnapshotForCamera_;
    /// <summary>
    /// A tree-based collection of transformations, which will include the transformations to each image's
    /// sensor in addition to transformations to the common frames ("vision", "body", "odom").
    /// All transforms within the snapshot are at the acquistion time of the image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FrameTreeSnapshot TransformsSnapshotForCamera {
      get { return transformsSnapshotForCamera_; }
      set {
        transformsSnapshotForCamera_ = value;
      }
    }

    /// <summary>Field number for the "frame_name_image_sensor" field.</summary>
    public const int FrameNameImageSensorFieldNumber = 3;
    private string frameNameImageSensor_ = "";
    /// <summary>
    /// The frame name for the image's sensor source. This will be included in the transform snapshot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FrameNameImageSensor {
      get { return frameNameImageSensor_; }
      set {
        frameNameImageSensor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "camera_model" field.</summary>
    public const int CameraModelFieldNumber = 4;
    private global::Bosdyn.Api.ImageSource.Types.PinholeModel cameraModel_;
    /// <summary>
    /// Camera model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ImageSource.Types.PinholeModel CameraModel {
      get { return cameraModel_; }
      set {
        cameraModel_ = value;
      }
    }

    /// <summary>Field number for the "offset_distance" field.</summary>
    public const int OffsetDistanceFieldNumber = 5;
    private static readonly pb::FieldCodec<float?> _single_offsetDistance_codec = pb::FieldCodec.ForStructWrapper<float>(42);
    private float? offsetDistance_;
    /// <summary>
    /// Optional offset distance for the robot to stand from the object's location.  The robot will
    /// walk forwards or backwards from where it is so that its center of mass is this distance from
    /// the object. \
    /// If unset, we use a reasonable default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float? OffsetDistance {
      get { return offsetDistance_; }
      set {
        offsetDistance_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WalkToObjectInImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WalkToObjectInImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PixelXy, other.PixelXy)) return false;
      if (!object.Equals(TransformsSnapshotForCamera, other.TransformsSnapshotForCamera)) return false;
      if (FrameNameImageSensor != other.FrameNameImageSensor) return false;
      if (!object.Equals(CameraModel, other.CameraModel)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableSingleEqualityComparer.Equals(OffsetDistance, other.OffsetDistance)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pixelXy_ != null) hash ^= PixelXy.GetHashCode();
      if (transformsSnapshotForCamera_ != null) hash ^= TransformsSnapshotForCamera.GetHashCode();
      if (FrameNameImageSensor.Length != 0) hash ^= FrameNameImageSensor.GetHashCode();
      if (cameraModel_ != null) hash ^= CameraModel.GetHashCode();
      if (offsetDistance_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableSingleEqualityComparer.GetHashCode(OffsetDistance);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pixelXy_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PixelXy);
      }
      if (transformsSnapshotForCamera_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TransformsSnapshotForCamera);
      }
      if (FrameNameImageSensor.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(FrameNameImageSensor);
      }
      if (cameraModel_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CameraModel);
      }
      if (offsetDistance_ != null) {
        _single_offsetDistance_codec.WriteTagAndValue(output, OffsetDistance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pixelXy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PixelXy);
      }
      if (transformsSnapshotForCamera_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransformsSnapshotForCamera);
      }
      if (FrameNameImageSensor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameNameImageSensor);
      }
      if (cameraModel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CameraModel);
      }
      if (offsetDistance_ != null) {
        size += _single_offsetDistance_codec.CalculateSizeWithTag(OffsetDistance);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WalkToObjectInImage other) {
      if (other == null) {
        return;
      }
      if (other.pixelXy_ != null) {
        if (pixelXy_ == null) {
          PixelXy = new global::Bosdyn.Api.Vec2();
        }
        PixelXy.MergeFrom(other.PixelXy);
      }
      if (other.transformsSnapshotForCamera_ != null) {
        if (transformsSnapshotForCamera_ == null) {
          TransformsSnapshotForCamera = new global::Bosdyn.Api.FrameTreeSnapshot();
        }
        TransformsSnapshotForCamera.MergeFrom(other.TransformsSnapshotForCamera);
      }
      if (other.FrameNameImageSensor.Length != 0) {
        FrameNameImageSensor = other.FrameNameImageSensor;
      }
      if (other.cameraModel_ != null) {
        if (cameraModel_ == null) {
          CameraModel = new global::Bosdyn.Api.ImageSource.Types.PinholeModel();
        }
        CameraModel.MergeFrom(other.CameraModel);
      }
      if (other.offsetDistance_ != null) {
        if (offsetDistance_ == null || other.OffsetDistance != 0F) {
          OffsetDistance = other.OffsetDistance;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (pixelXy_ == null) {
              PixelXy = new global::Bosdyn.Api.Vec2();
            }
            input.ReadMessage(PixelXy);
            break;
          }
          case 18: {
            if (transformsSnapshotForCamera_ == null) {
              TransformsSnapshotForCamera = new global::Bosdyn.Api.FrameTreeSnapshot();
            }
            input.ReadMessage(TransformsSnapshotForCamera);
            break;
          }
          case 26: {
            FrameNameImageSensor = input.ReadString();
            break;
          }
          case 34: {
            if (cameraModel_ == null) {
              CameraModel = new global::Bosdyn.Api.ImageSource.Types.PinholeModel();
            }
            input.ReadMessage(CameraModel);
            break;
          }
          case 42: {
            float? value = _single_offsetDistance_codec.Read(input);
            if (offsetDistance_ == null || value != 0F) {
              OffsetDistance = value;
            }
            break;
          }
        }
      }
    }

  }

  public sealed partial class PickObjectRayInWorld : pb::IMessage<PickObjectRayInWorld> {
    private static readonly pb::MessageParser<PickObjectRayInWorld> _parser = new pb::MessageParser<PickObjectRayInWorld>(() => new PickObjectRayInWorld());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickObjectRayInWorld> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectRayInWorld() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectRayInWorld(PickObjectRayInWorld other) : this() {
      rayStartRtFrame_ = other.rayStartRtFrame_ != null ? other.rayStartRtFrame_.Clone() : null;
      rayEndRtFrame_ = other.rayEndRtFrame_ != null ? other.rayEndRtFrame_.Clone() : null;
      frameName_ = other.frameName_;
      graspParams_ = other.graspParams_ != null ? other.graspParams_.Clone() : null;
      walkGazeMode_ = other.walkGazeMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectRayInWorld Clone() {
      return new PickObjectRayInWorld(this);
    }

    /// <summary>Field number for the "ray_start_rt_frame" field.</summary>
    public const int RayStartRtFrameFieldNumber = 1;
    private global::Bosdyn.Api.Vec3 rayStartRtFrame_;
    /// <summary>
    /// Cast a ray in the world and pick the first object found along the ray. \
    /// This is the lowest-level grasping message; all other grasp options internally use this
    /// message to trigger a grasp. \
    /// Example:
    ///  You see the object you are interested in with the gripper's camera.  To grasp it, you
    ///  cast a ray from the camera out to 4 meters (well past the object). \
    ///  To do this you'd set: \
    ///      ray_start_rt_frame: camera's position \
    ///      ray_end_rt_frame: camera's position + unit vector along ray of interest * 4 meters
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 RayStartRtFrame {
      get { return rayStartRtFrame_; }
      set {
        rayStartRtFrame_ = value;
      }
    }

    /// <summary>Field number for the "ray_end_rt_frame" field.</summary>
    public const int RayEndRtFrameFieldNumber = 2;
    private global::Bosdyn.Api.Vec3 rayEndRtFrame_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 RayEndRtFrame {
      get { return rayEndRtFrame_; }
      set {
        rayEndRtFrame_ = value;
      }
    }

    /// <summary>Field number for the "frame_name" field.</summary>
    public const int FrameNameFieldNumber = 6;
    private string frameName_ = "";
    /// <summary>
    /// Name of the frame the above parameters are represented in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FrameName {
      get { return frameName_; }
      set {
        frameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "grasp_params" field.</summary>
    public const int GraspParamsFieldNumber = 10;
    private global::Bosdyn.Api.GraspParams graspParams_;
    /// <summary>
    /// Optional parameters for the grasp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.GraspParams GraspParams {
      get { return graspParams_; }
      set {
        graspParams_ = value;
      }
    }

    /// <summary>Field number for the "walk_gaze_mode" field.</summary>
    public const int WalkGazeModeFieldNumber = 4;
    private global::Bosdyn.Api.WalkGazeMode walkGazeMode_ = 0;
    /// <summary>
    /// Configure if the robot should automatically walk and/or gaze at the target object before
    /// performing the grasp. \
    /// 1. If you haven't moved the robot or deployed the arm, use PICK_AUTO_WALK_AND_GAZE \
    /// 2. If you have moved to the location you want to pick from, but haven't yet deployed the arm,
    ///    use PICK_AUTO_GAZE. \
    /// 3. If you have already moved the robot and have the hand looking at your target object, use
    ///    PICK_NO_AUTO_WALK_OR_GAZE. \
    /// If you are seeing issues with "MANIP_STATE_GRASP_FAILED_TO_RAYCAST_INTO_MAP," that means that
    /// the automatic system cannot find your object when trying to automatically walk to it, so
    /// consider using PICK_AUTO_GAZE or PICK_NO_AUTO_WALK_OR_GAZE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.WalkGazeMode WalkGazeMode {
      get { return walkGazeMode_; }
      set {
        walkGazeMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickObjectRayInWorld);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickObjectRayInWorld other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(RayStartRtFrame, other.RayStartRtFrame)) return false;
      if (!object.Equals(RayEndRtFrame, other.RayEndRtFrame)) return false;
      if (FrameName != other.FrameName) return false;
      if (!object.Equals(GraspParams, other.GraspParams)) return false;
      if (WalkGazeMode != other.WalkGazeMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (rayStartRtFrame_ != null) hash ^= RayStartRtFrame.GetHashCode();
      if (rayEndRtFrame_ != null) hash ^= RayEndRtFrame.GetHashCode();
      if (FrameName.Length != 0) hash ^= FrameName.GetHashCode();
      if (graspParams_ != null) hash ^= GraspParams.GetHashCode();
      if (WalkGazeMode != 0) hash ^= WalkGazeMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (rayStartRtFrame_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(RayStartRtFrame);
      }
      if (rayEndRtFrame_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RayEndRtFrame);
      }
      if (WalkGazeMode != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) WalkGazeMode);
      }
      if (FrameName.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(FrameName);
      }
      if (graspParams_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(GraspParams);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (rayStartRtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RayStartRtFrame);
      }
      if (rayEndRtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RayEndRtFrame);
      }
      if (FrameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameName);
      }
      if (graspParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GraspParams);
      }
      if (WalkGazeMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WalkGazeMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickObjectRayInWorld other) {
      if (other == null) {
        return;
      }
      if (other.rayStartRtFrame_ != null) {
        if (rayStartRtFrame_ == null) {
          RayStartRtFrame = new global::Bosdyn.Api.Vec3();
        }
        RayStartRtFrame.MergeFrom(other.RayStartRtFrame);
      }
      if (other.rayEndRtFrame_ != null) {
        if (rayEndRtFrame_ == null) {
          RayEndRtFrame = new global::Bosdyn.Api.Vec3();
        }
        RayEndRtFrame.MergeFrom(other.RayEndRtFrame);
      }
      if (other.FrameName.Length != 0) {
        FrameName = other.FrameName;
      }
      if (other.graspParams_ != null) {
        if (graspParams_ == null) {
          GraspParams = new global::Bosdyn.Api.GraspParams();
        }
        GraspParams.MergeFrom(other.GraspParams);
      }
      if (other.WalkGazeMode != 0) {
        WalkGazeMode = other.WalkGazeMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (rayStartRtFrame_ == null) {
              RayStartRtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(RayStartRtFrame);
            break;
          }
          case 18: {
            if (rayEndRtFrame_ == null) {
              RayEndRtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(RayEndRtFrame);
            break;
          }
          case 32: {
            WalkGazeMode = (global::Bosdyn.Api.WalkGazeMode) input.ReadEnum();
            break;
          }
          case 50: {
            FrameName = input.ReadString();
            break;
          }
          case 82: {
            if (graspParams_ == null) {
              GraspParams = new global::Bosdyn.Api.GraspParams();
            }
            input.ReadMessage(GraspParams);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// No data
  /// </summary>
  public sealed partial class PickObjectExecutePlan : pb::IMessage<PickObjectExecutePlan> {
    private static readonly pb::MessageParser<PickObjectExecutePlan> _parser = new pb::MessageParser<PickObjectExecutePlan>(() => new PickObjectExecutePlan());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickObjectExecutePlan> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectExecutePlan() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectExecutePlan(PickObjectExecutePlan other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectExecutePlan Clone() {
      return new PickObjectExecutePlan(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickObjectExecutePlan);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickObjectExecutePlan other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickObjectExecutePlan other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class PickObject : pb::IMessage<PickObject> {
    private static readonly pb::MessageParser<PickObject> _parser = new pb::MessageParser<PickObject>(() => new PickObject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickObject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObject(PickObject other) : this() {
      frameName_ = other.frameName_;
      objectRtFrame_ = other.objectRtFrame_ != null ? other.objectRtFrame_.Clone() : null;
      graspParams_ = other.graspParams_ != null ? other.graspParams_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObject Clone() {
      return new PickObject(this);
    }

    /// <summary>Field number for the "frame_name" field.</summary>
    public const int FrameNameFieldNumber = 1;
    private string frameName_ = "";
    /// <summary>
    /// Name of the frame you want to give your input in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FrameName {
      get { return frameName_; }
      set {
        frameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "object_rt_frame" field.</summary>
    public const int ObjectRtFrameFieldNumber = 2;
    private global::Bosdyn.Api.Vec3 objectRtFrame_;
    /// <summary>
    /// Pickup an object at the location, given in the frame named above.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 ObjectRtFrame {
      get { return objectRtFrame_; }
      set {
        objectRtFrame_ = value;
      }
    }

    /// <summary>Field number for the "grasp_params" field.</summary>
    public const int GraspParamsFieldNumber = 3;
    private global::Bosdyn.Api.GraspParams graspParams_;
    /// <summary>
    /// Optional parameters for the grasp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.GraspParams GraspParams {
      get { return graspParams_; }
      set {
        graspParams_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickObject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickObject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FrameName != other.FrameName) return false;
      if (!object.Equals(ObjectRtFrame, other.ObjectRtFrame)) return false;
      if (!object.Equals(GraspParams, other.GraspParams)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FrameName.Length != 0) hash ^= FrameName.GetHashCode();
      if (objectRtFrame_ != null) hash ^= ObjectRtFrame.GetHashCode();
      if (graspParams_ != null) hash ^= GraspParams.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (FrameName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FrameName);
      }
      if (objectRtFrame_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ObjectRtFrame);
      }
      if (graspParams_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(GraspParams);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FrameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameName);
      }
      if (objectRtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ObjectRtFrame);
      }
      if (graspParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GraspParams);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickObject other) {
      if (other == null) {
        return;
      }
      if (other.FrameName.Length != 0) {
        FrameName = other.FrameName;
      }
      if (other.objectRtFrame_ != null) {
        if (objectRtFrame_ == null) {
          ObjectRtFrame = new global::Bosdyn.Api.Vec3();
        }
        ObjectRtFrame.MergeFrom(other.ObjectRtFrame);
      }
      if (other.graspParams_ != null) {
        if (graspParams_ == null) {
          GraspParams = new global::Bosdyn.Api.GraspParams();
        }
        GraspParams.MergeFrom(other.GraspParams);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            FrameName = input.ReadString();
            break;
          }
          case 18: {
            if (objectRtFrame_ == null) {
              ObjectRtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(ObjectRtFrame);
            break;
          }
          case 26: {
            if (graspParams_ == null) {
              GraspParams = new global::Bosdyn.Api.GraspParams();
            }
            input.ReadMessage(GraspParams);
            break;
          }
        }
      }
    }

  }

  public sealed partial class PickObjectInImage : pb::IMessage<PickObjectInImage> {
    private static readonly pb::MessageParser<PickObjectInImage> _parser = new pb::MessageParser<PickObjectInImage>(() => new PickObjectInImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PickObjectInImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectInImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectInImage(PickObjectInImage other) : this() {
      pixelXy_ = other.pixelXy_ != null ? other.pixelXy_.Clone() : null;
      transformsSnapshotForCamera_ = other.transformsSnapshotForCamera_ != null ? other.transformsSnapshotForCamera_.Clone() : null;
      frameNameImageSensor_ = other.frameNameImageSensor_;
      cameraModel_ = other.cameraModel_ != null ? other.cameraModel_.Clone() : null;
      graspParams_ = other.graspParams_ != null ? other.graspParams_.Clone() : null;
      walkGazeMode_ = other.walkGazeMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PickObjectInImage Clone() {
      return new PickObjectInImage(this);
    }

    /// <summary>Field number for the "pixel_xy" field.</summary>
    public const int PixelXyFieldNumber = 1;
    private global::Bosdyn.Api.Vec2 pixelXy_;
    /// <summary>
    /// Pickup an object that is at a pixel location in an image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec2 PixelXy {
      get { return pixelXy_; }
      set {
        pixelXy_ = value;
      }
    }

    /// <summary>Field number for the "transforms_snapshot_for_camera" field.</summary>
    public const int TransformsSnapshotForCameraFieldNumber = 2;
    private global::Bosdyn.Api.FrameTreeSnapshot transformsSnapshotForCamera_;
    /// <summary>
    /// A tree-based collection of transformations, which will include the transformations to each image's
    /// sensor in addition to transformations to the common frames ("vision", "body", "odom").
    /// All transforms within the snapshot are at the acquistion time of the image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FrameTreeSnapshot TransformsSnapshotForCamera {
      get { return transformsSnapshotForCamera_; }
      set {
        transformsSnapshotForCamera_ = value;
      }
    }

    /// <summary>Field number for the "frame_name_image_sensor" field.</summary>
    public const int FrameNameImageSensorFieldNumber = 3;
    private string frameNameImageSensor_ = "";
    /// <summary>
    /// The frame name for the image's sensor source. This must be included in the transform snapshot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FrameNameImageSensor {
      get { return frameNameImageSensor_; }
      set {
        frameNameImageSensor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "camera_model" field.</summary>
    public const int CameraModelFieldNumber = 4;
    private global::Bosdyn.Api.ImageSource.Types.PinholeModel cameraModel_;
    /// <summary>
    /// Camera model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ImageSource.Types.PinholeModel CameraModel {
      get { return cameraModel_; }
      set {
        cameraModel_ = value;
      }
    }

    /// <summary>Field number for the "grasp_params" field.</summary>
    public const int GraspParamsFieldNumber = 10;
    private global::Bosdyn.Api.GraspParams graspParams_;
    /// <summary>
    /// Optional parameters for the grasp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.GraspParams GraspParams {
      get { return graspParams_; }
      set {
        graspParams_ = value;
      }
    }

    /// <summary>Field number for the "walk_gaze_mode" field.</summary>
    public const int WalkGazeModeFieldNumber = 9;
    private global::Bosdyn.Api.WalkGazeMode walkGazeMode_ = 0;
    /// <summary>
    /// Automatic walking / gazing configuration.
    /// See detailed comment in the PickObjectRayInWorld message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.WalkGazeMode WalkGazeMode {
      get { return walkGazeMode_; }
      set {
        walkGazeMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PickObjectInImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PickObjectInImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PixelXy, other.PixelXy)) return false;
      if (!object.Equals(TransformsSnapshotForCamera, other.TransformsSnapshotForCamera)) return false;
      if (FrameNameImageSensor != other.FrameNameImageSensor) return false;
      if (!object.Equals(CameraModel, other.CameraModel)) return false;
      if (!object.Equals(GraspParams, other.GraspParams)) return false;
      if (WalkGazeMode != other.WalkGazeMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pixelXy_ != null) hash ^= PixelXy.GetHashCode();
      if (transformsSnapshotForCamera_ != null) hash ^= TransformsSnapshotForCamera.GetHashCode();
      if (FrameNameImageSensor.Length != 0) hash ^= FrameNameImageSensor.GetHashCode();
      if (cameraModel_ != null) hash ^= CameraModel.GetHashCode();
      if (graspParams_ != null) hash ^= GraspParams.GetHashCode();
      if (WalkGazeMode != 0) hash ^= WalkGazeMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pixelXy_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PixelXy);
      }
      if (transformsSnapshotForCamera_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TransformsSnapshotForCamera);
      }
      if (FrameNameImageSensor.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(FrameNameImageSensor);
      }
      if (cameraModel_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CameraModel);
      }
      if (WalkGazeMode != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) WalkGazeMode);
      }
      if (graspParams_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(GraspParams);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pixelXy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PixelXy);
      }
      if (transformsSnapshotForCamera_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransformsSnapshotForCamera);
      }
      if (FrameNameImageSensor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameNameImageSensor);
      }
      if (cameraModel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CameraModel);
      }
      if (graspParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GraspParams);
      }
      if (WalkGazeMode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) WalkGazeMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PickObjectInImage other) {
      if (other == null) {
        return;
      }
      if (other.pixelXy_ != null) {
        if (pixelXy_ == null) {
          PixelXy = new global::Bosdyn.Api.Vec2();
        }
        PixelXy.MergeFrom(other.PixelXy);
      }
      if (other.transformsSnapshotForCamera_ != null) {
        if (transformsSnapshotForCamera_ == null) {
          TransformsSnapshotForCamera = new global::Bosdyn.Api.FrameTreeSnapshot();
        }
        TransformsSnapshotForCamera.MergeFrom(other.TransformsSnapshotForCamera);
      }
      if (other.FrameNameImageSensor.Length != 0) {
        FrameNameImageSensor = other.FrameNameImageSensor;
      }
      if (other.cameraModel_ != null) {
        if (cameraModel_ == null) {
          CameraModel = new global::Bosdyn.Api.ImageSource.Types.PinholeModel();
        }
        CameraModel.MergeFrom(other.CameraModel);
      }
      if (other.graspParams_ != null) {
        if (graspParams_ == null) {
          GraspParams = new global::Bosdyn.Api.GraspParams();
        }
        GraspParams.MergeFrom(other.GraspParams);
      }
      if (other.WalkGazeMode != 0) {
        WalkGazeMode = other.WalkGazeMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (pixelXy_ == null) {
              PixelXy = new global::Bosdyn.Api.Vec2();
            }
            input.ReadMessage(PixelXy);
            break;
          }
          case 18: {
            if (transformsSnapshotForCamera_ == null) {
              TransformsSnapshotForCamera = new global::Bosdyn.Api.FrameTreeSnapshot();
            }
            input.ReadMessage(TransformsSnapshotForCamera);
            break;
          }
          case 26: {
            FrameNameImageSensor = input.ReadString();
            break;
          }
          case 34: {
            if (cameraModel_ == null) {
              CameraModel = new global::Bosdyn.Api.ImageSource.Types.PinholeModel();
            }
            input.ReadMessage(CameraModel);
            break;
          }
          case 72: {
            WalkGazeMode = (global::Bosdyn.Api.WalkGazeMode) input.ReadEnum();
            break;
          }
          case 82: {
            if (graspParams_ == null) {
              GraspParams = new global::Bosdyn.Api.GraspParams();
            }
            input.ReadMessage(GraspParams);
            break;
          }
        }
      }
    }

  }

  public sealed partial class GraspParams : pb::IMessage<GraspParams> {
    private static readonly pb::MessageParser<GraspParams> _parser = new pb::MessageParser<GraspParams>(() => new GraspParams());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GraspParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraspParams() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraspParams(GraspParams other) : this() {
      graspPalmToFingertip_ = other.graspPalmToFingertip_;
      graspParamsFrameName_ = other.graspParamsFrameName_;
      allowableOrientation_ = other.allowableOrientation_.Clone();
      positionConstraint_ = other.positionConstraint_;
      manipulationCameraSource_ = other.manipulationCameraSource_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraspParams Clone() {
      return new GraspParams(this);
    }

    /// <summary>Field number for the "grasp_palm_to_fingertip" field.</summary>
    public const int GraspPalmToFingertipFieldNumber = 1;
    private float graspPalmToFingertip_;
    /// <summary>
    /// Where the grasp is on the hand.  Set to 0 to be a (default) palm grasp, where the object will
    /// be pressed against the gripper's palm plate.  Set to 1.0 to be a fingertip grasp, where the
    /// robot will try to pick up the target with just the tip of its fingers. \
    /// Intermediate values move the grasp location between the two extremes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float GraspPalmToFingertip {
      get { return graspPalmToFingertip_; }
      set {
        graspPalmToFingertip_ = value;
      }
    }

    /// <summary>Field number for the "grasp_params_frame_name" field.</summary>
    public const int GraspParamsFrameNameFieldNumber = 2;
    private string graspParamsFrameName_ = "";
    /// <summary>
    /// Frame name for the frame that the constraints in allowable_orientation are expressed in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GraspParamsFrameName {
      get { return graspParamsFrameName_; }
      set {
        graspParamsFrameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allowable_orientation" field.</summary>
    public const int AllowableOrientationFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.AllowableOrientation> _repeated_allowableOrientation_codec
        = pb::FieldCodec.ForMessage(26, global::Bosdyn.Api.AllowableOrientation.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.AllowableOrientation> allowableOrientation_ = new pbc::RepeatedField<global::Bosdyn.Api.AllowableOrientation>();
    /// <summary>
    /// Optional constraints about the orientation of the grasp.  This field lets you specify things
    /// like "only do a top down grasp," "grasp only from this direction," or "grasp with the gripper
    /// upside-down."  If you don't pass anything, the robot will automatically search for a good
    /// grasp orientation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.AllowableOrientation> AllowableOrientation {
      get { return allowableOrientation_; }
    }

    /// <summary>Field number for the "position_constraint" field.</summary>
    public const int PositionConstraintFieldNumber = 4;
    private global::Bosdyn.Api.GraspPositionConstraint positionConstraint_ = 0;
    /// <summary>
    /// Optional parameter on how much the robot is allowed to move the grasp from where the user
    /// requested.  Set this to be GRASP_POSITION_CONSTRAINT_FIXED_AT_USER_POSITION to get a grasp
    /// that is at the exact position you requested, but has less or no automatic grasp selection
    /// help in position.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.GraspPositionConstraint PositionConstraint {
      get { return positionConstraint_; }
      set {
        positionConstraint_ = value;
      }
    }

    /// <summary>Field number for the "manipulation_camera_source" field.</summary>
    public const int ManipulationCameraSourceFieldNumber = 5;
    private global::Bosdyn.Api.ManipulationCameraSource manipulationCameraSource_ = 0;
    /// <summary>
    /// Optional hint about which camera was used to generate the target points.  The robot will
    /// attempt to correct for calibration error between the arm and the body cameras.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ManipulationCameraSource ManipulationCameraSource {
      get { return manipulationCameraSource_; }
      set {
        manipulationCameraSource_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GraspParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GraspParams other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(GraspPalmToFingertip, other.GraspPalmToFingertip)) return false;
      if (GraspParamsFrameName != other.GraspParamsFrameName) return false;
      if(!allowableOrientation_.Equals(other.allowableOrientation_)) return false;
      if (PositionConstraint != other.PositionConstraint) return false;
      if (ManipulationCameraSource != other.ManipulationCameraSource) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (GraspPalmToFingertip != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(GraspPalmToFingertip);
      if (GraspParamsFrameName.Length != 0) hash ^= GraspParamsFrameName.GetHashCode();
      hash ^= allowableOrientation_.GetHashCode();
      if (PositionConstraint != 0) hash ^= PositionConstraint.GetHashCode();
      if (ManipulationCameraSource != 0) hash ^= ManipulationCameraSource.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (GraspPalmToFingertip != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(GraspPalmToFingertip);
      }
      if (GraspParamsFrameName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(GraspParamsFrameName);
      }
      allowableOrientation_.WriteTo(output, _repeated_allowableOrientation_codec);
      if (PositionConstraint != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) PositionConstraint);
      }
      if (ManipulationCameraSource != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) ManipulationCameraSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (GraspPalmToFingertip != 0F) {
        size += 1 + 4;
      }
      if (GraspParamsFrameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GraspParamsFrameName);
      }
      size += allowableOrientation_.CalculateSize(_repeated_allowableOrientation_codec);
      if (PositionConstraint != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PositionConstraint);
      }
      if (ManipulationCameraSource != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ManipulationCameraSource);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GraspParams other) {
      if (other == null) {
        return;
      }
      if (other.GraspPalmToFingertip != 0F) {
        GraspPalmToFingertip = other.GraspPalmToFingertip;
      }
      if (other.GraspParamsFrameName.Length != 0) {
        GraspParamsFrameName = other.GraspParamsFrameName;
      }
      allowableOrientation_.Add(other.allowableOrientation_);
      if (other.PositionConstraint != 0) {
        PositionConstraint = other.PositionConstraint;
      }
      if (other.ManipulationCameraSource != 0) {
        ManipulationCameraSource = other.ManipulationCameraSource;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            GraspPalmToFingertip = input.ReadFloat();
            break;
          }
          case 18: {
            GraspParamsFrameName = input.ReadString();
            break;
          }
          case 26: {
            allowableOrientation_.AddEntriesFrom(input, _repeated_allowableOrientation_codec);
            break;
          }
          case 32: {
            PositionConstraint = (global::Bosdyn.Api.GraspPositionConstraint) input.ReadEnum();
            break;
          }
          case 40: {
            ManipulationCameraSource = (global::Bosdyn.Api.ManipulationCameraSource) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Allowable orientation allow you to specify vectors that the different axes of the robot's
  /// gripper will be aligned with in the final grasp pose. \
  ///
  /// Frame: \
  ///  In stow position, +X is to the front of the gripper, pointing forward. \
  ///                    +Y is out of the side of the gripper going to the robot's left \
  ///                    +Z is straight up towards the sky \
  ///
  /// Here, you can supply vectors that you want the gripper to be aligned with at the final grasp
  /// position.  For example, if you wanted to grasp a cup, you'd wouldn't want a top-down grasp.
  /// So you might specify: \
  ///      frame_name = "vision" (so that Z is gravity aligned) \
  ///       VectorAlignmentWithTolerance: \
  ///          axis_to_on_gripper_ewrt_gripper = Vec3(0, 0, 1)  &lt;--- we want to control the
  ///                                                                gripper's z-axis. \
  ///
  ///          axis_to_align_with_ewrt_frame = Vec3(0, 0, 1)  &lt;--- ...and we want that axis to be
  ///                                                                 straight up \
  ///          tolerance_z = 0.52  &lt;--- 30 degrees \
  ///    This will ensure that the z-axis of the gripper is pointed within 30 degrees of vertical
  ///    so that your grasp won't be top-down (which would need the z-axis of the gripper to be
  ///    pointed at the horizon). \
  ///
  /// You can also specify more than one AllowableOrientation to give the system multiple options.
  /// For example, you could specify that you're OK with either a z-up or z-down version of the cup
  /// grasp, allowing the gripper roll 180 from the stow position to grasp the cup.
  /// </summary>
  public sealed partial class AllowableOrientation : pb::IMessage<AllowableOrientation> {
    private static readonly pb::MessageParser<AllowableOrientation> _parser = new pb::MessageParser<AllowableOrientation>(() => new AllowableOrientation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AllowableOrientation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AllowableOrientation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AllowableOrientation(AllowableOrientation other) : this() {
      switch (other.ConstraintCase) {
        case ConstraintOneofCase.RotationWithTolerance:
          RotationWithTolerance = other.RotationWithTolerance.Clone();
          break;
        case ConstraintOneofCase.VectorAlignmentWithTolerance:
          VectorAlignmentWithTolerance = other.VectorAlignmentWithTolerance.Clone();
          break;
        case ConstraintOneofCase.SqueezeGrasp:
          SqueezeGrasp = other.SqueezeGrasp.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AllowableOrientation Clone() {
      return new AllowableOrientation(this);
    }

    /// <summary>Field number for the "rotation_with_tolerance" field.</summary>
    public const int RotationWithToleranceFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RotationWithTolerance RotationWithTolerance {
      get { return constraintCase_ == ConstraintOneofCase.RotationWithTolerance ? (global::Bosdyn.Api.RotationWithTolerance) constraint_ : null; }
      set {
        constraint_ = value;
        constraintCase_ = value == null ? ConstraintOneofCase.None : ConstraintOneofCase.RotationWithTolerance;
      }
    }

    /// <summary>Field number for the "vector_alignment_with_tolerance" field.</summary>
    public const int VectorAlignmentWithToleranceFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.VectorAlignmentWithTolerance VectorAlignmentWithTolerance {
      get { return constraintCase_ == ConstraintOneofCase.VectorAlignmentWithTolerance ? (global::Bosdyn.Api.VectorAlignmentWithTolerance) constraint_ : null; }
      set {
        constraint_ = value;
        constraintCase_ = value == null ? ConstraintOneofCase.None : ConstraintOneofCase.VectorAlignmentWithTolerance;
      }
    }

    /// <summary>Field number for the "squeeze_grasp" field.</summary>
    public const int SqueezeGraspFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SqueezeGrasp SqueezeGrasp {
      get { return constraintCase_ == ConstraintOneofCase.SqueezeGrasp ? (global::Bosdyn.Api.SqueezeGrasp) constraint_ : null; }
      set {
        constraint_ = value;
        constraintCase_ = value == null ? ConstraintOneofCase.None : ConstraintOneofCase.SqueezeGrasp;
      }
    }

    private object constraint_;
    /// <summary>Enum of possible cases for the "constraint" oneof.</summary>
    public enum ConstraintOneofCase {
      None = 0,
      RotationWithTolerance = 1,
      VectorAlignmentWithTolerance = 2,
      SqueezeGrasp = 3,
    }
    private ConstraintOneofCase constraintCase_ = ConstraintOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConstraintOneofCase ConstraintCase {
      get { return constraintCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConstraint() {
      constraintCase_ = ConstraintOneofCase.None;
      constraint_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AllowableOrientation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AllowableOrientation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(RotationWithTolerance, other.RotationWithTolerance)) return false;
      if (!object.Equals(VectorAlignmentWithTolerance, other.VectorAlignmentWithTolerance)) return false;
      if (!object.Equals(SqueezeGrasp, other.SqueezeGrasp)) return false;
      if (ConstraintCase != other.ConstraintCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (constraintCase_ == ConstraintOneofCase.RotationWithTolerance) hash ^= RotationWithTolerance.GetHashCode();
      if (constraintCase_ == ConstraintOneofCase.VectorAlignmentWithTolerance) hash ^= VectorAlignmentWithTolerance.GetHashCode();
      if (constraintCase_ == ConstraintOneofCase.SqueezeGrasp) hash ^= SqueezeGrasp.GetHashCode();
      hash ^= (int) constraintCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (constraintCase_ == ConstraintOneofCase.RotationWithTolerance) {
        output.WriteRawTag(10);
        output.WriteMessage(RotationWithTolerance);
      }
      if (constraintCase_ == ConstraintOneofCase.VectorAlignmentWithTolerance) {
        output.WriteRawTag(18);
        output.WriteMessage(VectorAlignmentWithTolerance);
      }
      if (constraintCase_ == ConstraintOneofCase.SqueezeGrasp) {
        output.WriteRawTag(26);
        output.WriteMessage(SqueezeGrasp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (constraintCase_ == ConstraintOneofCase.RotationWithTolerance) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RotationWithTolerance);
      }
      if (constraintCase_ == ConstraintOneofCase.VectorAlignmentWithTolerance) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VectorAlignmentWithTolerance);
      }
      if (constraintCase_ == ConstraintOneofCase.SqueezeGrasp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SqueezeGrasp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AllowableOrientation other) {
      if (other == null) {
        return;
      }
      switch (other.ConstraintCase) {
        case ConstraintOneofCase.RotationWithTolerance:
          if (RotationWithTolerance == null) {
            RotationWithTolerance = new global::Bosdyn.Api.RotationWithTolerance();
          }
          RotationWithTolerance.MergeFrom(other.RotationWithTolerance);
          break;
        case ConstraintOneofCase.VectorAlignmentWithTolerance:
          if (VectorAlignmentWithTolerance == null) {
            VectorAlignmentWithTolerance = new global::Bosdyn.Api.VectorAlignmentWithTolerance();
          }
          VectorAlignmentWithTolerance.MergeFrom(other.VectorAlignmentWithTolerance);
          break;
        case ConstraintOneofCase.SqueezeGrasp:
          if (SqueezeGrasp == null) {
            SqueezeGrasp = new global::Bosdyn.Api.SqueezeGrasp();
          }
          SqueezeGrasp.MergeFrom(other.SqueezeGrasp);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Bosdyn.Api.RotationWithTolerance subBuilder = new global::Bosdyn.Api.RotationWithTolerance();
            if (constraintCase_ == ConstraintOneofCase.RotationWithTolerance) {
              subBuilder.MergeFrom(RotationWithTolerance);
            }
            input.ReadMessage(subBuilder);
            RotationWithTolerance = subBuilder;
            break;
          }
          case 18: {
            global::Bosdyn.Api.VectorAlignmentWithTolerance subBuilder = new global::Bosdyn.Api.VectorAlignmentWithTolerance();
            if (constraintCase_ == ConstraintOneofCase.VectorAlignmentWithTolerance) {
              subBuilder.MergeFrom(VectorAlignmentWithTolerance);
            }
            input.ReadMessage(subBuilder);
            VectorAlignmentWithTolerance = subBuilder;
            break;
          }
          case 26: {
            global::Bosdyn.Api.SqueezeGrasp subBuilder = new global::Bosdyn.Api.SqueezeGrasp();
            if (constraintCase_ == ConstraintOneofCase.SqueezeGrasp) {
              subBuilder.MergeFrom(SqueezeGrasp);
            }
            input.ReadMessage(subBuilder);
            SqueezeGrasp = subBuilder;
            break;
          }
        }
      }
    }

  }

  public sealed partial class RotationWithTolerance : pb::IMessage<RotationWithTolerance> {
    private static readonly pb::MessageParser<RotationWithTolerance> _parser = new pb::MessageParser<RotationWithTolerance>(() => new RotationWithTolerance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RotationWithTolerance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationWithTolerance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationWithTolerance(RotationWithTolerance other) : this() {
      rotationEwrtFrame_ = other.rotationEwrtFrame_ != null ? other.rotationEwrtFrame_.Clone() : null;
      thresholdRadians_ = other.thresholdRadians_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RotationWithTolerance Clone() {
      return new RotationWithTolerance(this);
    }

    /// <summary>Field number for the "rotation_ewrt_frame" field.</summary>
    public const int RotationEwrtFrameFieldNumber = 1;
    private global::Bosdyn.Api.Quaternion rotationEwrtFrame_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Quaternion RotationEwrtFrame {
      get { return rotationEwrtFrame_; }
      set {
        rotationEwrtFrame_ = value;
      }
    }

    /// <summary>Field number for the "threshold_radians" field.</summary>
    public const int ThresholdRadiansFieldNumber = 2;
    private float thresholdRadians_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ThresholdRadians {
      get { return thresholdRadians_; }
      set {
        thresholdRadians_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RotationWithTolerance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RotationWithTolerance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(RotationEwrtFrame, other.RotationEwrtFrame)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ThresholdRadians, other.ThresholdRadians)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (rotationEwrtFrame_ != null) hash ^= RotationEwrtFrame.GetHashCode();
      if (ThresholdRadians != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ThresholdRadians);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (rotationEwrtFrame_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(RotationEwrtFrame);
      }
      if (ThresholdRadians != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(ThresholdRadians);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (rotationEwrtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RotationEwrtFrame);
      }
      if (ThresholdRadians != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RotationWithTolerance other) {
      if (other == null) {
        return;
      }
      if (other.rotationEwrtFrame_ != null) {
        if (rotationEwrtFrame_ == null) {
          RotationEwrtFrame = new global::Bosdyn.Api.Quaternion();
        }
        RotationEwrtFrame.MergeFrom(other.RotationEwrtFrame);
      }
      if (other.ThresholdRadians != 0F) {
        ThresholdRadians = other.ThresholdRadians;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (rotationEwrtFrame_ == null) {
              RotationEwrtFrame = new global::Bosdyn.Api.Quaternion();
            }
            input.ReadMessage(RotationEwrtFrame);
            break;
          }
          case 21: {
            ThresholdRadians = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class VectorAlignmentWithTolerance : pb::IMessage<VectorAlignmentWithTolerance> {
    private static readonly pb::MessageParser<VectorAlignmentWithTolerance> _parser = new pb::MessageParser<VectorAlignmentWithTolerance>(() => new VectorAlignmentWithTolerance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VectorAlignmentWithTolerance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VectorAlignmentWithTolerance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VectorAlignmentWithTolerance(VectorAlignmentWithTolerance other) : this() {
      axisOnGripperEwrtGripper_ = other.axisOnGripperEwrtGripper_ != null ? other.axisOnGripperEwrtGripper_.Clone() : null;
      axisToAlignWithEwrtFrame_ = other.axisToAlignWithEwrtFrame_ != null ? other.axisToAlignWithEwrtFrame_.Clone() : null;
      thresholdRadians_ = other.thresholdRadians_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VectorAlignmentWithTolerance Clone() {
      return new VectorAlignmentWithTolerance(this);
    }

    /// <summary>Field number for the "axis_on_gripper_ewrt_gripper" field.</summary>
    public const int AxisOnGripperEwrtGripperFieldNumber = 1;
    private global::Bosdyn.Api.Vec3 axisOnGripperEwrtGripper_;
    /// <summary>
    /// Axis on the gripper that you want to align.  For example, to align the front of the gripper
    /// to be straight down, you'd use: \
    ///      axis_on_gripper_ewrt_gripper = Vec3(1, 0, 0) \
    ///      axis_to_align_with_ewrt_frame = Vec3(0, 0, -1)   (in the "vision" frame) \
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 AxisOnGripperEwrtGripper {
      get { return axisOnGripperEwrtGripper_; }
      set {
        axisOnGripperEwrtGripper_ = value;
      }
    }

    /// <summary>Field number for the "axis_to_align_with_ewrt_frame" field.</summary>
    public const int AxisToAlignWithEwrtFrameFieldNumber = 2;
    private global::Bosdyn.Api.Vec3 axisToAlignWithEwrtFrame_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 AxisToAlignWithEwrtFrame {
      get { return axisToAlignWithEwrtFrame_; }
      set {
        axisToAlignWithEwrtFrame_ = value;
      }
    }

    /// <summary>Field number for the "threshold_radians" field.</summary>
    public const int ThresholdRadiansFieldNumber = 3;
    private float thresholdRadians_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ThresholdRadians {
      get { return thresholdRadians_; }
      set {
        thresholdRadians_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VectorAlignmentWithTolerance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VectorAlignmentWithTolerance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AxisOnGripperEwrtGripper, other.AxisOnGripperEwrtGripper)) return false;
      if (!object.Equals(AxisToAlignWithEwrtFrame, other.AxisToAlignWithEwrtFrame)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ThresholdRadians, other.ThresholdRadians)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (axisOnGripperEwrtGripper_ != null) hash ^= AxisOnGripperEwrtGripper.GetHashCode();
      if (axisToAlignWithEwrtFrame_ != null) hash ^= AxisToAlignWithEwrtFrame.GetHashCode();
      if (ThresholdRadians != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ThresholdRadians);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (axisOnGripperEwrtGripper_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AxisOnGripperEwrtGripper);
      }
      if (axisToAlignWithEwrtFrame_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AxisToAlignWithEwrtFrame);
      }
      if (ThresholdRadians != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(ThresholdRadians);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (axisOnGripperEwrtGripper_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AxisOnGripperEwrtGripper);
      }
      if (axisToAlignWithEwrtFrame_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AxisToAlignWithEwrtFrame);
      }
      if (ThresholdRadians != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VectorAlignmentWithTolerance other) {
      if (other == null) {
        return;
      }
      if (other.axisOnGripperEwrtGripper_ != null) {
        if (axisOnGripperEwrtGripper_ == null) {
          AxisOnGripperEwrtGripper = new global::Bosdyn.Api.Vec3();
        }
        AxisOnGripperEwrtGripper.MergeFrom(other.AxisOnGripperEwrtGripper);
      }
      if (other.axisToAlignWithEwrtFrame_ != null) {
        if (axisToAlignWithEwrtFrame_ == null) {
          AxisToAlignWithEwrtFrame = new global::Bosdyn.Api.Vec3();
        }
        AxisToAlignWithEwrtFrame.MergeFrom(other.AxisToAlignWithEwrtFrame);
      }
      if (other.ThresholdRadians != 0F) {
        ThresholdRadians = other.ThresholdRadians;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (axisOnGripperEwrtGripper_ == null) {
              AxisOnGripperEwrtGripper = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(AxisOnGripperEwrtGripper);
            break;
          }
          case 18: {
            if (axisToAlignWithEwrtFrame_ == null) {
              AxisToAlignWithEwrtFrame = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(AxisToAlignWithEwrtFrame);
            break;
          }
          case 29: {
            ThresholdRadians = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A "squeeze grasp" is a top-down grasp where we try to keep both jaws of the gripper in
  /// contact with the ground and bring the jaws together.  This can allow the robot to pick up
  /// small objects on the ground.
  ///
  /// If you specify a SqueezeGrasp as:
  ///      allowed:
  ///          - with no other allowable orientations:
  ///              then the robot will perform a squeeze grasp.
  ///          - with at least one other allowable orientation:
  ///              the robot will attempt to find a normal grasp with that orientation and if it
  ///              fails, will perform a squeeze grasp.
  ///      disallowed:
  ///          - with no other allowable orientations:
  ///              the robot will perform an unconstrained grasp search and a grasp if a good grasp
  ///              is found.  If no grasp is found, the robot will report
  ///              MANIP_STATE_GRASP_PLANNING_NO_SOLUTION
  ///          - with other allowable orientations:
  ///              the robot will attempt to find a valid grasp.  If it cannot it will report
  ///              MANIP_STATE_GRASP_PLANNING_NO_SOLUTION
  /// </summary>
  public sealed partial class SqueezeGrasp : pb::IMessage<SqueezeGrasp> {
    private static readonly pb::MessageParser<SqueezeGrasp> _parser = new pb::MessageParser<SqueezeGrasp>(() => new SqueezeGrasp());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SqueezeGrasp> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SqueezeGrasp() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SqueezeGrasp(SqueezeGrasp other) : this() {
      squeezeGraspDisallowed_ = other.squeezeGraspDisallowed_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SqueezeGrasp Clone() {
      return new SqueezeGrasp(this);
    }

    /// <summary>Field number for the "squeeze_grasp_disallowed" field.</summary>
    public const int SqueezeGraspDisallowedFieldNumber = 1;
    private bool squeezeGraspDisallowed_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SqueezeGraspDisallowed {
      get { return squeezeGraspDisallowed_; }
      set {
        squeezeGraspDisallowed_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SqueezeGrasp);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SqueezeGrasp other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SqueezeGraspDisallowed != other.SqueezeGraspDisallowed) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SqueezeGraspDisallowed != false) hash ^= SqueezeGraspDisallowed.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SqueezeGraspDisallowed != false) {
        output.WriteRawTag(8);
        output.WriteBool(SqueezeGraspDisallowed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SqueezeGraspDisallowed != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SqueezeGrasp other) {
      if (other == null) {
        return;
      }
      if (other.SqueezeGraspDisallowed != false) {
        SqueezeGraspDisallowed = other.SqueezeGraspDisallowed;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SqueezeGraspDisallowed = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ManipulationApiFeedbackRequest : pb::IMessage<ManipulationApiFeedbackRequest> {
    private static readonly pb::MessageParser<ManipulationApiFeedbackRequest> _parser = new pb::MessageParser<ManipulationApiFeedbackRequest>(() => new ManipulationApiFeedbackRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ManipulationApiFeedbackRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackRequest(ManipulationApiFeedbackRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      manipulationCmdId_ = other.manipulationCmdId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackRequest Clone() {
      return new ManipulationApiFeedbackRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "manipulation_cmd_id" field.</summary>
    public const int ManipulationCmdIdFieldNumber = 2;
    private int manipulationCmdId_;
    /// <summary>
    /// Unique identifier for the command, provided by ManipulationApiResponse.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ManipulationCmdId {
      get { return manipulationCmdId_; }
      set {
        manipulationCmdId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ManipulationApiFeedbackRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ManipulationApiFeedbackRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (ManipulationCmdId != other.ManipulationCmdId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (ManipulationCmdId != 0) hash ^= ManipulationCmdId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (ManipulationCmdId != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(ManipulationCmdId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ManipulationCmdId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ManipulationCmdId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ManipulationApiFeedbackRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.ManipulationCmdId != 0) {
        ManipulationCmdId = other.ManipulationCmdId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 16: {
            ManipulationCmdId = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ManipulationApiFeedbackResponse : pb::IMessage<ManipulationApiFeedbackResponse> {
    private static readonly pb::MessageParser<ManipulationApiFeedbackResponse> _parser = new pb::MessageParser<ManipulationApiFeedbackResponse>(() => new ManipulationApiFeedbackResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ManipulationApiFeedbackResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackResponse(ManipulationApiFeedbackResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      manipulationCmdId_ = other.manipulationCmdId_;
      currentState_ = other.currentState_;
      transformsSnapshotManipulationData_ = other.transformsSnapshotManipulationData_ != null ? other.transformsSnapshotManipulationData_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiFeedbackResponse Clone() {
      return new ManipulationApiFeedbackResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    //// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "manipulation_cmd_id" field.</summary>
    public const int ManipulationCmdIdFieldNumber = 4;
    private int manipulationCmdId_;
    /// <summary>
    /// The unique identifier for the ManipulationApiFeedbackRequest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ManipulationCmdId {
      get { return manipulationCmdId_; }
      set {
        manipulationCmdId_ = value;
      }
    }

    /// <summary>Field number for the "current_state" field.</summary>
    public const int CurrentStateFieldNumber = 2;
    private global::Bosdyn.Api.ManipulationFeedbackState currentState_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ManipulationFeedbackState CurrentState {
      get { return currentState_; }
      set {
        currentState_ = value;
      }
    }

    /// <summary>Field number for the "transforms_snapshot_manipulation_data" field.</summary>
    public const int TransformsSnapshotManipulationDataFieldNumber = 3;
    private global::Bosdyn.Api.FrameTreeSnapshot transformsSnapshotManipulationData_;
    /// <summary>
    /// Data from the manipulation system: \
    /// "walkto_raycast_intersection": \
    ///      If you sent a WalkToObject request, we raycast in the world to intersect your pixel/ray
    ///      with the world.  The point of intersection is included in this transform snapshot
    ///      with the name "walkto_raycast_intersection". \
    /// "grasp_planning_solution": \
    ///      If you requested a grasp plan, this frame will contain the planning solution if
    ///      available.  This will be the pose of the "hand" frame at the completion of the grasp. \
    /// "gripper_nearest_object": \
    ///      If the range camera in the hand senses an object, this frame will have the position of
    ///      the nearest object.  This is useful for getting a ballpark range measurement.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.FrameTreeSnapshot TransformsSnapshotManipulationData {
      get { return transformsSnapshotManipulationData_; }
      set {
        transformsSnapshotManipulationData_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ManipulationApiFeedbackResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ManipulationApiFeedbackResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (ManipulationCmdId != other.ManipulationCmdId) return false;
      if (CurrentState != other.CurrentState) return false;
      if (!object.Equals(TransformsSnapshotManipulationData, other.TransformsSnapshotManipulationData)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (ManipulationCmdId != 0) hash ^= ManipulationCmdId.GetHashCode();
      if (CurrentState != 0) hash ^= CurrentState.GetHashCode();
      if (transformsSnapshotManipulationData_ != null) hash ^= TransformsSnapshotManipulationData.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (CurrentState != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CurrentState);
      }
      if (transformsSnapshotManipulationData_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TransformsSnapshotManipulationData);
      }
      if (ManipulationCmdId != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(ManipulationCmdId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ManipulationCmdId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ManipulationCmdId);
      }
      if (CurrentState != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CurrentState);
      }
      if (transformsSnapshotManipulationData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransformsSnapshotManipulationData);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ManipulationApiFeedbackResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.ManipulationCmdId != 0) {
        ManipulationCmdId = other.ManipulationCmdId;
      }
      if (other.CurrentState != 0) {
        CurrentState = other.CurrentState;
      }
      if (other.transformsSnapshotManipulationData_ != null) {
        if (transformsSnapshotManipulationData_ == null) {
          TransformsSnapshotManipulationData = new global::Bosdyn.Api.FrameTreeSnapshot();
        }
        TransformsSnapshotManipulationData.MergeFrom(other.TransformsSnapshotManipulationData);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 16: {
            CurrentState = (global::Bosdyn.Api.ManipulationFeedbackState) input.ReadEnum();
            break;
          }
          case 26: {
            if (transformsSnapshotManipulationData_ == null) {
              TransformsSnapshotManipulationData = new global::Bosdyn.Api.FrameTreeSnapshot();
            }
            input.ReadMessage(TransformsSnapshotManipulationData);
            break;
          }
          case 32: {
            ManipulationCmdId = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ManipulationApiResponse : pb::IMessage<ManipulationApiResponse> {
    private static readonly pb::MessageParser<ManipulationApiResponse> _parser = new pb::MessageParser<ManipulationApiResponse>(() => new ManipulationApiResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ManipulationApiResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiResponse(ManipulationApiResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      manipulationCmdId_ = other.manipulationCmdId_;
      leaseUseResult_ = other.leaseUseResult_ != null ? other.leaseUseResult_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiResponse Clone() {
      return new ManipulationApiResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    //// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "manipulation_cmd_id" field.</summary>
    public const int ManipulationCmdIdFieldNumber = 5;
    private int manipulationCmdId_;
    /// <summary>
    /// ID of the manipulation command either just issued or that we are providing feedback for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ManipulationCmdId {
      get { return manipulationCmdId_; }
      set {
        manipulationCmdId_ = value;
      }
    }

    /// <summary>Field number for the "lease_use_result" field.</summary>
    public const int LeaseUseResultFieldNumber = 6;
    private global::Bosdyn.Api.LeaseUseResult leaseUseResult_;
    /// <summary>
    /// Details about how the lease was used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.LeaseUseResult LeaseUseResult {
      get { return leaseUseResult_; }
      set {
        leaseUseResult_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ManipulationApiResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ManipulationApiResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (ManipulationCmdId != other.ManipulationCmdId) return false;
      if (!object.Equals(LeaseUseResult, other.LeaseUseResult)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (ManipulationCmdId != 0) hash ^= ManipulationCmdId.GetHashCode();
      if (leaseUseResult_ != null) hash ^= LeaseUseResult.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (ManipulationCmdId != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(ManipulationCmdId);
      }
      if (leaseUseResult_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(LeaseUseResult);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ManipulationCmdId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ManipulationCmdId);
      }
      if (leaseUseResult_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LeaseUseResult);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ManipulationApiResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.ManipulationCmdId != 0) {
        ManipulationCmdId = other.ManipulationCmdId;
      }
      if (other.leaseUseResult_ != null) {
        if (leaseUseResult_ == null) {
          LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
        }
        LeaseUseResult.MergeFrom(other.LeaseUseResult);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 40: {
            ManipulationCmdId = input.ReadInt32();
            break;
          }
          case 50: {
            if (leaseUseResult_ == null) {
              LeaseUseResult = new global::Bosdyn.Api.LeaseUseResult();
            }
            input.ReadMessage(LeaseUseResult);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ManipulationApiRequest : pb::IMessage<ManipulationApiRequest> {
    private static readonly pb::MessageParser<ManipulationApiRequest> _parser = new pb::MessageParser<ManipulationApiRequest>(() => new ManipulationApiRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ManipulationApiRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiRequest(ManipulationApiRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      lease_ = other.lease_ != null ? other.lease_.Clone() : null;
      switch (other.ManipulationCmdCase) {
        case ManipulationCmdOneofCase.WalkToObjectRayInWorld:
          WalkToObjectRayInWorld = other.WalkToObjectRayInWorld.Clone();
          break;
        case ManipulationCmdOneofCase.WalkToObjectInImage:
          WalkToObjectInImage = other.WalkToObjectInImage.Clone();
          break;
        case ManipulationCmdOneofCase.PickObject:
          PickObject = other.PickObject.Clone();
          break;
        case ManipulationCmdOneofCase.PickObjectInImage:
          PickObjectInImage = other.PickObjectInImage.Clone();
          break;
        case ManipulationCmdOneofCase.PickObjectRayInWorld:
          PickObjectRayInWorld = other.PickObjectRayInWorld.Clone();
          break;
        case ManipulationCmdOneofCase.PickObjectExecutePlan:
          PickObjectExecutePlan = other.PickObjectExecutePlan.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationApiRequest Clone() {
      return new ManipulationApiRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "lease" field.</summary>
    public const int LeaseFieldNumber = 2;
    private global::Bosdyn.Api.Lease lease_;
    /// <summary>
    /// The Lease to show ownership of the robot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Lease Lease {
      get { return lease_; }
      set {
        lease_ = value;
      }
    }

    /// <summary>Field number for the "walk_to_object_ray_in_world" field.</summary>
    public const int WalkToObjectRayInWorldFieldNumber = 12;
    /// <summary>
    /// Walk to an object with a raycast in to the world
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.WalkToObjectRayInWorld WalkToObjectRayInWorld {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectRayInWorld ? (global::Bosdyn.Api.WalkToObjectRayInWorld) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.WalkToObjectRayInWorld;
      }
    }

    /// <summary>Field number for the "walk_to_object_in_image" field.</summary>
    public const int WalkToObjectInImageFieldNumber = 13;
    /// <summary>
    /// Walk to an object at a pixel location in an image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.WalkToObjectInImage WalkToObjectInImage {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectInImage ? (global::Bosdyn.Api.WalkToObjectInImage) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.WalkToObjectInImage;
      }
    }

    /// <summary>Field number for the "pick_object" field.</summary>
    public const int PickObjectFieldNumber = 10;
    /// <summary>
    /// Pick up an object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PickObject PickObject {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.PickObject ? (global::Bosdyn.Api.PickObject) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.PickObject;
      }
    }

    /// <summary>Field number for the "pick_object_in_image" field.</summary>
    public const int PickObjectInImageFieldNumber = 11;
    /// <summary>
    /// Pick up an object at a pixel location in an image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PickObjectInImage PickObjectInImage {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectInImage ? (global::Bosdyn.Api.PickObjectInImage) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.PickObjectInImage;
      }
    }

    /// <summary>Field number for the "pick_object_ray_in_world" field.</summary>
    public const int PickObjectRayInWorldFieldNumber = 4;
    /// <summary>
    /// Pick up an object based on a ray in 3D space.  This is the lowest-level, most
    /// configurable object picking command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PickObjectRayInWorld PickObjectRayInWorld {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectRayInWorld ? (global::Bosdyn.Api.PickObjectRayInWorld) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.PickObjectRayInWorld;
      }
    }

    /// <summary>Field number for the "pick_object_execute_plan" field.</summary>
    public const int PickObjectExecutePlanFieldNumber = 14;
    /// <summary>
    /// Execute a previously planned pick.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PickObjectExecutePlan PickObjectExecutePlan {
      get { return manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectExecutePlan ? (global::Bosdyn.Api.PickObjectExecutePlan) manipulationCmd_ : null; }
      set {
        manipulationCmd_ = value;
        manipulationCmdCase_ = value == null ? ManipulationCmdOneofCase.None : ManipulationCmdOneofCase.PickObjectExecutePlan;
      }
    }

    private object manipulationCmd_;
    /// <summary>Enum of possible cases for the "manipulation_cmd" oneof.</summary>
    public enum ManipulationCmdOneofCase {
      None = 0,
      WalkToObjectRayInWorld = 12,
      WalkToObjectInImage = 13,
      PickObject = 10,
      PickObjectInImage = 11,
      PickObjectRayInWorld = 4,
      PickObjectExecutePlan = 14,
    }
    private ManipulationCmdOneofCase manipulationCmdCase_ = ManipulationCmdOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ManipulationCmdOneofCase ManipulationCmdCase {
      get { return manipulationCmdCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearManipulationCmd() {
      manipulationCmdCase_ = ManipulationCmdOneofCase.None;
      manipulationCmd_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ManipulationApiRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ManipulationApiRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(Lease, other.Lease)) return false;
      if (!object.Equals(WalkToObjectRayInWorld, other.WalkToObjectRayInWorld)) return false;
      if (!object.Equals(WalkToObjectInImage, other.WalkToObjectInImage)) return false;
      if (!object.Equals(PickObject, other.PickObject)) return false;
      if (!object.Equals(PickObjectInImage, other.PickObjectInImage)) return false;
      if (!object.Equals(PickObjectRayInWorld, other.PickObjectRayInWorld)) return false;
      if (!object.Equals(PickObjectExecutePlan, other.PickObjectExecutePlan)) return false;
      if (ManipulationCmdCase != other.ManipulationCmdCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (lease_ != null) hash ^= Lease.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectRayInWorld) hash ^= WalkToObjectRayInWorld.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectInImage) hash ^= WalkToObjectInImage.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObject) hash ^= PickObject.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectInImage) hash ^= PickObjectInImage.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectRayInWorld) hash ^= PickObjectRayInWorld.GetHashCode();
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectExecutePlan) hash ^= PickObjectExecutePlan.GetHashCode();
      hash ^= (int) manipulationCmdCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (lease_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Lease);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectRayInWorld) {
        output.WriteRawTag(34);
        output.WriteMessage(PickObjectRayInWorld);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObject) {
        output.WriteRawTag(82);
        output.WriteMessage(PickObject);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectInImage) {
        output.WriteRawTag(90);
        output.WriteMessage(PickObjectInImage);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectRayInWorld) {
        output.WriteRawTag(98);
        output.WriteMessage(WalkToObjectRayInWorld);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectInImage) {
        output.WriteRawTag(106);
        output.WriteMessage(WalkToObjectInImage);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectExecutePlan) {
        output.WriteRawTag(114);
        output.WriteMessage(PickObjectExecutePlan);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (lease_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lease);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectRayInWorld) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WalkToObjectRayInWorld);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectInImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WalkToObjectInImage);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObject) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickObject);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectInImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickObjectInImage);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectRayInWorld) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickObjectRayInWorld);
      }
      if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectExecutePlan) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickObjectExecutePlan);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ManipulationApiRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.lease_ != null) {
        if (lease_ == null) {
          Lease = new global::Bosdyn.Api.Lease();
        }
        Lease.MergeFrom(other.Lease);
      }
      switch (other.ManipulationCmdCase) {
        case ManipulationCmdOneofCase.WalkToObjectRayInWorld:
          if (WalkToObjectRayInWorld == null) {
            WalkToObjectRayInWorld = new global::Bosdyn.Api.WalkToObjectRayInWorld();
          }
          WalkToObjectRayInWorld.MergeFrom(other.WalkToObjectRayInWorld);
          break;
        case ManipulationCmdOneofCase.WalkToObjectInImage:
          if (WalkToObjectInImage == null) {
            WalkToObjectInImage = new global::Bosdyn.Api.WalkToObjectInImage();
          }
          WalkToObjectInImage.MergeFrom(other.WalkToObjectInImage);
          break;
        case ManipulationCmdOneofCase.PickObject:
          if (PickObject == null) {
            PickObject = new global::Bosdyn.Api.PickObject();
          }
          PickObject.MergeFrom(other.PickObject);
          break;
        case ManipulationCmdOneofCase.PickObjectInImage:
          if (PickObjectInImage == null) {
            PickObjectInImage = new global::Bosdyn.Api.PickObjectInImage();
          }
          PickObjectInImage.MergeFrom(other.PickObjectInImage);
          break;
        case ManipulationCmdOneofCase.PickObjectRayInWorld:
          if (PickObjectRayInWorld == null) {
            PickObjectRayInWorld = new global::Bosdyn.Api.PickObjectRayInWorld();
          }
          PickObjectRayInWorld.MergeFrom(other.PickObjectRayInWorld);
          break;
        case ManipulationCmdOneofCase.PickObjectExecutePlan:
          if (PickObjectExecutePlan == null) {
            PickObjectExecutePlan = new global::Bosdyn.Api.PickObjectExecutePlan();
          }
          PickObjectExecutePlan.MergeFrom(other.PickObjectExecutePlan);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (lease_ == null) {
              Lease = new global::Bosdyn.Api.Lease();
            }
            input.ReadMessage(Lease);
            break;
          }
          case 34: {
            global::Bosdyn.Api.PickObjectRayInWorld subBuilder = new global::Bosdyn.Api.PickObjectRayInWorld();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectRayInWorld) {
              subBuilder.MergeFrom(PickObjectRayInWorld);
            }
            input.ReadMessage(subBuilder);
            PickObjectRayInWorld = subBuilder;
            break;
          }
          case 82: {
            global::Bosdyn.Api.PickObject subBuilder = new global::Bosdyn.Api.PickObject();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObject) {
              subBuilder.MergeFrom(PickObject);
            }
            input.ReadMessage(subBuilder);
            PickObject = subBuilder;
            break;
          }
          case 90: {
            global::Bosdyn.Api.PickObjectInImage subBuilder = new global::Bosdyn.Api.PickObjectInImage();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectInImage) {
              subBuilder.MergeFrom(PickObjectInImage);
            }
            input.ReadMessage(subBuilder);
            PickObjectInImage = subBuilder;
            break;
          }
          case 98: {
            global::Bosdyn.Api.WalkToObjectRayInWorld subBuilder = new global::Bosdyn.Api.WalkToObjectRayInWorld();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectRayInWorld) {
              subBuilder.MergeFrom(WalkToObjectRayInWorld);
            }
            input.ReadMessage(subBuilder);
            WalkToObjectRayInWorld = subBuilder;
            break;
          }
          case 106: {
            global::Bosdyn.Api.WalkToObjectInImage subBuilder = new global::Bosdyn.Api.WalkToObjectInImage();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.WalkToObjectInImage) {
              subBuilder.MergeFrom(WalkToObjectInImage);
            }
            input.ReadMessage(subBuilder);
            WalkToObjectInImage = subBuilder;
            break;
          }
          case 114: {
            global::Bosdyn.Api.PickObjectExecutePlan subBuilder = new global::Bosdyn.Api.PickObjectExecutePlan();
            if (manipulationCmdCase_ == ManipulationCmdOneofCase.PickObjectExecutePlan) {
              subBuilder.MergeFrom(PickObjectExecutePlan);
            }
            input.ReadMessage(subBuilder);
            PickObjectExecutePlan = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Use this message to assert the ground truth about grasping.
  /// Grasping is usually detected automatically by the robot. If the client wishes to override the
  /// robot's determination of grasp status, send an ApiGraspOverride message with either:
  /// OVERRIDE_HOLDING, indicating the gripper is holding something, or
  /// OVERRIDE_NOT_HOLDING, indicating the gripper is not holding
  /// anything.
  /// </summary>
  public sealed partial class ApiGraspOverride : pb::IMessage<ApiGraspOverride> {
    private static readonly pb::MessageParser<ApiGraspOverride> _parser = new pb::MessageParser<ApiGraspOverride>(() => new ApiGraspOverride());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApiGraspOverride> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverride() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverride(ApiGraspOverride other) : this() {
      overrideRequest_ = other.overrideRequest_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverride Clone() {
      return new ApiGraspOverride(this);
    }

    /// <summary>Field number for the "override_request" field.</summary>
    public const int OverrideRequestFieldNumber = 1;
    private global::Bosdyn.Api.ApiGraspOverride.Types.Override overrideRequest_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ApiGraspOverride.Types.Override OverrideRequest {
      get { return overrideRequest_; }
      set {
        overrideRequest_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApiGraspOverride);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApiGraspOverride other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OverrideRequest != other.OverrideRequest) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OverrideRequest != 0) hash ^= OverrideRequest.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OverrideRequest != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) OverrideRequest);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OverrideRequest != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OverrideRequest);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApiGraspOverride other) {
      if (other == null) {
        return;
      }
      if (other.OverrideRequest != 0) {
        OverrideRequest = other.OverrideRequest;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            OverrideRequest = (global::Bosdyn.Api.ApiGraspOverride.Types.Override) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ApiGraspOverride message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Override {
        [pbr::OriginalName("OVERRIDE_UNKNOWN")] Unknown = 0,
        [pbr::OriginalName("OVERRIDE_HOLDING")] Holding = 1,
        [pbr::OriginalName("OVERRIDE_NOT_HOLDING")] NotHolding = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Use this message to assert properties about the grasped item.
  /// By default, the robot will assume all grasped items are not carriable.
  /// </summary>
  public sealed partial class ApiGraspedCarryStateOverride : pb::IMessage<ApiGraspedCarryStateOverride> {
    private static readonly pb::MessageParser<ApiGraspedCarryStateOverride> _parser = new pb::MessageParser<ApiGraspedCarryStateOverride>(() => new ApiGraspedCarryStateOverride());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApiGraspedCarryStateOverride> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspedCarryStateOverride() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspedCarryStateOverride(ApiGraspedCarryStateOverride other) : this() {
      overrideRequest_ = other.overrideRequest_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspedCarryStateOverride Clone() {
      return new ApiGraspedCarryStateOverride(this);
    }

    /// <summary>Field number for the "override_request" field.</summary>
    public const int OverrideRequestFieldNumber = 1;
    private global::Bosdyn.Api.ManipulatorState.Types.CarryState overrideRequest_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ManipulatorState.Types.CarryState OverrideRequest {
      get { return overrideRequest_; }
      set {
        overrideRequest_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApiGraspedCarryStateOverride);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApiGraspedCarryStateOverride other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OverrideRequest != other.OverrideRequest) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OverrideRequest != 0) hash ^= OverrideRequest.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OverrideRequest != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) OverrideRequest);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OverrideRequest != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OverrideRequest);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApiGraspedCarryStateOverride other) {
      if (other == null) {
        return;
      }
      if (other.OverrideRequest != 0) {
        OverrideRequest = other.OverrideRequest;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            OverrideRequest = (global::Bosdyn.Api.ManipulatorState.Types.CarryState) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ApiGraspOverrideRequest : pb::IMessage<ApiGraspOverrideRequest> {
    private static readonly pb::MessageParser<ApiGraspOverrideRequest> _parser = new pb::MessageParser<ApiGraspOverrideRequest>(() => new ApiGraspOverrideRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApiGraspOverrideRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideRequest(ApiGraspOverrideRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      apiGraspOverride_ = other.apiGraspOverride_ != null ? other.apiGraspOverride_.Clone() : null;
      carryStateOverride_ = other.carryStateOverride_ != null ? other.carryStateOverride_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideRequest Clone() {
      return new ApiGraspOverrideRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.RequestHeader header_;
    /// <summary>
    /// Common request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "api_grasp_override" field.</summary>
    public const int ApiGraspOverrideFieldNumber = 4;
    private global::Bosdyn.Api.ApiGraspOverride apiGraspOverride_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ApiGraspOverride ApiGraspOverride {
      get { return apiGraspOverride_; }
      set {
        apiGraspOverride_ = value;
      }
    }

    /// <summary>Field number for the "carry_state_override" field.</summary>
    public const int CarryStateOverrideFieldNumber = 2;
    private global::Bosdyn.Api.ApiGraspedCarryStateOverride carryStateOverride_;
    /// <summary>
    /// If the grasp override is set to NOT_HOLDING, setting a carry_state_override
    /// message will cause the request to be rejected as malformed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ApiGraspedCarryStateOverride CarryStateOverride {
      get { return carryStateOverride_; }
      set {
        carryStateOverride_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApiGraspOverrideRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApiGraspOverrideRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(ApiGraspOverride, other.ApiGraspOverride)) return false;
      if (!object.Equals(CarryStateOverride, other.CarryStateOverride)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (apiGraspOverride_ != null) hash ^= ApiGraspOverride.GetHashCode();
      if (carryStateOverride_ != null) hash ^= CarryStateOverride.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (carryStateOverride_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CarryStateOverride);
      }
      if (apiGraspOverride_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ApiGraspOverride);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (apiGraspOverride_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ApiGraspOverride);
      }
      if (carryStateOverride_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CarryStateOverride);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApiGraspOverrideRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.apiGraspOverride_ != null) {
        if (apiGraspOverride_ == null) {
          ApiGraspOverride = new global::Bosdyn.Api.ApiGraspOverride();
        }
        ApiGraspOverride.MergeFrom(other.ApiGraspOverride);
      }
      if (other.carryStateOverride_ != null) {
        if (carryStateOverride_ == null) {
          CarryStateOverride = new global::Bosdyn.Api.ApiGraspedCarryStateOverride();
        }
        CarryStateOverride.MergeFrom(other.CarryStateOverride);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 18: {
            if (carryStateOverride_ == null) {
              CarryStateOverride = new global::Bosdyn.Api.ApiGraspedCarryStateOverride();
            }
            input.ReadMessage(CarryStateOverride);
            break;
          }
          case 34: {
            if (apiGraspOverride_ == null) {
              ApiGraspOverride = new global::Bosdyn.Api.ApiGraspOverride();
            }
            input.ReadMessage(ApiGraspOverride);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ApiGraspOverrideResponse : pb::IMessage<ApiGraspOverrideResponse> {
    private static readonly pb::MessageParser<ApiGraspOverrideResponse> _parser = new pb::MessageParser<ApiGraspOverrideResponse>(() => new ApiGraspOverrideResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApiGraspOverrideResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ManipulationApiReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideResponse(ApiGraspOverrideResponse other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiGraspOverrideResponse Clone() {
      return new ApiGraspOverrideResponse(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Bosdyn.Api.ResponseHeader header_;
    /// <summary>
    /// Common response header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.ResponseHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApiGraspOverrideResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApiGraspOverrideResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApiGraspOverrideResponse other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Bosdyn.Api.ResponseHeader();
        }
        Header.MergeFrom(other.Header);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Bosdyn.Api.ResponseHeader();
            }
            input.ReadMessage(Header);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
