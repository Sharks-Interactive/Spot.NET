// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/sparse_features.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/sparse_features.proto</summary>
  public static partial class SparseFeaturesReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/sparse_features.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static SparseFeaturesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChxQcm90b3Mvc3BhcnNlX2ZlYXR1cmVzLnByb3RvEgpib3NkeW4uYXBpGhVQ",
            "cm90b3MvZ2VvbWV0cnkucHJvdG8ieAoIS2V5cG9pbnQSJQoLY29vcmRpbmF0",
            "ZXMYAiABKAsyEC5ib3NkeW4uYXBpLlZlYzISGQoRYmluYXJ5X2Rlc2NyaXB0",
            "b3IYAyABKAwSDQoFc2NvcmUYBCABKAISDAoEc2l6ZRgFIAEoAhINCgVhbmds",
            "ZRgGIAEoAiK3AQoLS2V5cG9pbnRTZXQSJwoJa2V5cG9pbnRzGAIgAygLMhQu",
            "Ym9zZHluLmFwaS5LZXlwb2ludBIyCgR0eXBlGAMgASgOMiQuYm9zZHluLmFw",
            "aS5LZXlwb2ludFNldC5LZXlwb2ludFR5cGUiSwoMS2V5cG9pbnRUeXBlEhQK",
            "EEtFWVBPSU5UX1VOS05PV04QABITCg9LRVlQT0lOVF9TSU1QTEUQARIQCgxL",
            "RVlQT0lOVF9PUkIQAiJGCgVNYXRjaBIXCg9yZWZlcmVuY2VfaW5kZXgYAiAB",
            "KAUSEgoKbGl2ZV9pbmRleBgDIAEoBRIQCghkaXN0YW5jZRgEIAEoAiKcAQoP",
            "S2V5cG9pbnRNYXRjaGVzEjQKE3JlZmVyZW5jZV9rZXlwb2ludHMYAiABKAsy",
            "Fy5ib3NkeW4uYXBpLktleXBvaW50U2V0Ei8KDmxpdmVfa2V5cG9pbnRzGAMg",
            "ASgLMhcuYm9zZHluLmFwaS5LZXlwb2ludFNldBIiCgdtYXRjaGVzGAQgAygL",
            "MhEuYm9zZHluLmFwaS5NYXRjaEIVQhNTcGFyc2VGZWF0dXJlc1Byb3RvYgZw",
            "cm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.GeometryReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Keypoint), global::Bosdyn.Api.Keypoint.Parser, new[]{ "Coordinates", "BinaryDescriptor", "Score", "Size", "Angle" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.KeypointSet), global::Bosdyn.Api.KeypointSet.Parser, new[]{ "Keypoints", "Type" }, null, new[]{ typeof(global::Bosdyn.Api.KeypointSet.Types.KeypointType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Match), global::Bosdyn.Api.Match.Parser, new[]{ "ReferenceIndex", "LiveIndex", "Distance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.KeypointMatches), global::Bosdyn.Api.KeypointMatches.Parser, new[]{ "ReferenceKeypoints", "LiveKeypoints", "Matches" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A point of interest in an image expressed as a pixel coordinate with associated metadata.
  /// </summary>
  public sealed partial class Keypoint : pb::IMessage<Keypoint> {
    private static readonly pb::MessageParser<Keypoint> _parser = new pb::MessageParser<Keypoint>(() => new Keypoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Keypoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.SparseFeaturesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keypoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keypoint(Keypoint other) : this() {
      coordinates_ = other.coordinates_ != null ? other.coordinates_.Clone() : null;
      binaryDescriptor_ = other.binaryDescriptor_;
      score_ = other.score_;
      size_ = other.size_;
      angle_ = other.angle_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Keypoint Clone() {
      return new Keypoint(this);
    }

    /// <summary>Field number for the "coordinates" field.</summary>
    public const int CoordinatesFieldNumber = 2;
    private global::Bosdyn.Api.Vec2 coordinates_;
    /// <summary>
    /// The image pixel coordinates of the keypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec2 Coordinates {
      get { return coordinates_; }
      set {
        coordinates_ = value;
      }
    }

    /// <summary>Field number for the "binary_descriptor" field.</summary>
    public const int BinaryDescriptorFieldNumber = 3;
    private pb::ByteString binaryDescriptor_ = pb::ByteString.Empty;
    /// <summary>
    /// A binary descriptor representing the keypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString BinaryDescriptor {
      get { return binaryDescriptor_; }
      set {
        binaryDescriptor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "score" field.</summary>
    public const int ScoreFieldNumber = 4;
    private float score_;
    /// <summary>
    /// The score of this keypoint from the underlying keypoint detector, if applicable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Score {
      get { return score_; }
      set {
        score_ = value;
      }
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 5;
    private float size_;
    /// <summary>
    /// The diameter in pixels of the local neighborhood used to construct the descriptor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Size {
      get { return size_; }
      set {
        size_ = value;
      }
    }

    /// <summary>Field number for the "angle" field.</summary>
    public const int AngleFieldNumber = 6;
    private float angle_;
    /// <summary>
    /// The orientation of the keypoint, if applicable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Angle {
      get { return angle_; }
      set {
        angle_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Keypoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Keypoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Coordinates, other.Coordinates)) return false;
      if (BinaryDescriptor != other.BinaryDescriptor) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Score, other.Score)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Size, other.Size)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Angle, other.Angle)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (coordinates_ != null) hash ^= Coordinates.GetHashCode();
      if (BinaryDescriptor.Length != 0) hash ^= BinaryDescriptor.GetHashCode();
      if (Score != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Score);
      if (Size != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Size);
      if (Angle != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Angle);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (coordinates_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Coordinates);
      }
      if (BinaryDescriptor.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(BinaryDescriptor);
      }
      if (Score != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Score);
      }
      if (Size != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Size);
      }
      if (Angle != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(Angle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (coordinates_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Coordinates);
      }
      if (BinaryDescriptor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(BinaryDescriptor);
      }
      if (Score != 0F) {
        size += 1 + 4;
      }
      if (Size != 0F) {
        size += 1 + 4;
      }
      if (Angle != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Keypoint other) {
      if (other == null) {
        return;
      }
      if (other.coordinates_ != null) {
        if (coordinates_ == null) {
          Coordinates = new global::Bosdyn.Api.Vec2();
        }
        Coordinates.MergeFrom(other.Coordinates);
      }
      if (other.BinaryDescriptor.Length != 0) {
        BinaryDescriptor = other.BinaryDescriptor;
      }
      if (other.Score != 0F) {
        Score = other.Score;
      }
      if (other.Size != 0F) {
        Size = other.Size;
      }
      if (other.Angle != 0F) {
        Angle = other.Angle;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (coordinates_ == null) {
              Coordinates = new global::Bosdyn.Api.Vec2();
            }
            input.ReadMessage(Coordinates);
            break;
          }
          case 26: {
            BinaryDescriptor = input.ReadBytes();
            break;
          }
          case 37: {
            Score = input.ReadFloat();
            break;
          }
          case 45: {
            Size = input.ReadFloat();
            break;
          }
          case 53: {
            Angle = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A set of keypoints detected in a single image.
  /// </summary>
  public sealed partial class KeypointSet : pb::IMessage<KeypointSet> {
    private static readonly pb::MessageParser<KeypointSet> _parser = new pb::MessageParser<KeypointSet>(() => new KeypointSet());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KeypointSet> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.SparseFeaturesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointSet() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointSet(KeypointSet other) : this() {
      keypoints_ = other.keypoints_.Clone();
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointSet Clone() {
      return new KeypointSet(this);
    }

    /// <summary>Field number for the "keypoints" field.</summary>
    public const int KeypointsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.Keypoint> _repeated_keypoints_codec
        = pb::FieldCodec.ForMessage(18, global::Bosdyn.Api.Keypoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.Keypoint> keypoints_ = new pbc::RepeatedField<global::Bosdyn.Api.Keypoint>();
    /// <summary>
    /// A set of detected keypoints and associated metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.Keypoint> Keypoints {
      get { return keypoints_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private global::Bosdyn.Api.KeypointSet.Types.KeypointType type_ = 0;
    /// <summary>
    /// The algorithm used to compute this keypoint and its descriptor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.KeypointSet.Types.KeypointType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KeypointSet);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KeypointSet other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keypoints_.Equals(other.keypoints_)) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keypoints_.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keypoints_.WriteTo(output, _repeated_keypoints_codec);
      if (Type != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keypoints_.CalculateSize(_repeated_keypoints_codec);
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KeypointSet other) {
      if (other == null) {
        return;
      }
      keypoints_.Add(other.keypoints_);
      if (other.Type != 0) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            keypoints_.AddEntriesFrom(input, _repeated_keypoints_codec);
            break;
          }
          case 24: {
            Type = (global::Bosdyn.Api.KeypointSet.Types.KeypointType) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the KeypointSet message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum KeypointType {
        [pbr::OriginalName("KEYPOINT_UNKNOWN")] KeypointUnknown = 0,
        /// <summary>
        /// Keypoints that consist only of image coordinates. Simple keypoints do not have
        /// descriptors.
        /// </summary>
        [pbr::OriginalName("KEYPOINT_SIMPLE")] KeypointSimple = 1,
        /// <summary>
        /// Keypoints detected by the ORB feature extraction algorithm (Oriented FAST and Rotated
        /// BRIEF.)
        /// </summary>
        [pbr::OriginalName("KEYPOINT_ORB")] KeypointOrb = 2,
      }

    }
    #endregion

  }

  public sealed partial class Match : pb::IMessage<Match> {
    private static readonly pb::MessageParser<Match> _parser = new pb::MessageParser<Match>(() => new Match());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Match> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.SparseFeaturesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Match() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Match(Match other) : this() {
      referenceIndex_ = other.referenceIndex_;
      liveIndex_ = other.liveIndex_;
      distance_ = other.distance_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Match Clone() {
      return new Match(this);
    }

    /// <summary>Field number for the "reference_index" field.</summary>
    public const int ReferenceIndexFieldNumber = 2;
    private int referenceIndex_;
    /// <summary>
    /// The index in the reference KeypointSet of the keypoint in the matching pair.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ReferenceIndex {
      get { return referenceIndex_; }
      set {
        referenceIndex_ = value;
      }
    }

    /// <summary>Field number for the "live_index" field.</summary>
    public const int LiveIndexFieldNumber = 3;
    private int liveIndex_;
    /// <summary>
    /// The index in the live KeypointSet of the keypoint in the matching pair.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int LiveIndex {
      get { return liveIndex_; }
      set {
        liveIndex_ = value;
      }
    }

    /// <summary>Field number for the "distance" field.</summary>
    public const int DistanceFieldNumber = 4;
    private float distance_;
    /// <summary>
    /// The distance in descriptor space between the two keypoints.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Distance {
      get { return distance_; }
      set {
        distance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Match);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Match other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ReferenceIndex != other.ReferenceIndex) return false;
      if (LiveIndex != other.LiveIndex) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Distance, other.Distance)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ReferenceIndex != 0) hash ^= ReferenceIndex.GetHashCode();
      if (LiveIndex != 0) hash ^= LiveIndex.GetHashCode();
      if (Distance != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Distance);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ReferenceIndex != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(ReferenceIndex);
      }
      if (LiveIndex != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(LiveIndex);
      }
      if (Distance != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Distance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ReferenceIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ReferenceIndex);
      }
      if (LiveIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(LiveIndex);
      }
      if (Distance != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Match other) {
      if (other == null) {
        return;
      }
      if (other.ReferenceIndex != 0) {
        ReferenceIndex = other.ReferenceIndex;
      }
      if (other.LiveIndex != 0) {
        LiveIndex = other.LiveIndex;
      }
      if (other.Distance != 0F) {
        Distance = other.Distance;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 16: {
            ReferenceIndex = input.ReadInt32();
            break;
          }
          case 24: {
            LiveIndex = input.ReadInt32();
            break;
          }
          case 37: {
            Distance = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A pair of keypoint sets containing only features in common that have been matched.
  /// </summary>
  public sealed partial class KeypointMatches : pb::IMessage<KeypointMatches> {
    private static readonly pb::MessageParser<KeypointMatches> _parser = new pb::MessageParser<KeypointMatches>(() => new KeypointMatches());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KeypointMatches> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.SparseFeaturesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointMatches() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointMatches(KeypointMatches other) : this() {
      referenceKeypoints_ = other.referenceKeypoints_ != null ? other.referenceKeypoints_.Clone() : null;
      liveKeypoints_ = other.liveKeypoints_ != null ? other.liveKeypoints_.Clone() : null;
      matches_ = other.matches_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeypointMatches Clone() {
      return new KeypointMatches(this);
    }

    /// <summary>Field number for the "reference_keypoints" field.</summary>
    public const int ReferenceKeypointsFieldNumber = 2;
    private global::Bosdyn.Api.KeypointSet referenceKeypoints_;
    /// <summary>
    /// The set of common keypoints in a first ("reference") image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.KeypointSet ReferenceKeypoints {
      get { return referenceKeypoints_; }
      set {
        referenceKeypoints_ = value;
      }
    }

    /// <summary>Field number for the "live_keypoints" field.</summary>
    public const int LiveKeypointsFieldNumber = 3;
    private global::Bosdyn.Api.KeypointSet liveKeypoints_;
    /// <summary>
    /// The set of common keypoints in a second ("live") image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.KeypointSet LiveKeypoints {
      get { return liveKeypoints_; }
      set {
        liveKeypoints_ = value;
      }
    }

    /// <summary>Field number for the "matches" field.</summary>
    public const int MatchesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.Match> _repeated_matches_codec
        = pb::FieldCodec.ForMessage(34, global::Bosdyn.Api.Match.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.Match> matches_ = new pbc::RepeatedField<global::Bosdyn.Api.Match>();
    /// <summary>
    /// Indices of pairs of matches in the two KeypointSets and their distance measure.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.Match> Matches {
      get { return matches_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KeypointMatches);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KeypointMatches other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ReferenceKeypoints, other.ReferenceKeypoints)) return false;
      if (!object.Equals(LiveKeypoints, other.LiveKeypoints)) return false;
      if(!matches_.Equals(other.matches_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (referenceKeypoints_ != null) hash ^= ReferenceKeypoints.GetHashCode();
      if (liveKeypoints_ != null) hash ^= LiveKeypoints.GetHashCode();
      hash ^= matches_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (referenceKeypoints_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReferenceKeypoints);
      }
      if (liveKeypoints_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LiveKeypoints);
      }
      matches_.WriteTo(output, _repeated_matches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (referenceKeypoints_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceKeypoints);
      }
      if (liveKeypoints_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LiveKeypoints);
      }
      size += matches_.CalculateSize(_repeated_matches_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KeypointMatches other) {
      if (other == null) {
        return;
      }
      if (other.referenceKeypoints_ != null) {
        if (referenceKeypoints_ == null) {
          ReferenceKeypoints = new global::Bosdyn.Api.KeypointSet();
        }
        ReferenceKeypoints.MergeFrom(other.ReferenceKeypoints);
      }
      if (other.liveKeypoints_ != null) {
        if (liveKeypoints_ == null) {
          LiveKeypoints = new global::Bosdyn.Api.KeypointSet();
        }
        LiveKeypoints.MergeFrom(other.LiveKeypoints);
      }
      matches_.Add(other.matches_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (referenceKeypoints_ == null) {
              ReferenceKeypoints = new global::Bosdyn.Api.KeypointSet();
            }
            input.ReadMessage(ReferenceKeypoints);
            break;
          }
          case 26: {
            if (liveKeypoints_ == null) {
              LiveKeypoints = new global::Bosdyn.Api.KeypointSet();
            }
            input.ReadMessage(LiveKeypoints);
            break;
          }
          case 34: {
            matches_.AddEntriesFrom(input, _repeated_matches_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
