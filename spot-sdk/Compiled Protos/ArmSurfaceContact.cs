// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/arm_surface_contact.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/arm_surface_contact.proto</summary>
  public static partial class ArmSurfaceContactReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/arm_surface_contact.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ArmSurfaceContactReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiBQcm90b3MvYXJtX3N1cmZhY2VfY29udGFjdC5wcm90bxIKYm9zZHluLmFw",
            "aRoVUHJvdG9zL2dlb21ldHJ5LnByb3RvGhxQcm90b3MvZ3JpcHBlcl9jb21t",
            "YW5kLnByb3RvGhdQcm90b3MvdHJhamVjdG9yeS5wcm90bxoYUHJvdG9zL2Fy",
            "bV9jb21tYW5kLnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJv",
            "dG8iuwwKEUFybVN1cmZhY2VDb250YWN0GpkMCgdSZXF1ZXN0EhcKD3Jvb3Rf",
            "ZnJhbWVfbmFtZRgZIAEoCRItChB3cmlzdF90Zm9ybV90b29sGAYgASgLMhMu",
            "Ym9zZHluLmFwaS5TRTNQb3NlEiwKD3Jvb3RfdGZvcm1fdGFzaxgaIAEoCzIT",
            "LmJvc2R5bi5hcGkuU0UzUG9zZRI6Chdwb3NlX3RyYWplY3RvcnlfaW5fdGFz",
            "axgCIAEoCzIZLmJvc2R5bi5hcGkuU0UzVHJhamVjdG9yeRI6ChRtYXhpbXVt",
            "X2FjY2VsZXJhdGlvbhgDIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5Eb3VibGVW",
            "YWx1ZRI5ChNtYXhfbGluZWFyX3ZlbG9jaXR5GAQgASgLMhwuZ29vZ2xlLnBy",
            "b3RvYnVmLkRvdWJsZVZhbHVlEjoKFG1heF9hbmd1bGFyX3ZlbG9jaXR5GAUg",
            "ASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlEjwKFm1heF9wb3Nf",
            "dHJhY2tpbmdfZXJyb3IYEiABKAsyHC5nb29nbGUucHJvdG9idWYuRG91Ymxl",
            "VmFsdWUSPAoWbWF4X3JvdF90cmFja2luZ19lcnJvchgTIAEoCzIcLmdvb2ds",
            "ZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZRI3Ci1mb3JjZV9yZW1haW5fbmVhcl9j",
            "dXJyZW50X2pvaW50X2NvbmZpZ3VyYXRpb24YDyABKAhIABJFCh1wcmVmZXJy",
            "ZWRfam9pbnRfY29uZmlndXJhdGlvbhgQIAEoCzIcLmJvc2R5bi5hcGkuQXJt",
            "Sm9pbnRQb3NpdGlvbkgAEj4KBnhfYXhpcxgIIAEoDjIuLmJvc2R5bi5hcGku",
            "QXJtU3VyZmFjZUNvbnRhY3QuUmVxdWVzdC5BeGlzTW9kZRI+CgZ5X2F4aXMY",
            "CSABKA4yLi5ib3NkeW4uYXBpLkFybVN1cmZhY2VDb250YWN0LlJlcXVlc3Qu",
            "QXhpc01vZGUSPgoGel9heGlzGAogASgOMi4uYm9zZHluLmFwaS5Bcm1TdXJm",
            "YWNlQ29udGFjdC5SZXF1ZXN0LkF4aXNNb2RlEjAKFnByZXNzX2ZvcmNlX3Bl",
            "cmNlbnRhZ2UYDCABKAsyEC5ib3NkeW4uYXBpLlZlYzMSTgoNeHlfYWRtaXR0",
            "YW5jZRgVIAEoDjI3LmJvc2R5bi5hcGkuQXJtU3VyZmFjZUNvbnRhY3QuUmVx",
            "dWVzdC5BZG1pdHRhbmNlU2V0dGluZxJNCgx6X2FkbWl0dGFuY2UYFiABKA4y",
            "Ny5ib3NkeW4uYXBpLkFybVN1cmZhY2VDb250YWN0LlJlcXVlc3QuQWRtaXR0",
            "YW5jZVNldHRpbmcSXgodeHlfdG9fel9jcm9zc190ZXJtX2FkbWl0dGFuY2UY",
            "ESABKA4yNy5ib3NkeW4uYXBpLkFybVN1cmZhY2VDb250YWN0LlJlcXVlc3Qu",
            "QWRtaXR0YW5jZVNldHRpbmcSLgoUYmlhc19mb3JjZV9ld3J0X2JvZHkYFCAB",
            "KAsyEC5ib3NkeW4uYXBpLlZlYzMSPwoPZ3JpcHBlcl9jb21tYW5kGBcgASgL",
            "MiYuYm9zZHluLmFwaS5DbGF3R3JpcHBlckNvbW1hbmQuUmVxdWVzdBIfChdp",
            "c19yb2JvdF9mb2xsb3dpbmdfaGFuZBgYIAEoCCI3CghBeGlzTW9kZRIWChJB",
            "WElTX01PREVfUE9TSVRJT04QABITCg9BWElTX01PREVfRk9SQ0UQASLNAQoR",
            "QWRtaXR0YW5jZVNldHRpbmcSHgoaQURNSVRUQU5DRV9TRVRUSU5HX1VOS05P",
            "V04QABIaChZBRE1JVFRBTkNFX1NFVFRJTkdfT0ZGEAESHQoZQURNSVRUQU5D",
            "RV9TRVRUSU5HX05PUk1BTBACEhwKGEFETUlUVEFOQ0VfU0VUVElOR19MT09T",
            "RRADEhwKGEFETUlUVEFOQ0VfU0VUVElOR19TVElGRhAEEiEKHUFETUlUVEFO",
            "Q0VfU0VUVElOR19WRVJZX1NUSUZGEAVCFQoTam9pbnRfY29uZmlndXJhdGlv",
            "bkoECAEQAkoECAcQCBoKCghGZWVkYmFja0IYQhZBcm1TdXJmYWNlQ29udGFj",
            "dFByb3RvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.GeometryReflection.Descriptor, global::Bosdyn.Api.GripperCommandReflection.Descriptor, global::Bosdyn.Api.TrajectoryReflection.Descriptor, global::Bosdyn.Api.ArmCommandReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmSurfaceContact), global::Bosdyn.Api.ArmSurfaceContact.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmSurfaceContact.Types.Request), global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Parser, new[]{ "RootFrameName", "WristTformTool", "RootTformTask", "PoseTrajectoryInTask", "MaximumAcceleration", "MaxLinearVelocity", "MaxAngularVelocity", "MaxPosTrackingError", "MaxRotTrackingError", "ForceRemainNearCurrentJointConfiguration", "PreferredJointConfiguration", "XAxis", "YAxis", "ZAxis", "PressForcePercentage", "XyAdmittance", "ZAdmittance", "XyToZCrossTermAdmittance", "BiasForceEwrtBody", "GripperCommand", "IsRobotFollowingHand" }, new[]{ "JointConfiguration" }, new[]{ typeof(global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode), typeof(global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmSurfaceContact.Types.Feedback), global::Bosdyn.Api.ArmSurfaceContact.Types.Feedback.Parser, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// ArmSurfaceContact lets you accurately move the robot's arm in the world while having some ability
  /// to perform force control.  This mode is useful for drawing, wiping, and other similar behaviors.
  ///
  /// The message is similar to the ArmCartesianCommand message, which you can look at for additional
  /// details.
  /// </summary>
  public sealed partial class ArmSurfaceContact : pb::IMessage<ArmSurfaceContact> {
    private static readonly pb::MessageParser<ArmSurfaceContact> _parser = new pb::MessageParser<ArmSurfaceContact>(() => new ArmSurfaceContact());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ArmSurfaceContact> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.ArmSurfaceContactReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmSurfaceContact() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmSurfaceContact(ArmSurfaceContact other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmSurfaceContact Clone() {
      return new ArmSurfaceContact(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ArmSurfaceContact);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ArmSurfaceContact other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ArmSurfaceContact other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ArmSurfaceContact message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ArmSurfaceContact.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          rootFrameName_ = other.rootFrameName_;
          wristTformTool_ = other.wristTformTool_ != null ? other.wristTformTool_.Clone() : null;
          rootTformTask_ = other.rootTformTask_ != null ? other.rootTformTask_.Clone() : null;
          poseTrajectoryInTask_ = other.poseTrajectoryInTask_ != null ? other.poseTrajectoryInTask_.Clone() : null;
          MaximumAcceleration = other.MaximumAcceleration;
          MaxLinearVelocity = other.MaxLinearVelocity;
          MaxAngularVelocity = other.MaxAngularVelocity;
          MaxPosTrackingError = other.MaxPosTrackingError;
          MaxRotTrackingError = other.MaxRotTrackingError;
          xAxis_ = other.xAxis_;
          yAxis_ = other.yAxis_;
          zAxis_ = other.zAxis_;
          pressForcePercentage_ = other.pressForcePercentage_ != null ? other.pressForcePercentage_.Clone() : null;
          xyAdmittance_ = other.xyAdmittance_;
          zAdmittance_ = other.zAdmittance_;
          xyToZCrossTermAdmittance_ = other.xyToZCrossTermAdmittance_;
          biasForceEwrtBody_ = other.biasForceEwrtBody_ != null ? other.biasForceEwrtBody_.Clone() : null;
          gripperCommand_ = other.gripperCommand_ != null ? other.gripperCommand_.Clone() : null;
          isRobotFollowingHand_ = other.isRobotFollowingHand_;
          switch (other.JointConfigurationCase) {
            case JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration:
              ForceRemainNearCurrentJointConfiguration = other.ForceRemainNearCurrentJointConfiguration;
              break;
            case JointConfigurationOneofCase.PreferredJointConfiguration:
              PreferredJointConfiguration = other.PreferredJointConfiguration.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "root_frame_name" field.</summary>
        public const int RootFrameNameFieldNumber = 25;
        private string rootFrameName_ = "";
        /// <summary>
        /// The root frame is used to set the optional task frame that all trajectories are 
        /// specified with respect to.  If the optional task frame is left un-specified it defaults
        /// to the identity transform and the root frame becomes the task frame.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string RootFrameName {
          get { return rootFrameName_; }
          set {
            rootFrameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "wrist_tform_tool" field.</summary>
        public const int WristTformToolFieldNumber = 6;
        private global::Bosdyn.Api.SE3Pose wristTformTool_;
        /// <summary>
        /// The tool pose relative to the parent link (wrist).
        /// Defaults to
        ///    [0.19557 0 0]
        ///    [1 0 0 0]
        /// a frame with it's origin slightly in front of the gripper's palm plate aligned with wrists orientation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE3Pose WristTformTool {
          get { return wristTformTool_; }
          set {
            wristTformTool_ = value;
          }
        }

        /// <summary>Field number for the "root_tform_task" field.</summary>
        public const int RootTformTaskFieldNumber = 26;
        private global::Bosdyn.Api.SE3Pose rootTformTask_;
        /// <summary>
        /// The fields below are specified in this optional task frame.  If unset int defaults
        /// to the identity transform and all quantities are therefore expressed in the root_frame_name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE3Pose RootTformTask {
          get { return rootTformTask_; }
          set {
            rootTformTask_ = value;
          }
        }

        /// <summary>Field number for the "pose_trajectory_in_task" field.</summary>
        public const int PoseTrajectoryInTaskFieldNumber = 2;
        private global::Bosdyn.Api.SE3Trajectory poseTrajectoryInTask_;
        /// <summary>
        /// A 3D pose trajectory for the tool expressed in the task frame, e.g. task_T_tool.
        /// This pose trajectory is optional if requesting a pure wrench at the end-effector, 
        /// otherwise required for position or mixed force/position end-effector requests.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE3Trajectory PoseTrajectoryInTask {
          get { return poseTrajectoryInTask_; }
          set {
            poseTrajectoryInTask_ = value;
          }
        }

        /// <summary>Field number for the "maximum_acceleration" field.</summary>
        public const int MaximumAccelerationFieldNumber = 3;
        private static readonly pb::FieldCodec<double?> _single_maximumAcceleration_codec = pb::FieldCodec.ForStructWrapper<double>(26);
        private double? maximumAcceleration_;
        /// <summary>
        /// Optional Maximum acceleration magnitude of the end-effector.
        /// Valid ranges (0, 20]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? MaximumAcceleration {
          get { return maximumAcceleration_; }
          set {
            maximumAcceleration_ = value;
          }
        }


        /// <summary>Field number for the "max_linear_velocity" field.</summary>
        public const int MaxLinearVelocityFieldNumber = 4;
        private static readonly pb::FieldCodec<double?> _single_maxLinearVelocity_codec = pb::FieldCodec.ForStructWrapper<double>(34);
        private double? maxLinearVelocity_;
        /// <summary>
        /// Optional Maximum linear velocity magnitude of the end-effector. (m/s)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? MaxLinearVelocity {
          get { return maxLinearVelocity_; }
          set {
            maxLinearVelocity_ = value;
          }
        }


        /// <summary>Field number for the "max_angular_velocity" field.</summary>
        public const int MaxAngularVelocityFieldNumber = 5;
        private static readonly pb::FieldCodec<double?> _single_maxAngularVelocity_codec = pb::FieldCodec.ForStructWrapper<double>(42);
        private double? maxAngularVelocity_;
        /// <summary>
        /// Optional Maximum angular velocity magnitude of the end-effector. (rad/s)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? MaxAngularVelocity {
          get { return maxAngularVelocity_; }
          set {
            maxAngularVelocity_ = value;
          }
        }


        /// <summary>Field number for the "max_pos_tracking_error" field.</summary>
        public const int MaxPosTrackingErrorFieldNumber = 18;
        private static readonly pb::FieldCodec<double?> _single_maxPosTrackingError_codec = pb::FieldCodec.ForStructWrapper<double>(146);
        private double? maxPosTrackingError_;
        /// <summary>
        /// Maximum allowable tracking error of the tool frame from the desired trajectory
        /// before the arm will stop moving and cancel the rest of the trajectory. When this limit is exceeded, the
        /// hand will stay at the pose it was at when it exceeded the tracking error, and any other part of the
        /// trajectory specified in the rest of this message will be ignored.
        /// max position tracking error in meters
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? MaxPosTrackingError {
          get { return maxPosTrackingError_; }
          set {
            maxPosTrackingError_ = value;
          }
        }


        /// <summary>Field number for the "max_rot_tracking_error" field.</summary>
        public const int MaxRotTrackingErrorFieldNumber = 19;
        private static readonly pb::FieldCodec<double?> _single_maxRotTrackingError_codec = pb::FieldCodec.ForStructWrapper<double>(154);
        private double? maxRotTrackingError_;
        /// <summary>
        /// max orientation tracking error in radians
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? MaxRotTrackingError {
          get { return maxRotTrackingError_; }
          set {
            maxRotTrackingError_ = value;
          }
        }


        /// <summary>Field number for the "force_remain_near_current_joint_configuration" field.</summary>
        public const int ForceRemainNearCurrentJointConfigurationFieldNumber = 15;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ForceRemainNearCurrentJointConfiguration {
          get { return jointConfigurationCase_ == JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration ? (bool) jointConfiguration_ : false; }
          set {
            jointConfiguration_ = value;
            jointConfigurationCase_ = JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration;
          }
        }

        /// <summary>Field number for the "preferred_joint_configuration" field.</summary>
        public const int PreferredJointConfigurationFieldNumber = 16;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmJointPosition PreferredJointConfiguration {
          get { return jointConfigurationCase_ == JointConfigurationOneofCase.PreferredJointConfiguration ? (global::Bosdyn.Api.ArmJointPosition) jointConfiguration_ : null; }
          set {
            jointConfiguration_ = value;
            jointConfigurationCase_ = value == null ? JointConfigurationOneofCase.None : JointConfigurationOneofCase.PreferredJointConfiguration;
          }
        }

        /// <summary>Field number for the "x_axis" field.</summary>
        public const int XAxisFieldNumber = 8;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode xAxis_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode XAxis {
          get { return xAxis_; }
          set {
            xAxis_ = value;
          }
        }

        /// <summary>Field number for the "y_axis" field.</summary>
        public const int YAxisFieldNumber = 9;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode yAxis_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode YAxis {
          get { return yAxis_; }
          set {
            yAxis_ = value;
          }
        }

        /// <summary>Field number for the "z_axis" field.</summary>
        public const int ZAxisFieldNumber = 10;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode zAxis_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode ZAxis {
          get { return zAxis_; }
          set {
            zAxis_ = value;
          }
        }

        /// <summary>Field number for the "press_force_percentage" field.</summary>
        public const int PressForcePercentageFieldNumber = 12;
        private global::Bosdyn.Api.Vec3 pressForcePercentage_;
        /// <summary>
        /// Amount of force to use on each axis, from 0 (no force) to 1.0 (maximum force), can also
        /// be negative.  Full range: [-1.0, 1.0]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Vec3 PressForcePercentage {
          get { return pressForcePercentage_; }
          set {
            pressForcePercentage_ = value;
          }
        }

        /// <summary>Field number for the "xy_admittance" field.</summary>
        public const int XyAdmittanceFieldNumber = 21;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting xyAdmittance_ = 0;
        /// <summary>
        /// Admittance settings for each axis in the admittance frame.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting XyAdmittance {
          get { return xyAdmittance_; }
          set {
            xyAdmittance_ = value;
          }
        }

        /// <summary>Field number for the "z_admittance" field.</summary>
        public const int ZAdmittanceFieldNumber = 22;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting zAdmittance_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting ZAdmittance {
          get { return zAdmittance_; }
          set {
            zAdmittance_ = value;
          }
        }

        /// <summary>Field number for the "xy_to_z_cross_term_admittance" field.</summary>
        public const int XyToZCrossTermAdmittanceFieldNumber = 17;
        private global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting xyToZCrossTermAdmittance_ = 0;
        /// <summary>
        /// Cross term, making force in the XY axis cause movement in the z-axis.
        /// By default is OFF
        /// Setting this value will make the arm move in the negative Z-axis whenever it feels force in
        /// the XY axis.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting XyToZCrossTermAdmittance {
          get { return xyToZCrossTermAdmittance_; }
          set {
            xyToZCrossTermAdmittance_ = value;
          }
        }

        /// <summary>Field number for the "bias_force_ewrt_body" field.</summary>
        public const int BiasForceEwrtBodyFieldNumber = 20;
        private global::Bosdyn.Api.Vec3 biasForceEwrtBody_;
        /// <summary>
        /// Specifies a force that the body should expect to feel.  This allows the robot to "lean into"
        /// an external force.  Be careful using this field, because if you lie to the robot, it can
        /// fall over.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Vec3 BiasForceEwrtBody {
          get { return biasForceEwrtBody_; }
          set {
            biasForceEwrtBody_ = value;
          }
        }

        /// <summary>Field number for the "gripper_command" field.</summary>
        public const int GripperCommandFieldNumber = 23;
        private global::Bosdyn.Api.ClawGripperCommand.Types.Request gripperCommand_;
        /// <summary>
        /// Gripper control
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ClawGripperCommand.Types.Request GripperCommand {
          get { return gripperCommand_; }
          set {
            gripperCommand_ = value;
          }
        }

        /// <summary>Field number for the "is_robot_following_hand" field.</summary>
        public const int IsRobotFollowingHandFieldNumber = 24;
        private bool isRobotFollowingHand_;
        /// <summary>
        /// Set to true to have robot is walk around to follow the hand.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsRobotFollowingHand {
          get { return isRobotFollowingHand_; }
          set {
            isRobotFollowingHand_ = value;
          }
        }

        private object jointConfiguration_;
        /// <summary>Enum of possible cases for the "joint_configuration" oneof.</summary>
        public enum JointConfigurationOneofCase {
          None = 0,
          ForceRemainNearCurrentJointConfiguration = 15,
          PreferredJointConfiguration = 16,
        }
        private JointConfigurationOneofCase jointConfigurationCase_ = JointConfigurationOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public JointConfigurationOneofCase JointConfigurationCase {
          get { return jointConfigurationCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearJointConfiguration() {
          jointConfigurationCase_ = JointConfigurationOneofCase.None;
          jointConfiguration_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (RootFrameName != other.RootFrameName) return false;
          if (!object.Equals(WristTformTool, other.WristTformTool)) return false;
          if (!object.Equals(RootTformTask, other.RootTformTask)) return false;
          if (!object.Equals(PoseTrajectoryInTask, other.PoseTrajectoryInTask)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(MaximumAcceleration, other.MaximumAcceleration)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(MaxLinearVelocity, other.MaxLinearVelocity)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(MaxAngularVelocity, other.MaxAngularVelocity)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(MaxPosTrackingError, other.MaxPosTrackingError)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(MaxRotTrackingError, other.MaxRotTrackingError)) return false;
          if (ForceRemainNearCurrentJointConfiguration != other.ForceRemainNearCurrentJointConfiguration) return false;
          if (!object.Equals(PreferredJointConfiguration, other.PreferredJointConfiguration)) return false;
          if (XAxis != other.XAxis) return false;
          if (YAxis != other.YAxis) return false;
          if (ZAxis != other.ZAxis) return false;
          if (!object.Equals(PressForcePercentage, other.PressForcePercentage)) return false;
          if (XyAdmittance != other.XyAdmittance) return false;
          if (ZAdmittance != other.ZAdmittance) return false;
          if (XyToZCrossTermAdmittance != other.XyToZCrossTermAdmittance) return false;
          if (!object.Equals(BiasForceEwrtBody, other.BiasForceEwrtBody)) return false;
          if (!object.Equals(GripperCommand, other.GripperCommand)) return false;
          if (IsRobotFollowingHand != other.IsRobotFollowingHand) return false;
          if (JointConfigurationCase != other.JointConfigurationCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (RootFrameName.Length != 0) hash ^= RootFrameName.GetHashCode();
          if (wristTformTool_ != null) hash ^= WristTformTool.GetHashCode();
          if (rootTformTask_ != null) hash ^= RootTformTask.GetHashCode();
          if (poseTrajectoryInTask_ != null) hash ^= PoseTrajectoryInTask.GetHashCode();
          if (maximumAcceleration_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(MaximumAcceleration);
          if (maxLinearVelocity_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(MaxLinearVelocity);
          if (maxAngularVelocity_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(MaxAngularVelocity);
          if (maxPosTrackingError_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(MaxPosTrackingError);
          if (maxRotTrackingError_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(MaxRotTrackingError);
          if (jointConfigurationCase_ == JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration) hash ^= ForceRemainNearCurrentJointConfiguration.GetHashCode();
          if (jointConfigurationCase_ == JointConfigurationOneofCase.PreferredJointConfiguration) hash ^= PreferredJointConfiguration.GetHashCode();
          if (XAxis != 0) hash ^= XAxis.GetHashCode();
          if (YAxis != 0) hash ^= YAxis.GetHashCode();
          if (ZAxis != 0) hash ^= ZAxis.GetHashCode();
          if (pressForcePercentage_ != null) hash ^= PressForcePercentage.GetHashCode();
          if (XyAdmittance != 0) hash ^= XyAdmittance.GetHashCode();
          if (ZAdmittance != 0) hash ^= ZAdmittance.GetHashCode();
          if (XyToZCrossTermAdmittance != 0) hash ^= XyToZCrossTermAdmittance.GetHashCode();
          if (biasForceEwrtBody_ != null) hash ^= BiasForceEwrtBody.GetHashCode();
          if (gripperCommand_ != null) hash ^= GripperCommand.GetHashCode();
          if (IsRobotFollowingHand != false) hash ^= IsRobotFollowingHand.GetHashCode();
          hash ^= (int) jointConfigurationCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (poseTrajectoryInTask_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PoseTrajectoryInTask);
          }
          if (maximumAcceleration_ != null) {
            _single_maximumAcceleration_codec.WriteTagAndValue(output, MaximumAcceleration);
          }
          if (maxLinearVelocity_ != null) {
            _single_maxLinearVelocity_codec.WriteTagAndValue(output, MaxLinearVelocity);
          }
          if (maxAngularVelocity_ != null) {
            _single_maxAngularVelocity_codec.WriteTagAndValue(output, MaxAngularVelocity);
          }
          if (wristTformTool_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(WristTformTool);
          }
          if (XAxis != 0) {
            output.WriteRawTag(64);
            output.WriteEnum((int) XAxis);
          }
          if (YAxis != 0) {
            output.WriteRawTag(72);
            output.WriteEnum((int) YAxis);
          }
          if (ZAxis != 0) {
            output.WriteRawTag(80);
            output.WriteEnum((int) ZAxis);
          }
          if (pressForcePercentage_ != null) {
            output.WriteRawTag(98);
            output.WriteMessage(PressForcePercentage);
          }
          if (jointConfigurationCase_ == JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration) {
            output.WriteRawTag(120);
            output.WriteBool(ForceRemainNearCurrentJointConfiguration);
          }
          if (jointConfigurationCase_ == JointConfigurationOneofCase.PreferredJointConfiguration) {
            output.WriteRawTag(130, 1);
            output.WriteMessage(PreferredJointConfiguration);
          }
          if (XyToZCrossTermAdmittance != 0) {
            output.WriteRawTag(136, 1);
            output.WriteEnum((int) XyToZCrossTermAdmittance);
          }
          if (maxPosTrackingError_ != null) {
            _single_maxPosTrackingError_codec.WriteTagAndValue(output, MaxPosTrackingError);
          }
          if (maxRotTrackingError_ != null) {
            _single_maxRotTrackingError_codec.WriteTagAndValue(output, MaxRotTrackingError);
          }
          if (biasForceEwrtBody_ != null) {
            output.WriteRawTag(162, 1);
            output.WriteMessage(BiasForceEwrtBody);
          }
          if (XyAdmittance != 0) {
            output.WriteRawTag(168, 1);
            output.WriteEnum((int) XyAdmittance);
          }
          if (ZAdmittance != 0) {
            output.WriteRawTag(176, 1);
            output.WriteEnum((int) ZAdmittance);
          }
          if (gripperCommand_ != null) {
            output.WriteRawTag(186, 1);
            output.WriteMessage(GripperCommand);
          }
          if (IsRobotFollowingHand != false) {
            output.WriteRawTag(192, 1);
            output.WriteBool(IsRobotFollowingHand);
          }
          if (RootFrameName.Length != 0) {
            output.WriteRawTag(202, 1);
            output.WriteString(RootFrameName);
          }
          if (rootTformTask_ != null) {
            output.WriteRawTag(210, 1);
            output.WriteMessage(RootTformTask);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (RootFrameName.Length != 0) {
            size += 2 + pb::CodedOutputStream.ComputeStringSize(RootFrameName);
          }
          if (wristTformTool_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(WristTformTool);
          }
          if (rootTformTask_ != null) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(RootTformTask);
          }
          if (poseTrajectoryInTask_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PoseTrajectoryInTask);
          }
          if (maximumAcceleration_ != null) {
            size += _single_maximumAcceleration_codec.CalculateSizeWithTag(MaximumAcceleration);
          }
          if (maxLinearVelocity_ != null) {
            size += _single_maxLinearVelocity_codec.CalculateSizeWithTag(MaxLinearVelocity);
          }
          if (maxAngularVelocity_ != null) {
            size += _single_maxAngularVelocity_codec.CalculateSizeWithTag(MaxAngularVelocity);
          }
          if (maxPosTrackingError_ != null) {
            size += _single_maxPosTrackingError_codec.CalculateSizeWithTag(MaxPosTrackingError);
          }
          if (maxRotTrackingError_ != null) {
            size += _single_maxRotTrackingError_codec.CalculateSizeWithTag(MaxRotTrackingError);
          }
          if (jointConfigurationCase_ == JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration) {
            size += 1 + 1;
          }
          if (jointConfigurationCase_ == JointConfigurationOneofCase.PreferredJointConfiguration) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(PreferredJointConfiguration);
          }
          if (XAxis != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) XAxis);
          }
          if (YAxis != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) YAxis);
          }
          if (ZAxis != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ZAxis);
          }
          if (pressForcePercentage_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PressForcePercentage);
          }
          if (XyAdmittance != 0) {
            size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) XyAdmittance);
          }
          if (ZAdmittance != 0) {
            size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ZAdmittance);
          }
          if (XyToZCrossTermAdmittance != 0) {
            size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) XyToZCrossTermAdmittance);
          }
          if (biasForceEwrtBody_ != null) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(BiasForceEwrtBody);
          }
          if (gripperCommand_ != null) {
            size += 2 + pb::CodedOutputStream.ComputeMessageSize(GripperCommand);
          }
          if (IsRobotFollowingHand != false) {
            size += 2 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.RootFrameName.Length != 0) {
            RootFrameName = other.RootFrameName;
          }
          if (other.wristTformTool_ != null) {
            if (wristTformTool_ == null) {
              WristTformTool = new global::Bosdyn.Api.SE3Pose();
            }
            WristTformTool.MergeFrom(other.WristTformTool);
          }
          if (other.rootTformTask_ != null) {
            if (rootTformTask_ == null) {
              RootTformTask = new global::Bosdyn.Api.SE3Pose();
            }
            RootTformTask.MergeFrom(other.RootTformTask);
          }
          if (other.poseTrajectoryInTask_ != null) {
            if (poseTrajectoryInTask_ == null) {
              PoseTrajectoryInTask = new global::Bosdyn.Api.SE3Trajectory();
            }
            PoseTrajectoryInTask.MergeFrom(other.PoseTrajectoryInTask);
          }
          if (other.maximumAcceleration_ != null) {
            if (maximumAcceleration_ == null || other.MaximumAcceleration != 0D) {
              MaximumAcceleration = other.MaximumAcceleration;
            }
          }
          if (other.maxLinearVelocity_ != null) {
            if (maxLinearVelocity_ == null || other.MaxLinearVelocity != 0D) {
              MaxLinearVelocity = other.MaxLinearVelocity;
            }
          }
          if (other.maxAngularVelocity_ != null) {
            if (maxAngularVelocity_ == null || other.MaxAngularVelocity != 0D) {
              MaxAngularVelocity = other.MaxAngularVelocity;
            }
          }
          if (other.maxPosTrackingError_ != null) {
            if (maxPosTrackingError_ == null || other.MaxPosTrackingError != 0D) {
              MaxPosTrackingError = other.MaxPosTrackingError;
            }
          }
          if (other.maxRotTrackingError_ != null) {
            if (maxRotTrackingError_ == null || other.MaxRotTrackingError != 0D) {
              MaxRotTrackingError = other.MaxRotTrackingError;
            }
          }
          if (other.XAxis != 0) {
            XAxis = other.XAxis;
          }
          if (other.YAxis != 0) {
            YAxis = other.YAxis;
          }
          if (other.ZAxis != 0) {
            ZAxis = other.ZAxis;
          }
          if (other.pressForcePercentage_ != null) {
            if (pressForcePercentage_ == null) {
              PressForcePercentage = new global::Bosdyn.Api.Vec3();
            }
            PressForcePercentage.MergeFrom(other.PressForcePercentage);
          }
          if (other.XyAdmittance != 0) {
            XyAdmittance = other.XyAdmittance;
          }
          if (other.ZAdmittance != 0) {
            ZAdmittance = other.ZAdmittance;
          }
          if (other.XyToZCrossTermAdmittance != 0) {
            XyToZCrossTermAdmittance = other.XyToZCrossTermAdmittance;
          }
          if (other.biasForceEwrtBody_ != null) {
            if (biasForceEwrtBody_ == null) {
              BiasForceEwrtBody = new global::Bosdyn.Api.Vec3();
            }
            BiasForceEwrtBody.MergeFrom(other.BiasForceEwrtBody);
          }
          if (other.gripperCommand_ != null) {
            if (gripperCommand_ == null) {
              GripperCommand = new global::Bosdyn.Api.ClawGripperCommand.Types.Request();
            }
            GripperCommand.MergeFrom(other.GripperCommand);
          }
          if (other.IsRobotFollowingHand != false) {
            IsRobotFollowingHand = other.IsRobotFollowingHand;
          }
          switch (other.JointConfigurationCase) {
            case JointConfigurationOneofCase.ForceRemainNearCurrentJointConfiguration:
              ForceRemainNearCurrentJointConfiguration = other.ForceRemainNearCurrentJointConfiguration;
              break;
            case JointConfigurationOneofCase.PreferredJointConfiguration:
              if (PreferredJointConfiguration == null) {
                PreferredJointConfiguration = new global::Bosdyn.Api.ArmJointPosition();
              }
              PreferredJointConfiguration.MergeFrom(other.PreferredJointConfiguration);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 18: {
                if (poseTrajectoryInTask_ == null) {
                  PoseTrajectoryInTask = new global::Bosdyn.Api.SE3Trajectory();
                }
                input.ReadMessage(PoseTrajectoryInTask);
                break;
              }
              case 26: {
                double? value = _single_maximumAcceleration_codec.Read(input);
                if (maximumAcceleration_ == null || value != 0D) {
                  MaximumAcceleration = value;
                }
                break;
              }
              case 34: {
                double? value = _single_maxLinearVelocity_codec.Read(input);
                if (maxLinearVelocity_ == null || value != 0D) {
                  MaxLinearVelocity = value;
                }
                break;
              }
              case 42: {
                double? value = _single_maxAngularVelocity_codec.Read(input);
                if (maxAngularVelocity_ == null || value != 0D) {
                  MaxAngularVelocity = value;
                }
                break;
              }
              case 50: {
                if (wristTformTool_ == null) {
                  WristTformTool = new global::Bosdyn.Api.SE3Pose();
                }
                input.ReadMessage(WristTformTool);
                break;
              }
              case 64: {
                XAxis = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode) input.ReadEnum();
                break;
              }
              case 72: {
                YAxis = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode) input.ReadEnum();
                break;
              }
              case 80: {
                ZAxis = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AxisMode) input.ReadEnum();
                break;
              }
              case 98: {
                if (pressForcePercentage_ == null) {
                  PressForcePercentage = new global::Bosdyn.Api.Vec3();
                }
                input.ReadMessage(PressForcePercentage);
                break;
              }
              case 120: {
                ForceRemainNearCurrentJointConfiguration = input.ReadBool();
                break;
              }
              case 130: {
                global::Bosdyn.Api.ArmJointPosition subBuilder = new global::Bosdyn.Api.ArmJointPosition();
                if (jointConfigurationCase_ == JointConfigurationOneofCase.PreferredJointConfiguration) {
                  subBuilder.MergeFrom(PreferredJointConfiguration);
                }
                input.ReadMessage(subBuilder);
                PreferredJointConfiguration = subBuilder;
                break;
              }
              case 136: {
                XyToZCrossTermAdmittance = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting) input.ReadEnum();
                break;
              }
              case 146: {
                double? value = _single_maxPosTrackingError_codec.Read(input);
                if (maxPosTrackingError_ == null || value != 0D) {
                  MaxPosTrackingError = value;
                }
                break;
              }
              case 154: {
                double? value = _single_maxRotTrackingError_codec.Read(input);
                if (maxRotTrackingError_ == null || value != 0D) {
                  MaxRotTrackingError = value;
                }
                break;
              }
              case 162: {
                if (biasForceEwrtBody_ == null) {
                  BiasForceEwrtBody = new global::Bosdyn.Api.Vec3();
                }
                input.ReadMessage(BiasForceEwrtBody);
                break;
              }
              case 168: {
                XyAdmittance = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting) input.ReadEnum();
                break;
              }
              case 176: {
                ZAdmittance = (global::Bosdyn.Api.ArmSurfaceContact.Types.Request.Types.AdmittanceSetting) input.ReadEnum();
                break;
              }
              case 186: {
                if (gripperCommand_ == null) {
                  GripperCommand = new global::Bosdyn.Api.ClawGripperCommand.Types.Request();
                }
                input.ReadMessage(GripperCommand);
                break;
              }
              case 192: {
                IsRobotFollowingHand = input.ReadBool();
                break;
              }
              case 202: {
                RootFrameName = input.ReadString();
                break;
              }
              case 210: {
                if (rootTformTask_ == null) {
                  RootTformTask = new global::Bosdyn.Api.SE3Pose();
                }
                input.ReadMessage(RootTformTask);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Request message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// If an axis is set to position mode (default), read desired from SE3Trajectory command.
          /// If mode is set to force, use the "press_force_percentage" field to determine force.
          /// </summary>
          public enum AxisMode {
            [pbr::OriginalName("AXIS_MODE_POSITION")] Position = 0,
            [pbr::OriginalName("AXIS_MODE_FORCE")] Force = 1,
          }

          /// <summary>
          /// Parameters for controlling admittance.  By default, the robot will
          /// stop moving the arm when it encounters resistance.  You can control that reaction to
          /// make the robot stiffer or less stiff by changing the parameters.
          /// </summary>
          public enum AdmittanceSetting {
            [pbr::OriginalName("ADMITTANCE_SETTING_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// No admittance.
            /// </summary>
            [pbr::OriginalName("ADMITTANCE_SETTING_OFF")] Off = 1,
            /// <summary>
            /// Normal reaction to touching things in the world
            /// </summary>
            [pbr::OriginalName("ADMITTANCE_SETTING_NORMAL")] Normal = 2,
            /// <summary>
            /// Robot will not push very hard against objects
            /// </summary>
            [pbr::OriginalName("ADMITTANCE_SETTING_LOOSE")] Loose = 3,
            /// <summary>
            /// Robot will push hard against the world
            /// </summary>
            [pbr::OriginalName("ADMITTANCE_SETTING_STIFF")] Stiff = 4,
            /// <summary>
            /// Robot will push very hard against the world
            /// </summary>
            [pbr::OriginalName("ADMITTANCE_SETTING_VERY_STIFF")] VeryStiff = 5,
          }

        }
        #endregion

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ArmSurfaceContact.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
