// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/trajectory.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/trajectory.proto</summary>
  public static partial class TrajectoryReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/trajectory.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TrajectoryReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdQcm90b3MvdHJhamVjdG9yeS5wcm90bxIKYm9zZHluLmFwaRoVUHJvdG9z",
            "L2dlb21ldHJ5LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJv",
            "dG8aH2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8aHmdvb2dsZS9w",
            "cm90b2J1Zi93cmFwcGVycy5wcm90byK1AQoNU0UyVHJhamVjdG9yeRIuCgZw",
            "b2ludHMYASADKAsyHi5ib3NkeW4uYXBpLlNFMlRyYWplY3RvcnlQb2ludBIy",
            "Cg5yZWZlcmVuY2VfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXASOgoNaW50ZXJwb2xhdGlvbhgEIAEoDjIjLmJvc2R5bi5hcGkuUG9z",
            "aXRpb25hbEludGVycG9sYXRpb25KBAgCEAMicAoSU0UyVHJhamVjdG9yeVBv",
            "aW50EiEKBHBvc2UYASABKAsyEy5ib3NkeW4uYXBpLlNFMlBvc2USNwoUdGlt",
            "ZV9zaW5jZV9yZWZlcmVuY2UYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVy",
            "YXRpb24i9gEKDVNFM1RyYWplY3RvcnkSLgoGcG9pbnRzGAEgAygLMh4uYm9z",
            "ZHluLmFwaS5TRTNUcmFqZWN0b3J5UG9pbnQSMgoOcmVmZXJlbmNlX3RpbWUY",
            "AyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEj4KEXBvc19pbnRl",
            "cnBvbGF0aW9uGAQgASgOMiMuYm9zZHluLmFwaS5Qb3NpdGlvbmFsSW50ZXJw",
            "b2xhdGlvbhI7ChFhbmdfaW50ZXJwb2xhdGlvbhgFIAEoDjIgLmJvc2R5bi5h",
            "cGkuQW5ndWxhckludGVycG9sYXRpb25KBAgCEAMimwEKElNFM1RyYWplY3Rv",
            "cnlQb2ludBIhCgRwb3NlGAEgASgLMhMuYm9zZHluLmFwaS5TRTNQb3NlEikK",
            "CHZlbG9jaXR5GAIgASgLMhcuYm9zZHluLmFwaS5TRTNWZWxvY2l0eRI3ChR0",
            "aW1lX3NpbmNlX3JlZmVyZW5jZRgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5E",
            "dXJhdGlvbiKTAgoOVmVjM1RyYWplY3RvcnkSLwoGcG9pbnRzGAEgAygLMh8u",
            "Ym9zZHluLmFwaS5WZWMzVHJhamVjdG9yeVBvaW50EjIKDnJlZmVyZW5jZV90",
            "aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI+ChFwb3Nf",
            "aW50ZXJwb2xhdGlvbhgEIAEoDjIjLmJvc2R5bi5hcGkuUG9zaXRpb25hbElu",
            "dGVycG9sYXRpb24SKwoRc3RhcnRpbmdfdmVsb2NpdHkYBSABKAsyEC5ib3Nk",
            "eW4uYXBpLlZlYzMSKQoPZW5kaW5nX3ZlbG9jaXR5GAYgASgLMhAuYm9zZHlu",
            "LmFwaS5WZWMzSgQIAhADIoUBChNWZWMzVHJhamVjdG9yeVBvaW50Eh8KBXBv",
            "aW50GAEgASgLMhAuYm9zZHluLmFwaS5WZWMzEhQKDGxpbmVhcl9zcGVlZBgE",
            "IAEoARI3ChR0aW1lX3NpbmNlX3JlZmVyZW5jZRgDIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbiJ5ChBXcmVuY2hUcmFqZWN0b3J5EjEKBnBvaW50",
            "cxgBIAMoCzIhLmJvc2R5bi5hcGkuV3JlbmNoVHJhamVjdG9yeVBvaW50EjIK",
            "DnJlZmVyZW5jZV90aW1lGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVz",
            "dGFtcCJ0ChVXcmVuY2hUcmFqZWN0b3J5UG9pbnQSIgoGd3JlbmNoGAEgASgL",
            "MhIuYm9zZHluLmFwaS5XcmVuY2gSNwoUdGltZV9zaW5jZV9yZWZlcmVuY2UY",
            "AiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24itQEKEFNjYWxhclRy",
            "YWplY3RvcnkSMQoGcG9pbnRzGAEgAygLMiEuYm9zZHluLmFwaS5TY2FsYXJU",
            "cmFqZWN0b3J5UG9pbnQSMgoOcmVmZXJlbmNlX3RpbWUYAiABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuVGltZXN0YW1wEjoKDWludGVycG9sYXRpb24YAyABKA4y",
            "Iy5ib3NkeW4uYXBpLlBvc2l0aW9uYWxJbnRlcnBvbGF0aW9uIo8BChVTY2Fs",
            "YXJUcmFqZWN0b3J5UG9pbnQSDQoFcG9pbnQYASABKAESLgoIdmVsb2NpdHkY",
            "AiABKAsyHC5nb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUSNwoUdGltZV9z",
            "aW5jZV9yZWZlcmVuY2UYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b24qXgoXUG9zaXRpb25hbEludGVycG9sYXRpb24SFgoSUE9TX0lOVEVSUF9V",
            "TktOT1dOEAASFQoRUE9TX0lOVEVSUF9MSU5FQVIQARIUChBQT1NfSU5URVJQ",
            "X0NVQklDEAIqYQoUQW5ndWxhckludGVycG9sYXRpb24SFgoSQU5HX0lOVEVS",
            "UF9VTktOT1dOEAASFQoRQU5HX0lOVEVSUF9MSU5FQVIQARIaChZBTkdfSU5U",
            "RVJQX0NVQklDX0VVTEVSEAJCEUIPVHJhamVjdG9yeVByb3RvYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.GeometryReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Bosdyn.Api.PositionalInterpolation), typeof(global::Bosdyn.Api.AngularInterpolation), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2Trajectory), global::Bosdyn.Api.SE2Trajectory.Parser, new[]{ "Points", "ReferenceTime", "Interpolation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2TrajectoryPoint), global::Bosdyn.Api.SE2TrajectoryPoint.Parser, new[]{ "Pose", "TimeSinceReference" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE3Trajectory), global::Bosdyn.Api.SE3Trajectory.Parser, new[]{ "Points", "ReferenceTime", "PosInterpolation", "AngInterpolation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE3TrajectoryPoint), global::Bosdyn.Api.SE3TrajectoryPoint.Parser, new[]{ "Pose", "Velocity", "TimeSinceReference" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Vec3Trajectory), global::Bosdyn.Api.Vec3Trajectory.Parser, new[]{ "Points", "ReferenceTime", "PosInterpolation", "StartingVelocity", "EndingVelocity" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Vec3TrajectoryPoint), global::Bosdyn.Api.Vec3TrajectoryPoint.Parser, new[]{ "Point", "LinearSpeed", "TimeSinceReference" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.WrenchTrajectory), global::Bosdyn.Api.WrenchTrajectory.Parser, new[]{ "Points", "ReferenceTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.WrenchTrajectoryPoint), global::Bosdyn.Api.WrenchTrajectoryPoint.Parser, new[]{ "Wrench", "TimeSinceReference" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ScalarTrajectory), global::Bosdyn.Api.ScalarTrajectory.Parser, new[]{ "Points", "ReferenceTime", "Interpolation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ScalarTrajectoryPoint), global::Bosdyn.Api.ScalarTrajectoryPoint.Parser, new[]{ "Point", "Velocity", "TimeSinceReference" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Parameters for how positional trajectories will be interpolated on robot.
  /// </summary>
  public enum PositionalInterpolation {
    /// <summary>
    /// Unknown interpolation, do not use.
    /// </summary>
    [pbr::OriginalName("POS_INTERP_UNKNOWN")] PosInterpUnknown = 0,
    /// <summary>
    /// Linear interpolation for positional data.
    /// </summary>
    [pbr::OriginalName("POS_INTERP_LINEAR")] PosInterpLinear = 1,
    /// <summary>
    /// Cubic interpolation for positional data.
    /// </summary>
    [pbr::OriginalName("POS_INTERP_CUBIC")] PosInterpCubic = 2,
  }

  /// <summary>
  /// Parameters for how angular trajectories will be interpolated on robot.
  /// </summary>
  public enum AngularInterpolation {
    /// <summary>
    /// Unknown interpolation, do not use.
    /// </summary>
    [pbr::OriginalName("ANG_INTERP_UNKNOWN")] AngInterpUnknown = 0,
    /// <summary>
    /// Linear interpolation for angular data.
    /// </summary>
    [pbr::OriginalName("ANG_INTERP_LINEAR")] AngInterpLinear = 1,
    /// <summary>
    /// Cubic interpolation (using Euler method) for angular data.
    /// </summary>
    [pbr::OriginalName("ANG_INTERP_CUBIC_EULER")] AngInterpCubicEuler = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A 2D pose trajectory, which specified multiple points and the desired times the robot should
  /// reach these points.
  /// </summary>
  public sealed partial class SE2Trajectory : pb::IMessage<SE2Trajectory> {
    private static readonly pb::MessageParser<SE2Trajectory> _parser = new pb::MessageParser<SE2Trajectory>(() => new SE2Trajectory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE2Trajectory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2Trajectory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2Trajectory(SE2Trajectory other) : this() {
      points_ = other.points_.Clone();
      referenceTime_ = other.referenceTime_ != null ? other.referenceTime_.Clone() : null;
      interpolation_ = other.interpolation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2Trajectory Clone() {
      return new SE2Trajectory(this);
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.SE2TrajectoryPoint> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.SE2TrajectoryPoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.SE2TrajectoryPoint> points_ = new pbc::RepeatedField<global::Bosdyn.Api.SE2TrajectoryPoint>();
    /// <summary>
    /// The points in trajectory
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.SE2TrajectoryPoint> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "reference_time" field.</summary>
    public const int ReferenceTimeFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp referenceTime_;
    /// <summary>
    /// All trajectories specify times relative to this reference time. The reference time should be
    /// in robot clock. If this field is not included, this time will be the receive time of the
    /// command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReferenceTime {
      get { return referenceTime_; }
      set {
        referenceTime_ = value;
      }
    }

    /// <summary>Field number for the "interpolation" field.</summary>
    public const int InterpolationFieldNumber = 4;
    private global::Bosdyn.Api.PositionalInterpolation interpolation_ = 0;
    /// <summary>
    /// Parameters for how trajectories will be interpolated on robot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PositionalInterpolation Interpolation {
      get { return interpolation_; }
      set {
        interpolation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE2Trajectory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE2Trajectory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if (!object.Equals(ReferenceTime, other.ReferenceTime)) return false;
      if (Interpolation != other.Interpolation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      if (referenceTime_ != null) hash ^= ReferenceTime.GetHashCode();
      if (Interpolation != 0) hash ^= Interpolation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      points_.WriteTo(output, _repeated_points_codec);
      if (referenceTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ReferenceTime);
      }
      if (Interpolation != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Interpolation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      if (referenceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceTime);
      }
      if (Interpolation != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Interpolation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE2Trajectory other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      if (other.referenceTime_ != null) {
        if (referenceTime_ == null) {
          ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReferenceTime.MergeFrom(other.ReferenceTime);
      }
      if (other.Interpolation != 0) {
        Interpolation = other.Interpolation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 26: {
            if (referenceTime_ == null) {
              ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReferenceTime);
            break;
          }
          case 32: {
            Interpolation = (global::Bosdyn.Api.PositionalInterpolation) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A SE2 pose that can be used as a point within a trajectory.
  /// </summary>
  public sealed partial class SE2TrajectoryPoint : pb::IMessage<SE2TrajectoryPoint> {
    private static readonly pb::MessageParser<SE2TrajectoryPoint> _parser = new pb::MessageParser<SE2TrajectoryPoint>(() => new SE2TrajectoryPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE2TrajectoryPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryPoint(SE2TrajectoryPoint other) : this() {
      pose_ = other.pose_ != null ? other.pose_.Clone() : null;
      timeSinceReference_ = other.timeSinceReference_ != null ? other.timeSinceReference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryPoint Clone() {
      return new SE2TrajectoryPoint(this);
    }

    /// <summary>Field number for the "pose" field.</summary>
    public const int PoseFieldNumber = 1;
    private global::Bosdyn.Api.SE2Pose pose_;
    /// <summary>
    /// Required pose the robot will try and achieve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SE2Pose Pose {
      get { return pose_; }
      set {
        pose_ = value;
      }
    }

    /// <summary>Field number for the "time_since_reference" field.</summary>
    public const int TimeSinceReferenceFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration timeSinceReference_;
    /// <summary>
    /// The duration to reach the point relative to the trajectory reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TimeSinceReference {
      get { return timeSinceReference_; }
      set {
        timeSinceReference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE2TrajectoryPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE2TrajectoryPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Pose, other.Pose)) return false;
      if (!object.Equals(TimeSinceReference, other.TimeSinceReference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pose_ != null) hash ^= Pose.GetHashCode();
      if (timeSinceReference_ != null) hash ^= TimeSinceReference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pose_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Pose);
      }
      if (timeSinceReference_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TimeSinceReference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pose_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pose);
      }
      if (timeSinceReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeSinceReference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE2TrajectoryPoint other) {
      if (other == null) {
        return;
      }
      if (other.pose_ != null) {
        if (pose_ == null) {
          Pose = new global::Bosdyn.Api.SE2Pose();
        }
        Pose.MergeFrom(other.Pose);
      }
      if (other.timeSinceReference_ != null) {
        if (timeSinceReference_ == null) {
          TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TimeSinceReference.MergeFrom(other.TimeSinceReference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (pose_ == null) {
              Pose = new global::Bosdyn.Api.SE2Pose();
            }
            input.ReadMessage(Pose);
            break;
          }
          case 26: {
            if (timeSinceReference_ == null) {
              TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TimeSinceReference);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A 3D pose trajectory, which specified multiple poses (and velocities for each pose)
  /// and the desired times the robot should reach these points.
  /// </summary>
  public sealed partial class SE3Trajectory : pb::IMessage<SE3Trajectory> {
    private static readonly pb::MessageParser<SE3Trajectory> _parser = new pb::MessageParser<SE3Trajectory>(() => new SE3Trajectory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE3Trajectory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3Trajectory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3Trajectory(SE3Trajectory other) : this() {
      points_ = other.points_.Clone();
      referenceTime_ = other.referenceTime_ != null ? other.referenceTime_.Clone() : null;
      posInterpolation_ = other.posInterpolation_;
      angInterpolation_ = other.angInterpolation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3Trajectory Clone() {
      return new SE3Trajectory(this);
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.SE3TrajectoryPoint> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.SE3TrajectoryPoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.SE3TrajectoryPoint> points_ = new pbc::RepeatedField<global::Bosdyn.Api.SE3TrajectoryPoint>();
    /// <summary>
    /// The points in trajectory
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.SE3TrajectoryPoint> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "reference_time" field.</summary>
    public const int ReferenceTimeFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp referenceTime_;
    /// <summary>
    /// All trajectories specify times relative to this reference time. The reference time should be
    /// in robot clock. If this field is not included, this time will be the receive time of the
    /// command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReferenceTime {
      get { return referenceTime_; }
      set {
        referenceTime_ = value;
      }
    }

    /// <summary>Field number for the "pos_interpolation" field.</summary>
    public const int PosInterpolationFieldNumber = 4;
    private global::Bosdyn.Api.PositionalInterpolation posInterpolation_ = 0;
    /// <summary>
    /// Parameters for how trajectories will be interpolated on robot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PositionalInterpolation PosInterpolation {
      get { return posInterpolation_; }
      set {
        posInterpolation_ = value;
      }
    }

    /// <summary>Field number for the "ang_interpolation" field.</summary>
    public const int AngInterpolationFieldNumber = 5;
    private global::Bosdyn.Api.AngularInterpolation angInterpolation_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.AngularInterpolation AngInterpolation {
      get { return angInterpolation_; }
      set {
        angInterpolation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE3Trajectory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE3Trajectory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if (!object.Equals(ReferenceTime, other.ReferenceTime)) return false;
      if (PosInterpolation != other.PosInterpolation) return false;
      if (AngInterpolation != other.AngInterpolation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      if (referenceTime_ != null) hash ^= ReferenceTime.GetHashCode();
      if (PosInterpolation != 0) hash ^= PosInterpolation.GetHashCode();
      if (AngInterpolation != 0) hash ^= AngInterpolation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      points_.WriteTo(output, _repeated_points_codec);
      if (referenceTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ReferenceTime);
      }
      if (PosInterpolation != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) PosInterpolation);
      }
      if (AngInterpolation != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) AngInterpolation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      if (referenceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceTime);
      }
      if (PosInterpolation != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PosInterpolation);
      }
      if (AngInterpolation != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AngInterpolation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE3Trajectory other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      if (other.referenceTime_ != null) {
        if (referenceTime_ == null) {
          ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReferenceTime.MergeFrom(other.ReferenceTime);
      }
      if (other.PosInterpolation != 0) {
        PosInterpolation = other.PosInterpolation;
      }
      if (other.AngInterpolation != 0) {
        AngInterpolation = other.AngInterpolation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 26: {
            if (referenceTime_ == null) {
              ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReferenceTime);
            break;
          }
          case 32: {
            PosInterpolation = (global::Bosdyn.Api.PositionalInterpolation) input.ReadEnum();
            break;
          }
          case 40: {
            AngInterpolation = (global::Bosdyn.Api.AngularInterpolation) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A SE3 pose and velocity that can be used as a point within a trajectory.
  /// </summary>
  public sealed partial class SE3TrajectoryPoint : pb::IMessage<SE3TrajectoryPoint> {
    private static readonly pb::MessageParser<SE3TrajectoryPoint> _parser = new pb::MessageParser<SE3TrajectoryPoint>(() => new SE3TrajectoryPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE3TrajectoryPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3TrajectoryPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3TrajectoryPoint(SE3TrajectoryPoint other) : this() {
      pose_ = other.pose_ != null ? other.pose_.Clone() : null;
      velocity_ = other.velocity_ != null ? other.velocity_.Clone() : null;
      timeSinceReference_ = other.timeSinceReference_ != null ? other.timeSinceReference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE3TrajectoryPoint Clone() {
      return new SE3TrajectoryPoint(this);
    }

    /// <summary>Field number for the "pose" field.</summary>
    public const int PoseFieldNumber = 1;
    private global::Bosdyn.Api.SE3Pose pose_;
    /// <summary>
    /// Required pose the robot will try and achieve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SE3Pose Pose {
      get { return pose_; }
      set {
        pose_ = value;
      }
    }

    /// <summary>Field number for the "velocity" field.</summary>
    public const int VelocityFieldNumber = 2;
    private global::Bosdyn.Api.SE3Velocity velocity_;
    /// <summary>
    /// Optional velocity (linear and angular) the robot will try and achieve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.SE3Velocity Velocity {
      get { return velocity_; }
      set {
        velocity_ = value;
      }
    }

    /// <summary>Field number for the "time_since_reference" field.</summary>
    public const int TimeSinceReferenceFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration timeSinceReference_;
    /// <summary>
    /// The duration to reach the point relative to the trajectory reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TimeSinceReference {
      get { return timeSinceReference_; }
      set {
        timeSinceReference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE3TrajectoryPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE3TrajectoryPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Pose, other.Pose)) return false;
      if (!object.Equals(Velocity, other.Velocity)) return false;
      if (!object.Equals(TimeSinceReference, other.TimeSinceReference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pose_ != null) hash ^= Pose.GetHashCode();
      if (velocity_ != null) hash ^= Velocity.GetHashCode();
      if (timeSinceReference_ != null) hash ^= TimeSinceReference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pose_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Pose);
      }
      if (velocity_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Velocity);
      }
      if (timeSinceReference_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TimeSinceReference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pose_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pose);
      }
      if (velocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Velocity);
      }
      if (timeSinceReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeSinceReference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE3TrajectoryPoint other) {
      if (other == null) {
        return;
      }
      if (other.pose_ != null) {
        if (pose_ == null) {
          Pose = new global::Bosdyn.Api.SE3Pose();
        }
        Pose.MergeFrom(other.Pose);
      }
      if (other.velocity_ != null) {
        if (velocity_ == null) {
          Velocity = new global::Bosdyn.Api.SE3Velocity();
        }
        Velocity.MergeFrom(other.Velocity);
      }
      if (other.timeSinceReference_ != null) {
        if (timeSinceReference_ == null) {
          TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TimeSinceReference.MergeFrom(other.TimeSinceReference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (pose_ == null) {
              Pose = new global::Bosdyn.Api.SE3Pose();
            }
            input.ReadMessage(Pose);
            break;
          }
          case 18: {
            if (velocity_ == null) {
              Velocity = new global::Bosdyn.Api.SE3Velocity();
            }
            input.ReadMessage(Velocity);
            break;
          }
          case 26: {
            if (timeSinceReference_ == null) {
              TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TimeSinceReference);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A 3D point trajectory, described by 3D points, a starting and ending velocity, and
  /// a reference time.
  /// </summary>
  public sealed partial class Vec3Trajectory : pb::IMessage<Vec3Trajectory> {
    private static readonly pb::MessageParser<Vec3Trajectory> _parser = new pb::MessageParser<Vec3Trajectory>(() => new Vec3Trajectory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Vec3Trajectory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3Trajectory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3Trajectory(Vec3Trajectory other) : this() {
      points_ = other.points_.Clone();
      referenceTime_ = other.referenceTime_ != null ? other.referenceTime_.Clone() : null;
      posInterpolation_ = other.posInterpolation_;
      startingVelocity_ = other.startingVelocity_ != null ? other.startingVelocity_.Clone() : null;
      endingVelocity_ = other.endingVelocity_ != null ? other.endingVelocity_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3Trajectory Clone() {
      return new Vec3Trajectory(this);
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.Vec3TrajectoryPoint> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.Vec3TrajectoryPoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.Vec3TrajectoryPoint> points_ = new pbc::RepeatedField<global::Bosdyn.Api.Vec3TrajectoryPoint>();
    /// <summary>
    /// The points in trajectory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.Vec3TrajectoryPoint> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "reference_time" field.</summary>
    public const int ReferenceTimeFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp referenceTime_;
    /// <summary>
    /// All trajectories specify times relative to this reference time. The reference time should be
    /// in robot clock. If this field is not included, this time will be the receive time of the
    /// command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReferenceTime {
      get { return referenceTime_; }
      set {
        referenceTime_ = value;
      }
    }

    /// <summary>Field number for the "pos_interpolation" field.</summary>
    public const int PosInterpolationFieldNumber = 4;
    private global::Bosdyn.Api.PositionalInterpolation posInterpolation_ = 0;
    /// <summary>
    /// Parameters for how trajectories will be interpolated on robot.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PositionalInterpolation PosInterpolation {
      get { return posInterpolation_; }
      set {
        posInterpolation_ = value;
      }
    }

    /// <summary>Field number for the "starting_velocity" field.</summary>
    public const int StartingVelocityFieldNumber = 5;
    private global::Bosdyn.Api.Vec3 startingVelocity_;
    /// <summary>
    /// Velocity at the starting point of the trajectory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 StartingVelocity {
      get { return startingVelocity_; }
      set {
        startingVelocity_ = value;
      }
    }

    /// <summary>Field number for the "ending_velocity" field.</summary>
    public const int EndingVelocityFieldNumber = 6;
    private global::Bosdyn.Api.Vec3 endingVelocity_;
    /// <summary>
    /// Velocity at the ending point of the trajectory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 EndingVelocity {
      get { return endingVelocity_; }
      set {
        endingVelocity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Vec3Trajectory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Vec3Trajectory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if (!object.Equals(ReferenceTime, other.ReferenceTime)) return false;
      if (PosInterpolation != other.PosInterpolation) return false;
      if (!object.Equals(StartingVelocity, other.StartingVelocity)) return false;
      if (!object.Equals(EndingVelocity, other.EndingVelocity)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      if (referenceTime_ != null) hash ^= ReferenceTime.GetHashCode();
      if (PosInterpolation != 0) hash ^= PosInterpolation.GetHashCode();
      if (startingVelocity_ != null) hash ^= StartingVelocity.GetHashCode();
      if (endingVelocity_ != null) hash ^= EndingVelocity.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      points_.WriteTo(output, _repeated_points_codec);
      if (referenceTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ReferenceTime);
      }
      if (PosInterpolation != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) PosInterpolation);
      }
      if (startingVelocity_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(StartingVelocity);
      }
      if (endingVelocity_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(EndingVelocity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      if (referenceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceTime);
      }
      if (PosInterpolation != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PosInterpolation);
      }
      if (startingVelocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartingVelocity);
      }
      if (endingVelocity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndingVelocity);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Vec3Trajectory other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      if (other.referenceTime_ != null) {
        if (referenceTime_ == null) {
          ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReferenceTime.MergeFrom(other.ReferenceTime);
      }
      if (other.PosInterpolation != 0) {
        PosInterpolation = other.PosInterpolation;
      }
      if (other.startingVelocity_ != null) {
        if (startingVelocity_ == null) {
          StartingVelocity = new global::Bosdyn.Api.Vec3();
        }
        StartingVelocity.MergeFrom(other.StartingVelocity);
      }
      if (other.endingVelocity_ != null) {
        if (endingVelocity_ == null) {
          EndingVelocity = new global::Bosdyn.Api.Vec3();
        }
        EndingVelocity.MergeFrom(other.EndingVelocity);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 26: {
            if (referenceTime_ == null) {
              ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReferenceTime);
            break;
          }
          case 32: {
            PosInterpolation = (global::Bosdyn.Api.PositionalInterpolation) input.ReadEnum();
            break;
          }
          case 42: {
            if (startingVelocity_ == null) {
              StartingVelocity = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(StartingVelocity);
            break;
          }
          case 50: {
            if (endingVelocity_ == null) {
              EndingVelocity = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(EndingVelocity);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A 3D point (and linear velocity) that can be used as a point within a trajectory.
  /// </summary>
  public sealed partial class Vec3TrajectoryPoint : pb::IMessage<Vec3TrajectoryPoint> {
    private static readonly pb::MessageParser<Vec3TrajectoryPoint> _parser = new pb::MessageParser<Vec3TrajectoryPoint>(() => new Vec3TrajectoryPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Vec3TrajectoryPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3TrajectoryPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3TrajectoryPoint(Vec3TrajectoryPoint other) : this() {
      point_ = other.point_ != null ? other.point_.Clone() : null;
      linearSpeed_ = other.linearSpeed_;
      timeSinceReference_ = other.timeSinceReference_ != null ? other.timeSinceReference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Vec3TrajectoryPoint Clone() {
      return new Vec3TrajectoryPoint(this);
    }

    /// <summary>Field number for the "point" field.</summary>
    public const int PointFieldNumber = 1;
    private global::Bosdyn.Api.Vec3 point_;
    /// <summary>
    /// The point 3D position.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Vec3 Point {
      get { return point_; }
      set {
        point_ = value;
      }
    }

    /// <summary>Field number for the "linear_speed" field.</summary>
    public const int LinearSpeedFieldNumber = 4;
    private double linearSpeed_;
    /// <summary>
    /// These are all optional.  If nothing is specified, good defaults will be chosen
    /// server-side.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double LinearSpeed {
      get { return linearSpeed_; }
      set {
        linearSpeed_ = value;
      }
    }

    /// <summary>Field number for the "time_since_reference" field.</summary>
    public const int TimeSinceReferenceFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration timeSinceReference_;
    /// <summary>
    /// The duration to reach the point relative to the trajectory reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TimeSinceReference {
      get { return timeSinceReference_; }
      set {
        timeSinceReference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Vec3TrajectoryPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Vec3TrajectoryPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Point, other.Point)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(LinearSpeed, other.LinearSpeed)) return false;
      if (!object.Equals(TimeSinceReference, other.TimeSinceReference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (point_ != null) hash ^= Point.GetHashCode();
      if (LinearSpeed != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(LinearSpeed);
      if (timeSinceReference_ != null) hash ^= TimeSinceReference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (point_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Point);
      }
      if (timeSinceReference_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TimeSinceReference);
      }
      if (LinearSpeed != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(LinearSpeed);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (point_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Point);
      }
      if (LinearSpeed != 0D) {
        size += 1 + 8;
      }
      if (timeSinceReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeSinceReference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Vec3TrajectoryPoint other) {
      if (other == null) {
        return;
      }
      if (other.point_ != null) {
        if (point_ == null) {
          Point = new global::Bosdyn.Api.Vec3();
        }
        Point.MergeFrom(other.Point);
      }
      if (other.LinearSpeed != 0D) {
        LinearSpeed = other.LinearSpeed;
      }
      if (other.timeSinceReference_ != null) {
        if (timeSinceReference_ == null) {
          TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TimeSinceReference.MergeFrom(other.TimeSinceReference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (point_ == null) {
              Point = new global::Bosdyn.Api.Vec3();
            }
            input.ReadMessage(Point);
            break;
          }
          case 26: {
            if (timeSinceReference_ == null) {
              TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TimeSinceReference);
            break;
          }
          case 33: {
            LinearSpeed = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A time-based trajectories of wrenches.
  /// </summary>
  public sealed partial class WrenchTrajectory : pb::IMessage<WrenchTrajectory> {
    private static readonly pb::MessageParser<WrenchTrajectory> _parser = new pb::MessageParser<WrenchTrajectory>(() => new WrenchTrajectory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WrenchTrajectory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectory(WrenchTrajectory other) : this() {
      points_ = other.points_.Clone();
      referenceTime_ = other.referenceTime_ != null ? other.referenceTime_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectory Clone() {
      return new WrenchTrajectory(this);
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.WrenchTrajectoryPoint> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.WrenchTrajectoryPoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.WrenchTrajectoryPoint> points_ = new pbc::RepeatedField<global::Bosdyn.Api.WrenchTrajectoryPoint>();
    /// <summary>
    /// The wrenches in the trajectory
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.WrenchTrajectoryPoint> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "reference_time" field.</summary>
    public const int ReferenceTimeFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp referenceTime_;
    /// <summary>
    /// All trajectories specify times relative to this reference time. The reference time should be
    /// in robot clock. If this field is not included, this time will be the receive time of the
    /// command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReferenceTime {
      get { return referenceTime_; }
      set {
        referenceTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WrenchTrajectory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WrenchTrajectory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if (!object.Equals(ReferenceTime, other.ReferenceTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      if (referenceTime_ != null) hash ^= ReferenceTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      points_.WriteTo(output, _repeated_points_codec);
      if (referenceTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReferenceTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      if (referenceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WrenchTrajectory other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      if (other.referenceTime_ != null) {
        if (referenceTime_ == null) {
          ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReferenceTime.MergeFrom(other.ReferenceTime);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 18: {
            if (referenceTime_ == null) {
              ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReferenceTime);
            break;
          }
        }
      }
    }

  }

  public sealed partial class WrenchTrajectoryPoint : pb::IMessage<WrenchTrajectoryPoint> {
    private static readonly pb::MessageParser<WrenchTrajectoryPoint> _parser = new pb::MessageParser<WrenchTrajectoryPoint>(() => new WrenchTrajectoryPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WrenchTrajectoryPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectoryPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectoryPoint(WrenchTrajectoryPoint other) : this() {
      wrench_ = other.wrench_ != null ? other.wrench_.Clone() : null;
      timeSinceReference_ = other.timeSinceReference_ != null ? other.timeSinceReference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WrenchTrajectoryPoint Clone() {
      return new WrenchTrajectoryPoint(this);
    }

    /// <summary>Field number for the "wrench" field.</summary>
    public const int WrenchFieldNumber = 1;
    private global::Bosdyn.Api.Wrench wrench_;
    /// <summary>
    /// The wrench to apply at this point in time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.Wrench Wrench {
      get { return wrench_; }
      set {
        wrench_ = value;
      }
    }

    /// <summary>Field number for the "time_since_reference" field.</summary>
    public const int TimeSinceReferenceFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration timeSinceReference_;
    /// <summary>
    /// The duration to reach the point relative to the trajectory reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TimeSinceReference {
      get { return timeSinceReference_; }
      set {
        timeSinceReference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WrenchTrajectoryPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WrenchTrajectoryPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Wrench, other.Wrench)) return false;
      if (!object.Equals(TimeSinceReference, other.TimeSinceReference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (wrench_ != null) hash ^= Wrench.GetHashCode();
      if (timeSinceReference_ != null) hash ^= TimeSinceReference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (wrench_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Wrench);
      }
      if (timeSinceReference_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TimeSinceReference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (wrench_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Wrench);
      }
      if (timeSinceReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeSinceReference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WrenchTrajectoryPoint other) {
      if (other == null) {
        return;
      }
      if (other.wrench_ != null) {
        if (wrench_ == null) {
          Wrench = new global::Bosdyn.Api.Wrench();
        }
        Wrench.MergeFrom(other.Wrench);
      }
      if (other.timeSinceReference_ != null) {
        if (timeSinceReference_ == null) {
          TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TimeSinceReference.MergeFrom(other.TimeSinceReference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (wrench_ == null) {
              Wrench = new global::Bosdyn.Api.Wrench();
            }
            input.ReadMessage(Wrench);
            break;
          }
          case 18: {
            if (timeSinceReference_ == null) {
              TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TimeSinceReference);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A Point trajectory.
  /// </summary>
  public sealed partial class ScalarTrajectory : pb::IMessage<ScalarTrajectory> {
    private static readonly pb::MessageParser<ScalarTrajectory> _parser = new pb::MessageParser<ScalarTrajectory>(() => new ScalarTrajectory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScalarTrajectory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectory(ScalarTrajectory other) : this() {
      points_ = other.points_.Clone();
      referenceTime_ = other.referenceTime_ != null ? other.referenceTime_.Clone() : null;
      interpolation_ = other.interpolation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectory Clone() {
      return new ScalarTrajectory(this);
    }

    /// <summary>Field number for the "points" field.</summary>
    public const int PointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Bosdyn.Api.ScalarTrajectoryPoint> _repeated_points_codec
        = pb::FieldCodec.ForMessage(10, global::Bosdyn.Api.ScalarTrajectoryPoint.Parser);
    private readonly pbc::RepeatedField<global::Bosdyn.Api.ScalarTrajectoryPoint> points_ = new pbc::RepeatedField<global::Bosdyn.Api.ScalarTrajectoryPoint>();
    /// <summary>
    /// The points in trajectory
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Bosdyn.Api.ScalarTrajectoryPoint> Points {
      get { return points_; }
    }

    /// <summary>Field number for the "reference_time" field.</summary>
    public const int ReferenceTimeFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp referenceTime_;
    /// <summary>
    /// All trajectories specify times relative to this reference time. The reference time should be
    /// in robot clock. If this field is not included, this time will be the receive time of the
    /// command.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReferenceTime {
      get { return referenceTime_; }
      set {
        referenceTime_ = value;
      }
    }

    /// <summary>Field number for the "interpolation" field.</summary>
    public const int InterpolationFieldNumber = 3;
    private global::Bosdyn.Api.PositionalInterpolation interpolation_ = 0;
    /// <summary>
    /// Parameters for how trajectories will be interpolated on robot.
    /// (Note: ignored for ClawGripperCommand.Request, which will automatically
    /// select between cubic interpolation or a minimum time trajectory)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Bosdyn.Api.PositionalInterpolation Interpolation {
      get { return interpolation_; }
      set {
        interpolation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScalarTrajectory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScalarTrajectory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!points_.Equals(other.points_)) return false;
      if (!object.Equals(ReferenceTime, other.ReferenceTime)) return false;
      if (Interpolation != other.Interpolation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= points_.GetHashCode();
      if (referenceTime_ != null) hash ^= ReferenceTime.GetHashCode();
      if (Interpolation != 0) hash ^= Interpolation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      points_.WriteTo(output, _repeated_points_codec);
      if (referenceTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReferenceTime);
      }
      if (Interpolation != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Interpolation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += points_.CalculateSize(_repeated_points_codec);
      if (referenceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceTime);
      }
      if (Interpolation != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Interpolation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScalarTrajectory other) {
      if (other == null) {
        return;
      }
      points_.Add(other.points_);
      if (other.referenceTime_ != null) {
        if (referenceTime_ == null) {
          ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReferenceTime.MergeFrom(other.ReferenceTime);
      }
      if (other.Interpolation != 0) {
        Interpolation = other.Interpolation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            points_.AddEntriesFrom(input, _repeated_points_codec);
            break;
          }
          case 18: {
            if (referenceTime_ == null) {
              ReferenceTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReferenceTime);
            break;
          }
          case 24: {
            Interpolation = (global::Bosdyn.Api.PositionalInterpolation) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ScalarTrajectoryPoint : pb::IMessage<ScalarTrajectoryPoint> {
    private static readonly pb::MessageParser<ScalarTrajectoryPoint> _parser = new pb::MessageParser<ScalarTrajectoryPoint>(() => new ScalarTrajectoryPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScalarTrajectoryPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.TrajectoryReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectoryPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectoryPoint(ScalarTrajectoryPoint other) : this() {
      point_ = other.point_;
      Velocity = other.Velocity;
      timeSinceReference_ = other.timeSinceReference_ != null ? other.timeSinceReference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalarTrajectoryPoint Clone() {
      return new ScalarTrajectoryPoint(this);
    }

    /// <summary>Field number for the "point" field.</summary>
    public const int PointFieldNumber = 1;
    private double point_;
    /// <summary>
    /// Required position at the trajectory point's reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Point {
      get { return point_; }
      set {
        point_ = value;
      }
    }

    /// <summary>Field number for the "velocity" field.</summary>
    public const int VelocityFieldNumber = 2;
    private static readonly pb::FieldCodec<double?> _single_velocity_codec = pb::FieldCodec.ForStructWrapper<double>(18);
    private double? velocity_;
    /// <summary>
    /// Optional speed at the trajectory point's reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? Velocity {
      get { return velocity_; }
      set {
        velocity_ = value;
      }
    }


    /// <summary>Field number for the "time_since_reference" field.</summary>
    public const int TimeSinceReferenceFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration timeSinceReference_;
    /// <summary>
    /// The duration to reach the point relative to the trajectory reference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration TimeSinceReference {
      get { return timeSinceReference_; }
      set {
        timeSinceReference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScalarTrajectoryPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScalarTrajectoryPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Point, other.Point)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(Velocity, other.Velocity)) return false;
      if (!object.Equals(TimeSinceReference, other.TimeSinceReference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Point != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Point);
      if (velocity_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(Velocity);
      if (timeSinceReference_ != null) hash ^= TimeSinceReference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Point != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(Point);
      }
      if (velocity_ != null) {
        _single_velocity_codec.WriteTagAndValue(output, Velocity);
      }
      if (timeSinceReference_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TimeSinceReference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Point != 0D) {
        size += 1 + 8;
      }
      if (velocity_ != null) {
        size += _single_velocity_codec.CalculateSizeWithTag(Velocity);
      }
      if (timeSinceReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeSinceReference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScalarTrajectoryPoint other) {
      if (other == null) {
        return;
      }
      if (other.Point != 0D) {
        Point = other.Point;
      }
      if (other.velocity_ != null) {
        if (velocity_ == null || other.Velocity != 0D) {
          Velocity = other.Velocity;
        }
      }
      if (other.timeSinceReference_ != null) {
        if (timeSinceReference_ == null) {
          TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TimeSinceReference.MergeFrom(other.TimeSinceReference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            Point = input.ReadDouble();
            break;
          }
          case 18: {
            double? value = _single_velocity_codec.Read(input);
            if (velocity_ == null || value != 0D) {
              Velocity = value;
            }
            break;
          }
          case 26: {
            if (timeSinceReference_ == null) {
              TimeSinceReference = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TimeSinceReference);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
