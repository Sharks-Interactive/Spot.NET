// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Protos/basic_command.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Bosdyn.Api {

  /// <summary>Holder for reflection information generated from Protos/basic_command.proto</summary>
  public static partial class BasicCommandReflection {

    #region Descriptor
    /// <summary>File descriptor for Protos/basic_command.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BasicCommandReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChpQcm90b3MvYmFzaWNfY29tbWFuZC5wcm90bxIKYm9zZHluLmFwaRoVUHJv",
            "dG9zL2dlb21ldHJ5LnByb3RvGhdQcm90b3MvdHJhamVjdG9yeS5wcm90bxof",
            "Z29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90bxoeZ29vZ2xlL3Byb3Rv",
            "YnVmL3dyYXBwZXJzLnByb3RvIsoBChpSb2JvdENvbW1hbmRGZWVkYmFja1N0",
            "YXR1cyKrAQoGU3RhdHVzEhIKDlNUQVRVU19VTktOT1dOEAASFQoRU1RBVFVT",
            "X1BST0NFU1NJTkcQARIdChlTVEFUVVNfQ09NTUFORF9PVkVSUklEREVOEAIS",
            "HAoYU1RBVFVTX0NPTU1BTkRfVElNRURfT1VUEAMSFwoTU1RBVFVTX1JPQk9U",
            "X0ZST1pFThAEEiAKHFNUQVRVU19JTkNPTVBBVElCTEVfSEFSRFdBUkUQBSLu",
            "AgoYQmF0dGVyeUNoYW5nZVBvc2VDb21tYW5kGp8BCgdSZXF1ZXN0ElIKDmRp",
            "cmVjdGlvbl9oaW50GAEgASgOMjouYm9zZHluLmFwaS5CYXR0ZXJ5Q2hhbmdl",
            "UG9zZUNvbW1hbmQuUmVxdWVzdC5EaXJlY3Rpb25IaW50IkAKDURpcmVjdGlv",
            "bkhpbnQSEAoMSElOVF9VTktOT1dOEAASDgoKSElOVF9SSUdIVBABEg0KCUhJ",
            "TlRfTEVGVBACGq8BCghGZWVkYmFjaxJECgZzdGF0dXMYASABKA4yNC5ib3Nk",
            "eW4uYXBpLkJhdHRlcnlDaGFuZ2VQb3NlQ29tbWFuZC5GZWVkYmFjay5TdGF0",
            "dXMiXQoGU3RhdHVzEhIKDlNUQVRVU19VTktOT1dOEAASFAoQU1RBVFVTX0NP",
            "TVBMRVRFRBABEhYKElNUQVRVU19JTl9QUk9HUkVTUxACEhEKDVNUQVRVU19G",
            "QUlMRUQQAyIpChBTZWxmUmlnaHRDb21tYW5kGgkKB1JlcXVlc3QaCgoIRmVl",
            "ZGJhY2siJAoLU3RvcENvbW1hbmQaCQoHUmVxdWVzdBoKCghGZWVkYmFjayIm",
            "Cg1GcmVlemVDb21tYW5kGgkKB1JlcXVlc3QaCgoIRmVlZGJhY2sivAEKE1Nh",
            "ZmVQb3dlck9mZkNvbW1hbmQaCQoHUmVxdWVzdBqZAQoIRmVlZGJhY2sSPwoG",
            "c3RhdHVzGAEgASgOMi8uYm9zZHluLmFwaS5TYWZlUG93ZXJPZmZDb21tYW5k",
            "LkZlZWRiYWNrLlN0YXR1cyJMCgZTdGF0dXMSEgoOU1RBVFVTX1VOS05PV04Q",
            "ABIWChJTVEFUVVNfUE9XRVJFRF9PRkYQARIWChJTVEFUVVNfSU5fUFJPR1JF",
            "U1MQAiKDBAoUU0UyVHJhamVjdG9yeUNvbW1hbmQafgoHUmVxdWVzdBIsCghl",
            "bmRfdGltZRgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFgoO",
            "c2UyX2ZyYW1lX25hbWUYAyABKAkSLQoKdHJhamVjdG9yeRgCIAEoCzIZLmJv",
            "c2R5bi5hcGkuU0UyVHJhamVjdG9yeRrqAgoIRmVlZGJhY2sSQAoGc3RhdHVz",
            "GAEgASgOMjAuYm9zZHluLmFwaS5TRTJUcmFqZWN0b3J5Q29tbWFuZC5GZWVk",
            "YmFjay5TdGF0dXMSWgoUYm9keV9tb3ZlbWVudF9zdGF0dXMYAiABKA4yPC5i",
            "b3NkeW4uYXBpLlNFMlRyYWplY3RvcnlDb21tYW5kLkZlZWRiYWNrLkJvZHlN",
            "b3ZlbWVudFN0YXR1cyJgCgZTdGF0dXMSEgoOU1RBVFVTX1VOS05PV04QABIS",
            "Cg5TVEFUVVNfQVRfR09BTBABEhQKEFNUQVRVU19ORUFSX0dPQUwQAxIYChRT",
            "VEFUVVNfR09JTkdfVE9fR09BTBACIl4KEkJvZHlNb3ZlbWVudFN0YXR1cxIX",
            "ChNCT0RZX1NUQVRVU19VTktOT1dOEAASFgoSQk9EWV9TVEFUVVNfTU9WSU5H",
            "EAESFwoTQk9EWV9TVEFUVVNfU0VUVExFRBACItUBChJTRTJWZWxvY2l0eUNv",
            "bW1hbmQasgEKB1JlcXVlc3QSLAoIZW5kX3RpbWUYASABKAsyGi5nb29nbGUu",
            "cHJvdG9idWYuVGltZXN0YW1wEhYKDnNlMl9mcmFtZV9uYW1lGAUgASgJEikK",
            "CHZlbG9jaXR5GAIgASgLMhcuYm9zZHluLmFwaS5TRTJWZWxvY2l0eRIwCg9z",
            "bGV3X3JhdGVfbGltaXQYBCABKAsyFy5ib3NkeW4uYXBpLlNFMlZlbG9jaXR5",
            "SgQIAxAEGgoKCEZlZWRiYWNrIqkBCgpTaXRDb21tYW5kGgkKB1JlcXVlc3Qa",
            "jwEKCEZlZWRiYWNrEjYKBnN0YXR1cxgCIAEoDjImLmJvc2R5bi5hcGkuU2l0",
            "Q29tbWFuZC5GZWVkYmFjay5TdGF0dXMiSwoGU3RhdHVzEhIKDlNUQVRVU19V",
            "TktOT1dOEAASFQoRU1RBVFVTX0lTX1NJVFRJTkcQARIWChJTVEFUVVNfSU5f",
            "UFJPR1JFU1MQAiKuAQoMU3RhbmRDb21tYW5kGgkKB1JlcXVlc3QakgEKCEZl",
            "ZWRiYWNrEjgKBnN0YXR1cxgBIAEoDjIoLmJvc2R5bi5hcGkuU3RhbmRDb21t",
            "YW5kLkZlZWRiYWNrLlN0YXR1cyJMCgZTdGF0dXMSEgoOU1RBVFVTX1VOS05P",
            "V04QABIWChJTVEFUVVNfSVNfU1RBTkRJTkcQARIWChJTVEFUVVNfSU5fUFJP",
            "R1JFU1MQAiKbAgoNU3RhbmNlQ29tbWFuZBpbCgdSZXF1ZXN0EiwKCGVuZF90",
            "aW1lGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIiCgZzdGFu",
            "Y2UYAiABKAsyEi5ib3NkeW4uYXBpLlN0YW5jZRqsAQoIRmVlZGJhY2sSOQoG",
            "c3RhdHVzGAEgASgOMikuYm9zZHluLmFwaS5TdGFuY2VDb21tYW5kLkZlZWRi",
            "YWNrLlN0YXR1cyJlCgZTdGF0dXMSEgoOU1RBVFVTX1VOS05PV04QABISCg5T",
            "VEFUVVNfU1RBTkNFRBABEhoKFlNUQVRVU19HT0lOR19UT19TVEFOQ0UQAhIX",
            "ChNTVEFUVVNfVE9PX0ZBUl9BV0FZEAMiuQEKBlN0YW5jZRIWCg5zZTJfZnJh",
            "bWVfbmFtZRgDIAEoCRI9Cg5mb290X3Bvc2l0aW9ucxgCIAMoCzIlLmJvc2R5",
            "bi5hcGkuU3RhbmNlLkZvb3RQb3NpdGlvbnNFbnRyeRIQCghhY2N1cmFjeRgE",
            "IAEoAhpGChJGb290UG9zaXRpb25zRW50cnkSCwoDa2V5GAEgASgJEh8KBXZh",
            "bHVlGAIgASgLMhAuYm9zZHluLmFwaS5WZWMyOgI4ASJzChBGb2xsb3dBcm1D",
            "b21tYW5kGlMKB1JlcXVlc3QSLwoVYm9keV9vZmZzZXRfZnJvbV9oYW5kGAEg",
            "ASgLMhAuYm9zZHluLmFwaS5WZWMzEhcKD2Rpc2FibGVfd2Fsa2luZxgCIAEo",
            "CBoKCghGZWVkYmFjayLKAQoOQXJtRHJhZ0NvbW1hbmQaCQoHUmVxdWVzdBqs",
            "AQoIRmVlZGJhY2sSOgoGc3RhdHVzGAEgASgOMiouYm9zZHluLmFwaS5Bcm1E",
            "cmFnQ29tbWFuZC5GZWVkYmFjay5TdGF0dXMiZAoGU3RhdHVzEhIKDlNUQVRV",
            "U19VTktOT1dOEAASEwoPU1RBVFVTX0RSQUdHSU5HEAESFwoTU1RBVFVTX0dS",
            "QVNQX0ZBSUxFRBACEhgKFFNUQVRVU19PVEhFUl9GQUlMVVJFEAMikAcKHkNv",
            "bnN0cmFpbmVkTWFuaXB1bGF0aW9uQ29tbWFuZBr4BAoHUmVxdWVzdBISCgpm",
            "cmFtZV9uYW1lGAEgASgJEj8KI2luaXRfd3JlbmNoX2RpcmVjdGlvbl9pbl9m",
            "cmFtZV9uYW1lGAIgASgLMhIuYm9zZHluLmFwaS5XcmVuY2gSGgoQdGFuZ2Vu",
            "dGlhbF9zcGVlZBgDIAEoAUgAEhoKEHJvdGF0aW9uYWxfc3BlZWQYBCABKAFI",
            "ABIxCgtmb3JjZV9saW1pdBgFIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5Eb3Vi",
            "bGVWYWx1ZRIyCgx0b3JxdWVfbGltaXQYBiABKAsyHC5nb29nbGUucHJvdG9i",
            "dWYuRG91YmxlVmFsdWUSTgoJdGFza190eXBlGAcgASgOMjsuYm9zZHluLmFw",
            "aS5Db25zdHJhaW5lZE1hbmlwdWxhdGlvbkNvbW1hbmQuUmVxdWVzdC5UYXNr",
            "VHlwZRIsCghlbmRfdGltZRgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXAi7AEKCFRhc2tUeXBlEhUKEVRBU0tfVFlQRV9VTktOT1dOEAASJQoh",
            "VEFTS19UWVBFX1NFM19DSVJDTEVfRk9SQ0VfVE9SUVVFEAESJgoiVEFTS19U",
            "WVBFX1IzX0NJUkNMRV9FWFRSQURPRl9GT1JDRRACEiMKH1RBU0tfVFlQRV9T",
            "RTNfUk9UQVRJT05BTF9UT1JRVUUQAxIdChlUQVNLX1RZUEVfUjNfQ0lSQ0xF",
            "X0ZPUkNFEAQSHQoZVEFTS19UWVBFX1IzX0xJTkVBUl9GT1JDRRAFEhcKE1RB",
            "U0tfVFlQRV9IT0xEX1BPU0UQBkIMCgp0YXNrX3NwZWVkGvIBCghGZWVkYmFj",
            "axJKCgZzdGF0dXMYASABKA4yOi5ib3NkeW4uYXBpLkNvbnN0cmFpbmVkTWFu",
            "aXB1bGF0aW9uQ29tbWFuZC5GZWVkYmFjay5TdGF0dXMSNQoZZGVzaXJlZF93",
            "cmVuY2hfb2RvbV9mcmFtZRgCIAEoCzISLmJvc2R5bi5hcGkuV3JlbmNoImMK",
            "BlN0YXR1cxISCg5TVEFUVVNfVU5LTk9XThAAEhIKDlNUQVRVU19SVU5OSU5H",
            "EAESFwoTU1RBVFVTX0FSTV9JU19TVFVDSxACEhgKFFNUQVRVU19HUkFTUF9J",
            "U19MT1NUEANCE0IRQmFzaWNDb21tYW5kUHJvdG9iBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Bosdyn.Api.GeometryReflection.Descriptor, global::Bosdyn.Api.TrajectoryReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.RobotCommandFeedbackStatus), global::Bosdyn.Api.RobotCommandFeedbackStatus.Parser, null, null, new[]{ typeof(global::Bosdyn.Api.RobotCommandFeedbackStatus.Types.Status) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.BatteryChangePoseCommand), global::Bosdyn.Api.BatteryChangePoseCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request), global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request.Parser, new[]{ "DirectionHint" }, null, new[]{ typeof(global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request.Types.DirectionHint) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback), global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SelfRightCommand), global::Bosdyn.Api.SelfRightCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SelfRightCommand.Types.Request), global::Bosdyn.Api.SelfRightCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SelfRightCommand.Types.Feedback), global::Bosdyn.Api.SelfRightCommand.Types.Feedback.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StopCommand), global::Bosdyn.Api.StopCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StopCommand.Types.Request), global::Bosdyn.Api.StopCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StopCommand.Types.Feedback), global::Bosdyn.Api.StopCommand.Types.Feedback.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FreezeCommand), global::Bosdyn.Api.FreezeCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FreezeCommand.Types.Request), global::Bosdyn.Api.FreezeCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FreezeCommand.Types.Feedback), global::Bosdyn.Api.FreezeCommand.Types.Feedback.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SafePowerOffCommand), global::Bosdyn.Api.SafePowerOffCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SafePowerOffCommand.Types.Request), global::Bosdyn.Api.SafePowerOffCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback), global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2TrajectoryCommand), global::Bosdyn.Api.SE2TrajectoryCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2TrajectoryCommand.Types.Request), global::Bosdyn.Api.SE2TrajectoryCommand.Types.Request.Parser, new[]{ "EndTime", "Se2FrameName", "Trajectory" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback), global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Parser, new[]{ "Status", "BodyMovementStatus" }, null, new[]{ typeof(global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.Status), typeof(global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.BodyMovementStatus) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2VelocityCommand), global::Bosdyn.Api.SE2VelocityCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2VelocityCommand.Types.Request), global::Bosdyn.Api.SE2VelocityCommand.Types.Request.Parser, new[]{ "EndTime", "Se2FrameName", "Velocity", "SlewRateLimit" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SE2VelocityCommand.Types.Feedback), global::Bosdyn.Api.SE2VelocityCommand.Types.Feedback.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SitCommand), global::Bosdyn.Api.SitCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SitCommand.Types.Request), global::Bosdyn.Api.SitCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.SitCommand.Types.Feedback), global::Bosdyn.Api.SitCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.SitCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StandCommand), global::Bosdyn.Api.StandCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StandCommand.Types.Request), global::Bosdyn.Api.StandCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StandCommand.Types.Feedback), global::Bosdyn.Api.StandCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.StandCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StanceCommand), global::Bosdyn.Api.StanceCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StanceCommand.Types.Request), global::Bosdyn.Api.StanceCommand.Types.Request.Parser, new[]{ "EndTime", "Stance" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.StanceCommand.Types.Feedback), global::Bosdyn.Api.StanceCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.StanceCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.Stance), global::Bosdyn.Api.Stance.Parser, new[]{ "Se2FrameName", "FootPositions", "Accuracy" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FollowArmCommand), global::Bosdyn.Api.FollowArmCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FollowArmCommand.Types.Request), global::Bosdyn.Api.FollowArmCommand.Types.Request.Parser, new[]{ "BodyOffsetFromHand", "DisableWalking" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.FollowArmCommand.Types.Feedback), global::Bosdyn.Api.FollowArmCommand.Types.Feedback.Parser, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmDragCommand), global::Bosdyn.Api.ArmDragCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmDragCommand.Types.Request), global::Bosdyn.Api.ArmDragCommand.Types.Request.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ArmDragCommand.Types.Feedback), global::Bosdyn.Api.ArmDragCommand.Types.Feedback.Parser, new[]{ "Status" }, null, new[]{ typeof(global::Bosdyn.Api.ArmDragCommand.Types.Feedback.Types.Status) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ConstrainedManipulationCommand), global::Bosdyn.Api.ConstrainedManipulationCommand.Parser, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request), global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request.Parser, new[]{ "FrameName", "InitWrenchDirectionInFrameName", "TangentialSpeed", "RotationalSpeed", "ForceLimit", "TorqueLimit", "TaskType", "EndTime" }, new[]{ "TaskSpeed" }, new[]{ typeof(global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request.Types.TaskType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback), global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback.Parser, new[]{ "Status", "DesiredWrenchOdomFrame" }, null, new[]{ typeof(global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback.Types.Status) }, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class RobotCommandFeedbackStatus : pb::IMessage<RobotCommandFeedbackStatus> {
    private static readonly pb::MessageParser<RobotCommandFeedbackStatus> _parser = new pb::MessageParser<RobotCommandFeedbackStatus>(() => new RobotCommandFeedbackStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RobotCommandFeedbackStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RobotCommandFeedbackStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RobotCommandFeedbackStatus(RobotCommandFeedbackStatus other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RobotCommandFeedbackStatus Clone() {
      return new RobotCommandFeedbackStatus(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RobotCommandFeedbackStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RobotCommandFeedbackStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RobotCommandFeedbackStatus other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RobotCommandFeedbackStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Status {
        /// <summary>
        //// Behavior execution is in an unknown / unexpected state.
        /// </summary>
        [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
        /// <summary>
        //// The robot is actively working on the command
        /// </summary>
        [pbr::OriginalName("STATUS_PROCESSING")] Processing = 1,
        /// <summary>
        //// The command was replaced by a new command
        /// </summary>
        [pbr::OriginalName("STATUS_COMMAND_OVERRIDDEN")] CommandOverridden = 2,
        /// <summary>
        //// The command expired
        /// </summary>
        [pbr::OriginalName("STATUS_COMMAND_TIMED_OUT")] CommandTimedOut = 3,
        /// <summary>
        //// The robot is in an unsafe state, and will only respond to known safe commands.
        /// </summary>
        [pbr::OriginalName("STATUS_ROBOT_FROZEN")] RobotFrozen = 4,
        /// <summary>
        //// The request cannot be executed because the required hardware is missing.
        //// For example, an armless robot receiving a synchronized command with an arm_command
        //// request will return this value in the arm_command_feedback status.
        /// </summary>
        [pbr::OriginalName("STATUS_INCOMPATIBLE_HARDWARE")] IncompatibleHardware = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// Get the robot into a convenient pose for changing the battery
  /// </summary>
  public sealed partial class BatteryChangePoseCommand : pb::IMessage<BatteryChangePoseCommand> {
    private static readonly pb::MessageParser<BatteryChangePoseCommand> _parser = new pb::MessageParser<BatteryChangePoseCommand>(() => new BatteryChangePoseCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BatteryChangePoseCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryChangePoseCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryChangePoseCommand(BatteryChangePoseCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatteryChangePoseCommand Clone() {
      return new BatteryChangePoseCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BatteryChangePoseCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BatteryChangePoseCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BatteryChangePoseCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the BatteryChangePoseCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.BatteryChangePoseCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          directionHint_ = other.directionHint_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "direction_hint" field.</summary>
        public const int DirectionHintFieldNumber = 1;
        private global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request.Types.DirectionHint directionHint_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request.Types.DirectionHint DirectionHint {
          get { return directionHint_; }
          set {
            directionHint_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DirectionHint != other.DirectionHint) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (DirectionHint != 0) hash ^= DirectionHint.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (DirectionHint != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DirectionHint);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (DirectionHint != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DirectionHint);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.DirectionHint != 0) {
            DirectionHint = other.DirectionHint;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DirectionHint = (global::Bosdyn.Api.BatteryChangePoseCommand.Types.Request.Types.DirectionHint) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Request message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum DirectionHint {
            /// <summary>
            /// Unknown direction, just hold still
            /// </summary>
            [pbr::OriginalName("HINT_UNKNOWN")] HintUnknown = 0,
            /// <summary>
            /// Roll over right (right feet end up under the robot)
            /// </summary>
            [pbr::OriginalName("HINT_RIGHT")] HintRight = 1,
            /// <summary>
            /// Roll over left (left feet end up under the robot)
            /// </summary>
            [pbr::OriginalName("HINT_LEFT")] HintLeft = 2,
          }

        }
        #endregion

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.BatteryChangePoseCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback.Types.Status status_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.BatteryChangePoseCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot is finished rolling
            /// </summary>
            [pbr::OriginalName("STATUS_COMPLETED")] Completed = 1,
            /// <summary>
            /// Robot still in process of rolling over
            /// </summary>
            [pbr::OriginalName("STATUS_IN_PROGRESS")] InProgress = 2,
            /// <summary>
            /// Robot has failed to roll onto its side
            /// </summary>
            [pbr::OriginalName("STATUS_FAILED")] Failed = 3,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Move the robot into a "ready" position from which it can sit or stand up.
  /// </summary>
  public sealed partial class SelfRightCommand : pb::IMessage<SelfRightCommand> {
    private static readonly pb::MessageParser<SelfRightCommand> _parser = new pb::MessageParser<SelfRightCommand>(() => new SelfRightCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SelfRightCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SelfRightCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SelfRightCommand(SelfRightCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SelfRightCommand Clone() {
      return new SelfRightCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SelfRightCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SelfRightCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SelfRightCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SelfRightCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// SelfRight command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SelfRightCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// SelfRight command request provides no feedback.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SelfRightCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Stop the robot in place with minimal motion.
  /// </summary>
  public sealed partial class StopCommand : pb::IMessage<StopCommand> {
    private static readonly pb::MessageParser<StopCommand> _parser = new pb::MessageParser<StopCommand>(() => new StopCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StopCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopCommand(StopCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StopCommand Clone() {
      return new StopCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StopCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StopCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StopCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the StopCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Stop command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StopCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// Stop command provides no feedback.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StopCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Freeze all joints at their current positions (no balancing control).
  /// </summary>
  public sealed partial class FreezeCommand : pb::IMessage<FreezeCommand> {
    private static readonly pb::MessageParser<FreezeCommand> _parser = new pb::MessageParser<FreezeCommand>(() => new FreezeCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FreezeCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FreezeCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FreezeCommand(FreezeCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FreezeCommand Clone() {
      return new FreezeCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FreezeCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FreezeCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FreezeCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FreezeCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Freeze command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.FreezeCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// Freeze command provides no feedback.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.FreezeCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Get robot into a position where it is safe to power down, then power down. If the robot has
  /// fallen, it will power down directly. If the robot is not in a safe position, it will get to a
  /// safe position before powering down. The robot will not power down until it is in a safe state.
  /// </summary>
  public sealed partial class SafePowerOffCommand : pb::IMessage<SafePowerOffCommand> {
    private static readonly pb::MessageParser<SafePowerOffCommand> _parser = new pb::MessageParser<SafePowerOffCommand>(() => new SafePowerOffCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SafePowerOffCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SafePowerOffCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SafePowerOffCommand(SafePowerOffCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SafePowerOffCommand Clone() {
      return new SafePowerOffCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SafePowerOffCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SafePowerOffCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SafePowerOffCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SafePowerOffCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// SafePowerOff command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SafePowerOffCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// The SafePowerOff will provide feedback on whether or not it has succeeded in powering off
      /// the robot yet.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SafePowerOffCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback.Types.Status status_ = 0;
        /// <summary>
        /// Current status of the command.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.SafePowerOffCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot has powered off.
            /// </summary>
            [pbr::OriginalName("STATUS_POWERED_OFF")] PoweredOff = 1,
            /// <summary>
            /// Robot is trying to safely power off.
            /// </summary>
            [pbr::OriginalName("STATUS_IN_PROGRESS")] InProgress = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Move along a trajectory in 2D space.
  /// </summary>
  public sealed partial class SE2TrajectoryCommand : pb::IMessage<SE2TrajectoryCommand> {
    private static readonly pb::MessageParser<SE2TrajectoryCommand> _parser = new pb::MessageParser<SE2TrajectoryCommand>(() => new SE2TrajectoryCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE2TrajectoryCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryCommand(SE2TrajectoryCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2TrajectoryCommand Clone() {
      return new SE2TrajectoryCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE2TrajectoryCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE2TrajectoryCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE2TrajectoryCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SE2TrajectoryCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SE2TrajectoryCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
          se2FrameName_ = other.se2FrameName_;
          trajectory_ = other.trajectory_ != null ? other.trajectory_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "end_time" field.</summary>
        public const int EndTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
        /// <summary>
        /// The timestamp (in robot time) by which a command must finish executing.
        /// This is a required field and used to prevent runaway commands.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
          get { return endTime_; }
          set {
            endTime_ = value;
          }
        }

        /// <summary>Field number for the "se2_frame_name" field.</summary>
        public const int Se2FrameNameFieldNumber = 3;
        private string se2FrameName_ = "";
        /// <summary>
        /// The name of the frame that trajectory is relative to. The trajectory
        /// must be expressed in a gravity aligned frame, so either "vision",
        /// "odom", or "body". Any other provided se2_frame_name will be rejected
        /// and the trajectory command will not be exectuted.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Se2FrameName {
          get { return se2FrameName_; }
          set {
            se2FrameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "trajectory" field.</summary>
        public const int TrajectoryFieldNumber = 2;
        private global::Bosdyn.Api.SE2Trajectory trajectory_;
        /// <summary>
        /// The trajectory that the robot should follow, expressed in the frame
        /// identified by se2_frame_name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE2Trajectory Trajectory {
          get { return trajectory_; }
          set {
            trajectory_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EndTime, other.EndTime)) return false;
          if (Se2FrameName != other.Se2FrameName) return false;
          if (!object.Equals(Trajectory, other.Trajectory)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (endTime_ != null) hash ^= EndTime.GetHashCode();
          if (Se2FrameName.Length != 0) hash ^= Se2FrameName.GetHashCode();
          if (trajectory_ != null) hash ^= Trajectory.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (endTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EndTime);
          }
          if (trajectory_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Trajectory);
          }
          if (Se2FrameName.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(Se2FrameName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (endTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
          }
          if (Se2FrameName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Se2FrameName);
          }
          if (trajectory_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Trajectory);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.endTime_ != null) {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EndTime.MergeFrom(other.EndTime);
          }
          if (other.Se2FrameName.Length != 0) {
            Se2FrameName = other.Se2FrameName;
          }
          if (other.trajectory_ != null) {
            if (trajectory_ == null) {
              Trajectory = new global::Bosdyn.Api.SE2Trajectory();
            }
            Trajectory.MergeFrom(other.Trajectory);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (endTime_ == null) {
                  EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EndTime);
                break;
              }
              case 18: {
                if (trajectory_ == null) {
                  Trajectory = new global::Bosdyn.Api.SE2Trajectory();
                }
                input.ReadMessage(Trajectory);
                break;
              }
              case 26: {
                Se2FrameName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The SE2TrajectoryCommand will provide feedback on whether or not the robot has reached the
      /// final point of the trajectory.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SE2TrajectoryCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          bodyMovementStatus_ = other.bodyMovementStatus_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.Status status_ = 0;
        /// <summary>
        /// Current status of the command.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        /// <summary>Field number for the "body_movement_status" field.</summary>
        public const int BodyMovementStatusFieldNumber = 2;
        private global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.BodyMovementStatus bodyMovementStatus_ = 0;
        /// <summary>
        /// Current status of how the body is moving
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.BodyMovementStatus BodyMovementStatus {
          get { return bodyMovementStatus_; }
          set {
            bodyMovementStatus_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          if (BodyMovementStatus != other.BodyMovementStatus) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (BodyMovementStatus != 0) hash ^= BodyMovementStatus.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (BodyMovementStatus != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) BodyMovementStatus);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (BodyMovementStatus != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BodyMovementStatus);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          if (other.BodyMovementStatus != 0) {
            BodyMovementStatus = other.BodyMovementStatus;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
              case 16: {
                BodyMovementStatus = (global::Bosdyn.Api.SE2TrajectoryCommand.Types.Feedback.Types.BodyMovementStatus) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// The robot has arrived and is standing at the goal.
            /// </summary>
            [pbr::OriginalName("STATUS_AT_GOAL")] AtGoal = 1,
            /// <summary>
            /// The robot has arrived at the goal and is doing final positioning.
            /// </summary>
            [pbr::OriginalName("STATUS_NEAR_GOAL")] NearGoal = 3,
            /// <summary>
            /// The robot is attempting to go to a goal.
            /// </summary>
            [pbr::OriginalName("STATUS_GOING_TO_GOAL")] GoingToGoal = 2,
          }

          public enum BodyMovementStatus {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("BODY_STATUS_UNKNOWN")] BodyStatusUnknown = 0,
            /// <summary>
            /// The robot body is not settled at the goal.
            /// </summary>
            [pbr::OriginalName("BODY_STATUS_MOVING")] BodyStatusMoving = 1,
            /// <summary>
            /// The robot is at the goal and the body has stopped moving.
            /// </summary>
            [pbr::OriginalName("BODY_STATUS_SETTLED")] BodyStatusSettled = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Move the robot at a specific SE2 velocity for a fixed amount of time.
  /// </summary>
  public sealed partial class SE2VelocityCommand : pb::IMessage<SE2VelocityCommand> {
    private static readonly pb::MessageParser<SE2VelocityCommand> _parser = new pb::MessageParser<SE2VelocityCommand>(() => new SE2VelocityCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SE2VelocityCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2VelocityCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2VelocityCommand(SE2VelocityCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SE2VelocityCommand Clone() {
      return new SE2VelocityCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SE2VelocityCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SE2VelocityCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SE2VelocityCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SE2VelocityCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SE2VelocityCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
          se2FrameName_ = other.se2FrameName_;
          velocity_ = other.velocity_ != null ? other.velocity_.Clone() : null;
          slewRateLimit_ = other.slewRateLimit_ != null ? other.slewRateLimit_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "end_time" field.</summary>
        public const int EndTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
        /// <summary>
        /// The timestamp (in robot time) by which a command must finish executing. This is a
        /// required field and used to prevent runaway commands.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
          get { return endTime_; }
          set {
            endTime_ = value;
          }
        }

        /// <summary>Field number for the "se2_frame_name" field.</summary>
        public const int Se2FrameNameFieldNumber = 5;
        private string se2FrameName_ = "";
        /// <summary>
        /// The name of the frame that velocity and slew_rate_limit are relative to.
        /// The trajectory must be expressed in a gravity aligned frame, so either
        /// "vision", "odom", or "flat_body". Any other provided
        /// se2_frame_name will be rejected and the velocity command will not be executed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Se2FrameName {
          get { return se2FrameName_; }
          set {
            se2FrameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "velocity" field.</summary>
        public const int VelocityFieldNumber = 2;
        private global::Bosdyn.Api.SE2Velocity velocity_;
        /// <summary>
        /// Desired planar velocity of the robot body relative to se2_frame_name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE2Velocity Velocity {
          get { return velocity_; }
          set {
            velocity_ = value;
          }
        }

        /// <summary>Field number for the "slew_rate_limit" field.</summary>
        public const int SlewRateLimitFieldNumber = 4;
        private global::Bosdyn.Api.SE2Velocity slewRateLimit_;
        /// <summary>
        /// If set, limits how quickly velocity can change relative to se2_frame_name.
        /// Otherwise, robot may decide to limit velocities using default settings.
        /// These values should be non-negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SE2Velocity SlewRateLimit {
          get { return slewRateLimit_; }
          set {
            slewRateLimit_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EndTime, other.EndTime)) return false;
          if (Se2FrameName != other.Se2FrameName) return false;
          if (!object.Equals(Velocity, other.Velocity)) return false;
          if (!object.Equals(SlewRateLimit, other.SlewRateLimit)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (endTime_ != null) hash ^= EndTime.GetHashCode();
          if (Se2FrameName.Length != 0) hash ^= Se2FrameName.GetHashCode();
          if (velocity_ != null) hash ^= Velocity.GetHashCode();
          if (slewRateLimit_ != null) hash ^= SlewRateLimit.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (endTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EndTime);
          }
          if (velocity_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Velocity);
          }
          if (slewRateLimit_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(SlewRateLimit);
          }
          if (Se2FrameName.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(Se2FrameName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (endTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
          }
          if (Se2FrameName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Se2FrameName);
          }
          if (velocity_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Velocity);
          }
          if (slewRateLimit_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SlewRateLimit);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.endTime_ != null) {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EndTime.MergeFrom(other.EndTime);
          }
          if (other.Se2FrameName.Length != 0) {
            Se2FrameName = other.Se2FrameName;
          }
          if (other.velocity_ != null) {
            if (velocity_ == null) {
              Velocity = new global::Bosdyn.Api.SE2Velocity();
            }
            Velocity.MergeFrom(other.Velocity);
          }
          if (other.slewRateLimit_ != null) {
            if (slewRateLimit_ == null) {
              SlewRateLimit = new global::Bosdyn.Api.SE2Velocity();
            }
            SlewRateLimit.MergeFrom(other.SlewRateLimit);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (endTime_ == null) {
                  EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EndTime);
                break;
              }
              case 18: {
                if (velocity_ == null) {
                  Velocity = new global::Bosdyn.Api.SE2Velocity();
                }
                input.ReadMessage(Velocity);
                break;
              }
              case 34: {
                if (slewRateLimit_ == null) {
                  SlewRateLimit = new global::Bosdyn.Api.SE2Velocity();
                }
                input.ReadMessage(SlewRateLimit);
                break;
              }
              case 42: {
                Se2FrameName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Planar velocity commands provide no feedback.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SE2VelocityCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Sit the robot down in its current position.
  /// </summary>
  public sealed partial class SitCommand : pb::IMessage<SitCommand> {
    private static readonly pb::MessageParser<SitCommand> _parser = new pb::MessageParser<SitCommand>(() => new SitCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SitCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SitCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SitCommand(SitCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SitCommand Clone() {
      return new SitCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SitCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SitCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SitCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SitCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Sit command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SitCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.SitCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 2;
        private global::Bosdyn.Api.SitCommand.Types.Feedback.Types.Status status_ = 0;
        /// <summary>
        /// Current status of the command.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.SitCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 16: {
                Status = (global::Bosdyn.Api.SitCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot is currently sitting.
            /// </summary>
            [pbr::OriginalName("STATUS_IS_SITTING")] IsSitting = 1,
            /// <summary>
            /// Robot is trying to sit.
            /// </summary>
            [pbr::OriginalName("STATUS_IN_PROGRESS")] InProgress = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// The stand the robot up in its current position.
  /// </summary>
  public sealed partial class StandCommand : pb::IMessage<StandCommand> {
    private static readonly pb::MessageParser<StandCommand> _parser = new pb::MessageParser<StandCommand>(() => new StandCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StandCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StandCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StandCommand(StandCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StandCommand Clone() {
      return new StandCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StandCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StandCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StandCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the StandCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Stand command request takes no additional arguments.
      /// </summary>
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StandCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// The StandCommand will provide feedback on whether or not the robot has finished
      /// standing up.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StandCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.StandCommand.Types.Feedback.Types.Status status_ = 0;
        /// <summary>
        /// Current status of the command.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.StandCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.StandCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot has finished standing up and has completed desired body trajectory.
            /// Robot is not attempting to move.
            /// </summary>
            [pbr::OriginalName("STATUS_IS_STANDING")] IsStanding = 1,
            /// <summary>
            /// Robot is trying to come to a steady stand.
            /// </summary>
            [pbr::OriginalName("STATUS_IN_PROGRESS")] InProgress = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Precise foot placement
  /// This can be used to reposition the robots feet in place.
  /// </summary>
  public sealed partial class StanceCommand : pb::IMessage<StanceCommand> {
    private static readonly pb::MessageParser<StanceCommand> _parser = new pb::MessageParser<StanceCommand>(() => new StanceCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StanceCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StanceCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StanceCommand(StanceCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StanceCommand Clone() {
      return new StanceCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StanceCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StanceCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StanceCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the StanceCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StanceCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
          stance_ = other.stance_ != null ? other.stance_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "end_time" field.</summary>
        public const int EndTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
        /// <summary>
        //// The timestamp (in robot time) by which a command must finish executing.
        //// This is a required field and used to prevent runaway commands.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
          get { return endTime_; }
          set {
            endTime_ = value;
          }
        }

        /// <summary>Field number for the "stance" field.</summary>
        public const int StanceFieldNumber = 2;
        private global::Bosdyn.Api.Stance stance_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Stance Stance {
          get { return stance_; }
          set {
            stance_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EndTime, other.EndTime)) return false;
          if (!object.Equals(Stance, other.Stance)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (endTime_ != null) hash ^= EndTime.GetHashCode();
          if (stance_ != null) hash ^= Stance.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (endTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EndTime);
          }
          if (stance_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Stance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (endTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
          }
          if (stance_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Stance);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.endTime_ != null) {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EndTime.MergeFrom(other.EndTime);
          }
          if (other.stance_ != null) {
            if (stance_ == null) {
              Stance = new global::Bosdyn.Api.Stance();
            }
            Stance.MergeFrom(other.Stance);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (endTime_ == null) {
                  EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EndTime);
                break;
              }
              case 18: {
                if (stance_ == null) {
                  Stance = new global::Bosdyn.Api.Stance();
                }
                input.ReadMessage(Stance);
                break;
              }
            }
          }
        }

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.StanceCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.StanceCommand.Types.Feedback.Types.Status status_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.StanceCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.StanceCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot has finished moving feet and they are at the specified position
            /// </summary>
            [pbr::OriginalName("STATUS_STANCED")] Stanced = 1,
            /// <summary>
            /// Robot is in the process of moving feet to specified position
            /// </summary>
            [pbr::OriginalName("STATUS_GOING_TO_STANCE")] GoingToStance = 2,
            /// <summary>
            /// Robot is not moving, the specified stance was too far away.
            /// Hint: Try using SE2TrajectoryCommand to safely put the robot at the
            ///       correct location first.
            /// </summary>
            [pbr::OriginalName("STATUS_TOO_FAR_AWAY")] TooFarAway = 3,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class Stance : pb::IMessage<Stance> {
    private static readonly pb::MessageParser<Stance> _parser = new pb::MessageParser<Stance>(() => new Stance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Stance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Stance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Stance(Stance other) : this() {
      se2FrameName_ = other.se2FrameName_;
      footPositions_ = other.footPositions_.Clone();
      accuracy_ = other.accuracy_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Stance Clone() {
      return new Stance(this);
    }

    /// <summary>Field number for the "se2_frame_name" field.</summary>
    public const int Se2FrameNameFieldNumber = 3;
    private string se2FrameName_ = "";
    /// <summary>
    /// The frame name which the desired foot_positions are described in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Se2FrameName {
      get { return se2FrameName_; }
      set {
        se2FrameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "foot_positions" field.</summary>
    public const int FootPositionsFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Bosdyn.Api.Vec2>.Codec _map_footPositions_codec
        = new pbc::MapField<string, global::Bosdyn.Api.Vec2>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Bosdyn.Api.Vec2.Parser), 18);
    private readonly pbc::MapField<string, global::Bosdyn.Api.Vec2> footPositions_ = new pbc::MapField<string, global::Bosdyn.Api.Vec2>();
    /// <summary>
    /// Map of foot name to its x,y location in specified frame.
    /// Required positions for spot: "fl", "fr", "hl", "hr".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Bosdyn.Api.Vec2> FootPositions {
      get { return footPositions_; }
    }

    /// <summary>Field number for the "accuracy" field.</summary>
    public const int AccuracyFieldNumber = 4;
    private float accuracy_;
    /// <summary>
    /// Required foot positional accuracy in meters
    /// Advised = 0.05 ( 5cm)
    /// Minimum = 0.02 ( 2cm)
    /// Maximum = 0.10 (10cm)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Accuracy {
      get { return accuracy_; }
      set {
        accuracy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Stance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Stance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Se2FrameName != other.Se2FrameName) return false;
      if (!FootPositions.Equals(other.FootPositions)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Accuracy, other.Accuracy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Se2FrameName.Length != 0) hash ^= Se2FrameName.GetHashCode();
      hash ^= FootPositions.GetHashCode();
      if (Accuracy != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Accuracy);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      footPositions_.WriteTo(output, _map_footPositions_codec);
      if (Se2FrameName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Se2FrameName);
      }
      if (Accuracy != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Accuracy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Se2FrameName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Se2FrameName);
      }
      size += footPositions_.CalculateSize(_map_footPositions_codec);
      if (Accuracy != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Stance other) {
      if (other == null) {
        return;
      }
      if (other.Se2FrameName.Length != 0) {
        Se2FrameName = other.Se2FrameName;
      }
      footPositions_.Add(other.footPositions_);
      if (other.Accuracy != 0F) {
        Accuracy = other.Accuracy;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            footPositions_.AddEntriesFrom(input, _map_footPositions_codec);
            break;
          }
          case 26: {
            Se2FrameName = input.ReadString();
            break;
          }
          case 37: {
            Accuracy = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The base will move in response to the hand's location, allow the arm to reach beyond
  /// its current workspace.  If the hand is moved forward, the body will begin walking
  /// forward to keep the base at the desired offset from the hand.
  /// </summary>
  public sealed partial class FollowArmCommand : pb::IMessage<FollowArmCommand> {
    private static readonly pb::MessageParser<FollowArmCommand> _parser = new pb::MessageParser<FollowArmCommand>(() => new FollowArmCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FollowArmCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FollowArmCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FollowArmCommand(FollowArmCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FollowArmCommand Clone() {
      return new FollowArmCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FollowArmCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FollowArmCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FollowArmCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FollowArmCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.FollowArmCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          bodyOffsetFromHand_ = other.bodyOffsetFromHand_ != null ? other.bodyOffsetFromHand_.Clone() : null;
          disableWalking_ = other.disableWalking_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "body_offset_from_hand" field.</summary>
        public const int BodyOffsetFromHandFieldNumber = 1;
        private global::Bosdyn.Api.Vec3 bodyOffsetFromHand_;
        /// <summary>
        /// Optional body offset from the hand.
        /// For example, to have the body 0.75 meters behind the hand, use (0.75, 0, 0)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Vec3 BodyOffsetFromHand {
          get { return bodyOffsetFromHand_; }
          set {
            bodyOffsetFromHand_ = value;
          }
        }

        /// <summary>Field number for the "disable_walking" field.</summary>
        public const int DisableWalkingFieldNumber = 2;
        private bool disableWalking_;
        /// <summary>
        /// Optional. If true, the body will be restricted to body orientation offsets only.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DisableWalking {
          get { return disableWalking_; }
          set {
            disableWalking_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BodyOffsetFromHand, other.BodyOffsetFromHand)) return false;
          if (DisableWalking != other.DisableWalking) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (bodyOffsetFromHand_ != null) hash ^= BodyOffsetFromHand.GetHashCode();
          if (DisableWalking != false) hash ^= DisableWalking.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (bodyOffsetFromHand_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BodyOffsetFromHand);
          }
          if (DisableWalking != false) {
            output.WriteRawTag(16);
            output.WriteBool(DisableWalking);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (bodyOffsetFromHand_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BodyOffsetFromHand);
          }
          if (DisableWalking != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.bodyOffsetFromHand_ != null) {
            if (bodyOffsetFromHand_ == null) {
              BodyOffsetFromHand = new global::Bosdyn.Api.Vec3();
            }
            BodyOffsetFromHand.MergeFrom(other.BodyOffsetFromHand);
          }
          if (other.DisableWalking != false) {
            DisableWalking = other.DisableWalking;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (bodyOffsetFromHand_ == null) {
                  BodyOffsetFromHand = new global::Bosdyn.Api.Vec3();
                }
                input.ReadMessage(BodyOffsetFromHand);
                break;
              }
              case 16: {
                DisableWalking = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// FollowArmCommand commands provide no feedback.
      /// </summary>
      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.FollowArmCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class ArmDragCommand : pb::IMessage<ArmDragCommand> {
    private static readonly pb::MessageParser<ArmDragCommand> _parser = new pb::MessageParser<ArmDragCommand>(() => new ArmDragCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ArmDragCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmDragCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmDragCommand(ArmDragCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ArmDragCommand Clone() {
      return new ArmDragCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ArmDragCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ArmDragCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ArmDragCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ArmDragCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ArmDragCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ArmDragCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.ArmDragCommand.Types.Feedback.Types.Status status_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ArmDragCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.ArmDragCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Robot is dragging.
            /// </summary>
            [pbr::OriginalName("STATUS_DRAGGING")] Dragging = 1,
            /// <summary>
            /// Robot is not dragging because grasp failed.
            /// This could be due to a lost grasp during a drag, or because the gripper isn't in a good
            /// position at the time of request. You'll have to reposition or regrasp and then send a
            /// new drag request to overcome this type of error.
            /// Note: When requesting drag, make sure the gripper is positioned in front of the robot (not to the side of or
            /// above the robot body).
            /// </summary>
            [pbr::OriginalName("STATUS_GRASP_FAILED")] GraspFailed = 2,
            /// <summary>
            /// Robot is not dragging for another reason.
            /// This might be because the gripper isn't holding an item.
            /// You can continue dragging once you resolve this type of error (i.e. by sending an ApiGraspOverride request).
            /// Note: When requesting drag, be sure to that the robot knows it's holding something (or use APIGraspOverride to
            /// OVERRIDE_HOLDING).
            /// </summary>
            [pbr::OriginalName("STATUS_OTHER_FAILURE")] OtherFailure = 3,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class ConstrainedManipulationCommand : pb::IMessage<ConstrainedManipulationCommand> {
    private static readonly pb::MessageParser<ConstrainedManipulationCommand> _parser = new pb::MessageParser<ConstrainedManipulationCommand>(() => new ConstrainedManipulationCommand());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConstrainedManipulationCommand> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Bosdyn.Api.BasicCommandReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConstrainedManipulationCommand() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConstrainedManipulationCommand(ConstrainedManipulationCommand other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConstrainedManipulationCommand Clone() {
      return new ConstrainedManipulationCommand(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConstrainedManipulationCommand);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConstrainedManipulationCommand other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConstrainedManipulationCommand other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ConstrainedManipulationCommand message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Request : pb::IMessage<Request> {
        private static readonly pb::MessageParser<Request> _parser = new pb::MessageParser<Request>(() => new Request());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Request> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ConstrainedManipulationCommand.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request(Request other) : this() {
          frameName_ = other.frameName_;
          initWrenchDirectionInFrameName_ = other.initWrenchDirectionInFrameName_ != null ? other.initWrenchDirectionInFrameName_.Clone() : null;
          ForceLimit = other.ForceLimit;
          TorqueLimit = other.TorqueLimit;
          taskType_ = other.taskType_;
          endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
          switch (other.TaskSpeedCase) {
            case TaskSpeedOneofCase.TangentialSpeed:
              TangentialSpeed = other.TangentialSpeed;
              break;
            case TaskSpeedOneofCase.RotationalSpeed:
              RotationalSpeed = other.RotationalSpeed;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Request Clone() {
          return new Request(this);
        }

        /// <summary>Field number for the "frame_name" field.</summary>
        public const int FrameNameFieldNumber = 1;
        private string frameName_ = "";
        /// <summary>
        /// Frame that the initial wrench will be expressed in
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FrameName {
          get { return frameName_; }
          set {
            frameName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "init_wrench_direction_in_frame_name" field.</summary>
        public const int InitWrenchDirectionInFrameNameFieldNumber = 2;
        private global::Bosdyn.Api.Wrench initWrenchDirectionInFrameName_;
        /// <summary>
        /// Direction of the initial wrench to be applied
        /// Depending on the task, either the force vector or the
        /// torque vector are required to be specified. The required
        /// vector should not have a magnitude of zero and will be
        /// normalized to 1. For tasks that require the force vector,
        /// the torque vector can still be specified as a non-zero vector
        /// if it is a good guess of the axis of rotation of the task.
        /// (for e.g. TASK_TYPE_SE3_ROTATIONAL_TORQUE task types.)
        /// Note that if both vectors are non-zero, they have to be perpendicular.
        /// Once the constrained manipulation system estimates the
        /// constraint, the init_wrench_direction and frame_name
        /// will no longer be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Wrench InitWrenchDirectionInFrameName {
          get { return initWrenchDirectionInFrameName_; }
          set {
            initWrenchDirectionInFrameName_ = value;
          }
        }

        /// <summary>Field number for the "tangential_speed" field.</summary>
        public const int TangentialSpeedFieldNumber = 3;
        /// <summary>
        /// Recommended values are in the range of [-4, 4] m/s
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double TangentialSpeed {
          get { return taskSpeedCase_ == TaskSpeedOneofCase.TangentialSpeed ? (double) taskSpeed_ : 0D; }
          set {
            taskSpeed_ = value;
            taskSpeedCase_ = TaskSpeedOneofCase.TangentialSpeed;
          }
        }

        /// <summary>Field number for the "rotational_speed" field.</summary>
        public const int RotationalSpeedFieldNumber = 4;
        /// <summary>
        /// Recommended values are in the range of [-4, 4] rad/s
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double RotationalSpeed {
          get { return taskSpeedCase_ == TaskSpeedOneofCase.RotationalSpeed ? (double) taskSpeed_ : 0D; }
          set {
            taskSpeed_ = value;
            taskSpeedCase_ = TaskSpeedOneofCase.RotationalSpeed;
          }
        }

        /// <summary>Field number for the "force_limit" field.</summary>
        public const int ForceLimitFieldNumber = 5;
        private static readonly pb::FieldCodec<double?> _single_forceLimit_codec = pb::FieldCodec.ForStructWrapper<double>(42);
        private double? forceLimit_;
        /// <summary>
        /// The limit on the force that is applied on any translation direction
        /// Value must be positive
        /// If unspecified, a default value of 40 N will be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? ForceLimit {
          get { return forceLimit_; }
          set {
            forceLimit_ = value;
          }
        }


        /// <summary>Field number for the "torque_limit" field.</summary>
        public const int TorqueLimitFieldNumber = 6;
        private static readonly pb::FieldCodec<double?> _single_torqueLimit_codec = pb::FieldCodec.ForStructWrapper<double>(50);
        private double? torqueLimit_;
        /// <summary>
        /// The limit on the torque that is applied on any rotational direction
        /// Value must be positive
        /// If unspecified, a default value of 4 Nm will be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double? TorqueLimit {
          get { return torqueLimit_; }
          set {
            torqueLimit_ = value;
          }
        }


        /// <summary>Field number for the "task_type" field.</summary>
        public const int TaskTypeFieldNumber = 7;
        private global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request.Types.TaskType taskType_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request.Types.TaskType TaskType {
          get { return taskType_; }
          set {
            taskType_ = value;
          }
        }

        /// <summary>Field number for the "end_time" field.</summary>
        public const int EndTimeFieldNumber = 8;
        private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
        /// <summary>
        /// The timestamp (in robot time) by which a command must finish executing.
        /// This is a required field and used to prevent runaway commands.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
          get { return endTime_; }
          set {
            endTime_ = value;
          }
        }

        private object taskSpeed_;
        /// <summary>Enum of possible cases for the "task_speed" oneof.</summary>
        public enum TaskSpeedOneofCase {
          None = 0,
          TangentialSpeed = 3,
          RotationalSpeed = 4,
        }
        private TaskSpeedOneofCase taskSpeedCase_ = TaskSpeedOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TaskSpeedOneofCase TaskSpeedCase {
          get { return taskSpeedCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTaskSpeed() {
          taskSpeedCase_ = TaskSpeedOneofCase.None;
          taskSpeed_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Request);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Request other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FrameName != other.FrameName) return false;
          if (!object.Equals(InitWrenchDirectionInFrameName, other.InitWrenchDirectionInFrameName)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TangentialSpeed, other.TangentialSpeed)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RotationalSpeed, other.RotationalSpeed)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(ForceLimit, other.ForceLimit)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(TorqueLimit, other.TorqueLimit)) return false;
          if (TaskType != other.TaskType) return false;
          if (!object.Equals(EndTime, other.EndTime)) return false;
          if (TaskSpeedCase != other.TaskSpeedCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FrameName.Length != 0) hash ^= FrameName.GetHashCode();
          if (initWrenchDirectionInFrameName_ != null) hash ^= InitWrenchDirectionInFrameName.GetHashCode();
          if (taskSpeedCase_ == TaskSpeedOneofCase.TangentialSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TangentialSpeed);
          if (taskSpeedCase_ == TaskSpeedOneofCase.RotationalSpeed) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RotationalSpeed);
          if (forceLimit_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(ForceLimit);
          if (torqueLimit_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(TorqueLimit);
          if (TaskType != 0) hash ^= TaskType.GetHashCode();
          if (endTime_ != null) hash ^= EndTime.GetHashCode();
          hash ^= (int) taskSpeedCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FrameName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FrameName);
          }
          if (initWrenchDirectionInFrameName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(InitWrenchDirectionInFrameName);
          }
          if (taskSpeedCase_ == TaskSpeedOneofCase.TangentialSpeed) {
            output.WriteRawTag(25);
            output.WriteDouble(TangentialSpeed);
          }
          if (taskSpeedCase_ == TaskSpeedOneofCase.RotationalSpeed) {
            output.WriteRawTag(33);
            output.WriteDouble(RotationalSpeed);
          }
          if (forceLimit_ != null) {
            _single_forceLimit_codec.WriteTagAndValue(output, ForceLimit);
          }
          if (torqueLimit_ != null) {
            _single_torqueLimit_codec.WriteTagAndValue(output, TorqueLimit);
          }
          if (TaskType != 0) {
            output.WriteRawTag(56);
            output.WriteEnum((int) TaskType);
          }
          if (endTime_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(EndTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FrameName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FrameName);
          }
          if (initWrenchDirectionInFrameName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitWrenchDirectionInFrameName);
          }
          if (taskSpeedCase_ == TaskSpeedOneofCase.TangentialSpeed) {
            size += 1 + 8;
          }
          if (taskSpeedCase_ == TaskSpeedOneofCase.RotationalSpeed) {
            size += 1 + 8;
          }
          if (forceLimit_ != null) {
            size += _single_forceLimit_codec.CalculateSizeWithTag(ForceLimit);
          }
          if (torqueLimit_ != null) {
            size += _single_torqueLimit_codec.CalculateSizeWithTag(TorqueLimit);
          }
          if (TaskType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TaskType);
          }
          if (endTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Request other) {
          if (other == null) {
            return;
          }
          if (other.FrameName.Length != 0) {
            FrameName = other.FrameName;
          }
          if (other.initWrenchDirectionInFrameName_ != null) {
            if (initWrenchDirectionInFrameName_ == null) {
              InitWrenchDirectionInFrameName = new global::Bosdyn.Api.Wrench();
            }
            InitWrenchDirectionInFrameName.MergeFrom(other.InitWrenchDirectionInFrameName);
          }
          if (other.forceLimit_ != null) {
            if (forceLimit_ == null || other.ForceLimit != 0D) {
              ForceLimit = other.ForceLimit;
            }
          }
          if (other.torqueLimit_ != null) {
            if (torqueLimit_ == null || other.TorqueLimit != 0D) {
              TorqueLimit = other.TorqueLimit;
            }
          }
          if (other.TaskType != 0) {
            TaskType = other.TaskType;
          }
          if (other.endTime_ != null) {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EndTime.MergeFrom(other.EndTime);
          }
          switch (other.TaskSpeedCase) {
            case TaskSpeedOneofCase.TangentialSpeed:
              TangentialSpeed = other.TangentialSpeed;
              break;
            case TaskSpeedOneofCase.RotationalSpeed:
              RotationalSpeed = other.RotationalSpeed;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                FrameName = input.ReadString();
                break;
              }
              case 18: {
                if (initWrenchDirectionInFrameName_ == null) {
                  InitWrenchDirectionInFrameName = new global::Bosdyn.Api.Wrench();
                }
                input.ReadMessage(InitWrenchDirectionInFrameName);
                break;
              }
              case 25: {
                TangentialSpeed = input.ReadDouble();
                break;
              }
              case 33: {
                RotationalSpeed = input.ReadDouble();
                break;
              }
              case 42: {
                double? value = _single_forceLimit_codec.Read(input);
                if (forceLimit_ == null || value != 0D) {
                  ForceLimit = value;
                }
                break;
              }
              case 50: {
                double? value = _single_torqueLimit_codec.Read(input);
                if (torqueLimit_ == null || value != 0D) {
                  TorqueLimit = value;
                }
                break;
              }
              case 56: {
                TaskType = (global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Request.Types.TaskType) input.ReadEnum();
                break;
              }
              case 66: {
                if (endTime_ == null) {
                  EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EndTime);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Request message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Geometrical category of a task. See the constrained_manipulation_helper function
          /// for examples of each of these categories. For e.g. SE3_CIRCLE_FORCE_TORQUE corresponds
          /// to lever type objects.
          /// </summary>
          public enum TaskType {
            [pbr::OriginalName("TASK_TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// This task type corresponds to circular tasks where
            /// both the end-effector position and orientation rotate about a circle to manipulate.
            /// The constrained manipulation logic will generate forces and torques in this case.
            /// Example tasks are: A lever or a ball valve with a solid grasp
            /// This task type will require an initial force vector specified
            /// in init_wrench_direction_in_frame_name. A torque vector can be specified
            /// as well if a good initial guess of the axis of rotation of the task is available.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_SE3_CIRCLE_FORCE_TORQUE")] Se3CircleForceTorque = 1,
            /// <summary>
            /// This task type corresponds to circular tasks that have an extra degree of freedom.
            /// In these tasks the end-effector position rotates about a circle
            /// but the orientation does not need to follow a circle (can remain fixed).
            /// The constrained manipulation logic will generate translational forces in this case.
            /// Example tasks are: A crank that has a loose handle and moves in a circle
            /// and the end-effector is free to rotate about the handle in one direction.
            /// This task type will require an initial force vector specified
            /// in init_wrench_direction_in_frame_name.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_R3_CIRCLE_EXTRADOF_FORCE")] R3CircleExtradofForce = 2,
            /// <summary>
            /// This task type corresponds to purely rotational tasks.
            /// In these tasks the orientation of the end-effector follows a circle,
            /// and the position remains fixed. The robot will apply a torque at the
            /// end-effector in these tasks.
            /// Example tasks are: rotating a knob or valve that does not have a lever arm.
            /// This task type will require an initial torque vector specified
            /// in init_wrench_direction_in_frame_name.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_SE3_ROTATIONAL_TORQUE")] Se3RotationalTorque = 3,
            /// <summary>
            /// This task type corresponds to circular tasks where
            /// the end-effector position and orientation rotate about a circle
            /// but the orientation does always strictly follow the circle due to slips.
            /// The constrained manipulation logic will generate translational forces in this case.
            /// Example tasks are: manipulating a cabinet where the grasp on handle is not very rigid
            /// or can often slip.
            /// This task type will require an initial force vector specified
            /// in init_wrench_direction_in_frame_name.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_R3_CIRCLE_FORCE")] R3CircleForce = 4,
            /// <summary>
            /// This task type corresponds to linear tasks where
            /// the end-effector position moves in a line
            /// but the orientation does not need to change.
            /// The constrained manipulation logic will generate a force in this case.
            /// Example tasks are: A crank that has a loose handle, or manipulating
            /// a cabinet where the grasp of the handle is loose and the end-effector is free
            /// to rotate about the handle in one direction.
            /// This task type will require an initial force vector specified
            /// in init_wrench_direction_in_frame_name.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_R3_LINEAR_FORCE")] R3LinearForce = 5,
            /// <summary>
            /// This option simply holds the hand in place with stiff impedance control.
            /// You can use this mode at the beginning of a constrained manipulation task or to
            /// hold position while transitioning between two different constrained manipulation tasks.
            /// The target pose to hold will be the measured hand pose upon transitioning to constrained
            /// manipulation or upon switching to this task type. 
            /// This mode should only be used during constrained manipulation tasks,
            /// since it uses impedance control to hold the hand in place.
            /// This is not intended to stop the arm during position control moves.
            /// </summary>
            [pbr::OriginalName("TASK_TYPE_HOLD_POSE")] HoldPose = 6,
          }

        }
        #endregion

      }

      public sealed partial class Feedback : pb::IMessage<Feedback> {
        private static readonly pb::MessageParser<Feedback> _parser = new pb::MessageParser<Feedback>(() => new Feedback());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Feedback> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Bosdyn.Api.ConstrainedManipulationCommand.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback(Feedback other) : this() {
          status_ = other.status_;
          desiredWrenchOdomFrame_ = other.desiredWrenchOdomFrame_ != null ? other.desiredWrenchOdomFrame_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Feedback Clone() {
          return new Feedback(this);
        }

        /// <summary>Field number for the "status" field.</summary>
        public const int StatusFieldNumber = 1;
        private global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback.Types.Status status_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback.Types.Status Status {
          get { return status_; }
          set {
            status_ = value;
          }
        }

        /// <summary>Field number for the "desired_wrench_odom_frame" field.</summary>
        public const int DesiredWrenchOdomFrameFieldNumber = 2;
        private global::Bosdyn.Api.Wrench desiredWrenchOdomFrame_;
        /// <summary>
        /// Desired wrench in odom world frame, applied at hand frame origin
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Bosdyn.Api.Wrench DesiredWrenchOdomFrame {
          get { return desiredWrenchOdomFrame_; }
          set {
            desiredWrenchOdomFrame_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Feedback);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Feedback other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Status != other.Status) return false;
          if (!object.Equals(DesiredWrenchOdomFrame, other.DesiredWrenchOdomFrame)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Status != 0) hash ^= Status.GetHashCode();
          if (desiredWrenchOdomFrame_ != null) hash ^= DesiredWrenchOdomFrame.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Status != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Status);
          }
          if (desiredWrenchOdomFrame_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DesiredWrenchOdomFrame);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Status != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
          }
          if (desiredWrenchOdomFrame_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DesiredWrenchOdomFrame);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Feedback other) {
          if (other == null) {
            return;
          }
          if (other.Status != 0) {
            Status = other.Status;
          }
          if (other.desiredWrenchOdomFrame_ != null) {
            if (desiredWrenchOdomFrame_ == null) {
              DesiredWrenchOdomFrame = new global::Bosdyn.Api.Wrench();
            }
            DesiredWrenchOdomFrame.MergeFrom(other.DesiredWrenchOdomFrame);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Status = (global::Bosdyn.Api.ConstrainedManipulationCommand.Types.Feedback.Types.Status) input.ReadEnum();
                break;
              }
              case 18: {
                if (desiredWrenchOdomFrame_ == null) {
                  DesiredWrenchOdomFrame = new global::Bosdyn.Api.Wrench();
                }
                input.ReadMessage(DesiredWrenchOdomFrame);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Feedback message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Status {
            /// <summary>
            /// STATUS_UNKNOWN should never be used. If used, an internal error has happened.
            /// </summary>
            [pbr::OriginalName("STATUS_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Constrained manipulation is working as expected
            /// </summary>
            [pbr::OriginalName("STATUS_RUNNING")] Running = 1,
            /// <summary>
            /// Arm is stuck, either force is being applied in a direction
            /// where the affordance can't move or not enough force is applied
            /// </summary>
            [pbr::OriginalName("STATUS_ARM_IS_STUCK")] ArmIsStuck = 2,
            /// <summary>
            /// The grasp was lost. In this situation, constrained manipulation
            /// will stop applying force, and will hold the last position.
            /// </summary>
            [pbr::OriginalName("STATUS_GRASP_IS_LOST")] GraspIsLost = 3,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
